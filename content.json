{"meta":{"title":"有幸的个人小站","subtitle":"code is poetry","description":"这是作者为五十年后的自己留下的，感恩生活。","author":"xiaoqinghua 有幸","url":"http://xiaoqinghua.site"},"pages":[],"posts":[{"title":"MySql的B+Tree","slug":"MySql的B+Tree","date":"2019-11-07T07:52:59.000Z","updated":"2019-11-08T09:42:07.599Z","comments":true,"path":"MySql的B+Tree.html","link":"","permalink":"http://xiaoqinghua.site/MySql的B+Tree.html","excerpt":"","text":"前言索引这个词，相信大家已经相当熟悉了，都知道MySQL的索引主要以B+树为主，但是要问到为什么用B+树呢。 索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。 索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在 [1,2,3,4] 中找到4这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。索引在 mysql 数据库中分三类： B+树索引、Hash索引、全文索引 今天要介绍的是工作开发中最常接触到 innodb存储引中的的B+树索引。 要介绍B+树索引，就不得不提二叉查找树，平衡二叉树和B树这三种数据结构。B+树就是从他们演化来的。 二叉查找树 从图中可以看到，我们为 user表（用户信息表）建立了一个二叉查找树的索引。图中的圆为二叉查找树的节点，节点中存储了键(key)和数据(data)。 键对应 user 表中的 id，数据对应 user 表中的行数据。二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。 顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。 如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下： 将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点 &gt; 的右子节点作为当前节点。 继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。 把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12,name=xm。 利用二叉查找树我们只需要 3次 即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6次 才能找到。 平衡二叉树 这个时候可以看到我们的二叉查找树变成了一个链表。 如果我们需要查找id=17的用户信息，我们需要查找7次，也就相当于全表扫描了。 导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。 为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 每个节点的左右子树的高度差不能超过1。 下面是平衡二叉树和非平衡二叉树的对比： 由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树。 平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。 平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。 B树因为内存的易失性。一般情况下，我们都会选择将user表中的数据和索引存储在磁盘这种外围设备中。 但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。 另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。 如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。 如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。 那说明什么？ 说明每个磁盘块仅仅存储一个键值和数据！ 那如果我们要存储海量的数据呢？ 可以想象到二叉树的节点将会非常多，高度也会及其高，我们查找数据时也会进行很多次磁盘IO，我们查找数据的效率将会极低！ 为了解决平衡二叉树的这个弊端，我们应该寻找 一种单个节点可以存储多个键值和数据的平衡树。 也就是我们接下来要说的B树。 图中的p节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。 图中的每个节点称为页，页就是我们上面说的磁盘块，在mysql中数据读取的基本单位都是页，所以我们这里叫做页更符合mysql中索引的底层数据结构。 从上图可以看出，B树相对于平衡二叉树，每个节点存储了 更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低。基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。 假如我们要查找 id=28 的用户信息，那么我们在上图B树中查找的流程如下： 先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。 将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。 将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。 B+树B+树是对B树的进一步优化。让我们先来看下B+树的结构图： 根据上图我们来看下B+树和B树有什么不同: B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。 因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。 上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是说上图中的B+树索引就是innodb中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。通过上图可以看到，在innodb中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。MyISAM中的B+树索引实现与innodb中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。 聚簇索引 VS 非聚簇索引在MySQL中，B+树索引按照存储方式的不同分为聚集索引和非聚集索引。这里我们着重介绍innodb中的聚集索引和非聚集索引。 聚集索引（聚簇索引）：以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这是因为innodb是把数据存放在B+树中的，而B+树的键值就是主键，在B+树的叶子节点中，存储了表中所有的数据。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。 非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。 利用聚簇索引和非聚簇索引查找数据如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下B+树索引查找数据方法。 利用聚簇索引查找数据 还是这张B+树索引图，现在我们应该知道这就是聚集索引，表中的数据存储在其中。现在假设我们要查找id&gt;=18并且id&lt;40的用户数据。对应的sql语句为select * from user where id&gt;=18 and id&lt;40，其中id为主键。具体的查找过程如下： 一般根节点都是常驻内存的，也就是说页1已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。 从内存中读取到页1，要查找这个id&gt;=18 and id &lt;40或者范围值，我们首先需要找到id=18的键值。 从页1中我们可以找到键值18，此时我们需要根据指针p2，定位到页3。 要从页3中查找数据，我们就需要拿着p2指针去磁盘中进行读取页3。 从磁盘中读取页3后将页3放入内存中，然后进行查找，我们可以找到键值18，然后再拿到页3中的指针p1，定位到页8。 同样的页8页不在内存中，我们需要再去磁盘中将页8读取到内存中。 将页8读取到内存中后。 因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值18。 此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值18对应的数据。 因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页8中的键值依次进行遍历查找并匹配满足条件的数据。 我们可以一直找到键值为22的数据，然后页8中就没有数据了，此时我们需要拿着页8中的p指针去读取页9中的数据。 因为页9不在内存中，就又会加载页9到内存中，并通过和页8中一样的方式进行数据的查找，直到将页12加载到内存中，发现41大于40，此时不满足条件。 那么查找到此终止。 最终我们找到满足条件的所有数据为： (18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt)。 总共12条记录。 下面看下具体的查找流程图： 利用非聚簇索引查找数据 这个非聚集索引表示的是用户age的索引，此时表结构是这样的。 id name age 1 zs 23 2 ls 17 在叶子节点中，不在存储所有的数据了，存储的是键值和主键。对于叶子节点中的x-y，比如1-1。左边的1表示的是索引的键值，右边的1表示的是主键值。如果我们要找到幸运数字为33的用户信息，对应的sql语句为select * from user where age=23。查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。下面看下具体的查找流程图： 在MyISAM中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。 总结","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"MySql","slug":"Code/MySql","permalink":"http://xiaoqinghua.site/categories/Code/MySql/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"http://xiaoqinghua.site/tags/MySql/"}]},{"title":"Java内存模型JMM总结","slug":"Java内存模型JMM总结","date":"2019-10-16T03:21:51.000Z","updated":"2019-10-16T10:25:55.694Z","comments":true,"path":"Java内存模型JMM总结.html","link":"","permalink":"http://xiaoqinghua.site/Java内存模型JMM总结.html","excerpt":"","text":"Java内存模型（JMM）从 volatile 说起英文：volatile 的意思是不稳定的;挥发性的；Java：volatile 用于修饰变量，被volatile修饰的共享变量，就具有了以下两点特性： 1.保证了不同线程对该变量操作的内存可见性 2.禁止指令重排序 Java内存模型（JMM）Java虚拟机（JVM）规范试图定义一种 Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果（write once, run anywhere）。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以就在CPU里加了好几层高速缓存（计算机世界很多问题都可以靠增加一个缓存来解决）。JMM是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式; 在JMM里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主内存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值再同步回主内存。 直接看图： 在线程执行时，首先会从主存中 read 变量值，再 load 到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。 使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。（缓存不一致）比如看下面一个例子： 1i = i + 1; 假设 i 初值为 0，当只有一个线程执行它时，结果肯定得到 1，当两个线程执行时，会得到结果 2吗？这倒不一定了。可能存在这种情况： 123456Thread1： load i from 主存 // i = 0 i + 1 // i = 1Thread2： load i from主存 // 因为Thread1还没将i的值写回主存，所以i还是0 i + 1 // i = 1Thread1: save i to 主存Thread2： save i to 主存 如果两个线程按照上面的执行流程，那么 i 最后的值就是 1 了。如果最后的写回主存生效的慢，你再读取 i 的值，都可能是0，这就是缓存不一致问题。 JMM主要就是围绕着如何在并发过程中处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile 跟可见性和有序性都有关； 三大特性（原子性、可见性、有序性） 1.原子性(Atomicity)：Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如：i = 2;j = i;i++;i = i + 1;上面4个操作中，i = 2 是读取操作，必定是原子性操作，j = i 不原子性操作，分为两步，一是读取 i的值，然后再赋值给 j , 这就是2步操作了，称不上原子操作；i++ 和 i = i + 1 其实是等效的，读取 i 的值，加 1，再写回主存，是3步操作了。 所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。 这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。 有个例外是，虚拟机规范中允许对 64 位数据类型 (long 和 double)，分为 2 次 32 位的操作来处理，但是最新JDK实现还是实现了原子操作的。 JMM只实现了基本的原子性，像上面 i++ 那样的操作，必须借助于 synchronized 和 Lock 来保证整块代码的原子性了。线程在释放锁之前，必然会把 i 的值刷回到主存的。 可见性(Visibility)：Java 就是利用 volatile 来提供可见性的。 当一个变量被 volatile 修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。 其实通过 synchronized 和 Lock 也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是 synchronized 和 Lock 的开销都更大。 有序性（Ordering） JMM是允许编译器和处理器对指令重排序的，但是规定了 as-if-serial 语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段： 123int v = 3; // Aint t = 4; // Bint s = v * t; // C 上面的语句，可以按照 A-&gt;B-&gt;C 执行，结果为 12 ;但是也可以按照 B-&gt;A-&gt;C 的顺序执行，因为A、B 是两句独立的语句，而 C 则依赖于 A、B，所以 A、B 可以重排序，但是 C 却不能排到 A、B 的前面。JMM 保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。比如这样的代码： 12345678910111213int a = 0;bool flag = false;public void write() &#123; a = 2; //1 flag = true; //2&#125;public void multiply() &#123; if (flag) &#123; //3 int result = a * a;//4 &#125;&#125; 假如有两个线程执行上述代码段，线程1先执行 write 方法，随后线程2再执行 multiply 方法，最后result 的值一定是 4 吗？ 如图所示，write 方法里的 1 和 2 做了重排序，线程1先对 flag 赋值为 true，随后执行到线程2，result 直接计算出结果为 0，再到线程1，这时候 a 才赋值为 2, 很明显迟了一步。 这时候可以为 flag 加上 volatile 关键字，禁止重排序，可以确保程序的有序性，也可以上重量级的 synchronized 和 Lock 来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。 另外，JMM具备一些先天的有序性, 即不需要通过任何手段就可以保证的有序性，通常称为 happens-before 原则。&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;定义了如下 happens-before 规则： 1.程序顺序规则： 一个线程中的每个操作，happens-before 于该线程中的任意后续操作 2.监视器锁规则：对一个线程的解锁，happens-before 于随后对这个线程的加锁 3.volatile变量规则： 对一个 volatile 变量的写，happens-before 于后续对这个 volatile 变量的读 4.传递性：如果 A happens-before B ,且 B happens-before C, 那么 A happens-before C 5.start()规则： 如果线程A执行操作 ThreadB_start() (启动线程B) , 那么 A线程的ThreadB_start() happens-before 于B中的任意操作 6.join()原则： 如果A执行 ThreadB.join() 并且成功返回，那么线程B中的任意操作 happens-before 于线程A从ThreadB.join()操作成功返回。 7.interrupt()原则： 对线程 interrupt() 方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测是否有中断发生 8.finalize()原则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始 volatile如何满足并发编程的三大特性那就要重提 volatile 变量规则： 对一个 volatile 变量的写，happens-before 于后续对这个 volatile 变量的读。 其实就是如果一个变量声明成是 volatile 的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说 volatile 关键字可以保证可见性以及有序性。 继续拿上面的一段代码举例： 12345678910111213int a = 0;bool flag = false;public void write() &#123; a = 2; //1 flag = true; //2&#125;public void multiply() &#123; if (flag) &#123; //3 int result = a * a;//4 &#125;&#125; 这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行 write 方法，线程2再执行 multiply 方法，由于线程1是在工作内存里把 flag 赋值为 true，不一定立刻写回主存，所以线程2执行时，multiply 方法再从主存读 flag 值，仍然可能为 false，那么括号里的语句将不会执行。 如果改成下面这样： 12345678910111213int a = 0;volatile bool flag = false;public void write() &#123; a = 2; //1 flag = true; //2&#125;public void multiply() &#123; if (flag) &#123; //3 int result = a * a;//4 &#125;&#125; 那么还是线程1先执行 write 方法, 线程2再执行 multiply 方法。根据 happens-before 原则，这个过程会满足以下3类规则： 程序顺序规则：1 happens-before 2（volatile 限制了指令重排序）; 3 happens-before 4; volatile规则：2 happens-before 3 传递性规则：1 happens-before 4 volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？先看一段代码： 123456789101112131415161718192021222324public class Test &#123; private volatile int inc = 0; private void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; test.increase(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 1) &#123; //保证前面的线程都执行完 Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()); System.out.println(test.inc); &#125;&#125; 讲道理来说结果是10000，但是运行下很可能是个小于 10000 的值。有同学可能会说 volatile 不是保证了可见性吗，一个线程对 inc 的修改，另外一个线程应该立刻看到！可是这里的操作 inc++ 是个复合操作啊，包括 3 个步骤读取 inc 的值，对其自增，然后再写回主存。 假设线程A，读取了 inc 的值为10，这时候被阻塞了（可能都不是被阻塞，就是有其他线程执行比线程A更快，因为线程的执行是CPU调度的，在同等优先级的情况下，是抢占式的），因为没有对变量进行修改（前面的例子 flag = true；是读取主存中的值，再把 true 赋值给工作内存中的副本 flag，然后再刷新回主存，这样 flag 这个变量就改变了，而这些都是一个步骤，原子的），触发不了 volatile 规则。 线程B此时也读到 inc 的值，主存里 inc 的值依旧为10，做自增，然后立刻就被写回主存了，结果为11。 此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次 increase()，结果却只加了一次。看图看图： 在这种复合操作的情景下，原子性的功能是维持不了了。但是 volatile 在上面那种设置 flag 值的例子里，由于对 flag 的读/写操作都是单步的，所以还是能保证原子性的。 要想保证原子性，只能借助于synchronized ,Lock 以及并发包下的 atomic 的原子操作类; 123456789101112131415161718192021222324public class Test &#123; private AtomicInteger inc = new AtomicInteger(); private void increase() &#123; inc.getAndIncrement(); &#125; public static void main(String[] args) &#123; final Test test = new Test(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; test.increase(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 1) &#123; //保证前面的线程都执行完 Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()); System.out.println(test.inc); &#125;&#125; volatile底层的实现机制是什么？下面这段话摘自《深入理解Java虚拟机》： “观察加入 volatile 关键字和没有加入volatile关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个lock 前缀指令”。 lock 前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：1、重排序时不能把后面的指令重排序到内存屏障之前的位置2、它会强制将对缓存的修改操作立即写入主存3、写入动作也会引起别的CPU或者别的内核无效化其 Cache，相当于让新写入的值对别的线程可见。 总结JMM就是一组规则，这组规则是为了解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before原则）及其外部可使用的同步手段(synchronized/volatile等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java并发总结","slug":"Java并发总结","date":"2019-10-02T07:52:59.000Z","updated":"2019-10-16T09:40:08.435Z","comments":true,"path":"Java并发总结.html","link":"","permalink":"http://xiaoqinghua.site/Java并发总结.html","excerpt":"","text":"一、线程状态转换 新建 (New)线程创建后但未启动 可运行 (Runnable)包含了操作系统线程状态中的Running和Ready 阻塞 (Blocking)等待获取一个排它锁，如果其他线程释放了锁就会结束此状态 无限期等待 (Waiting)等待其他线程显示地唤醒，否则不会被分配CPU时间片 进入方法 没有设置Timeout的Object.wait()方法 没有设置Timeout的Object.join()方法 LockSupport.park()方法 退出方法 Object.notify()/Object.notifyAll() 被调用的线程执行完毕 限期等待 (Timed Waiting)无需等待其它线程显示地唤醒，在一定时间之后会被系统那个自动唤醒 调用Thread.sleep()方法使线程进入限期等待状态时，常常用使一个线程睡眠进行描述 调用Object.wait()方法使线程进入限期等待或者无限期等待时，常常用挂起一个线程\b进行描述 睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态 阻塞和等待的区别在于，阻塞是被动的，它是在等待\b获取一个排它锁。而等待是主动的，通过调用Thread.sleep()和Object.wait()等方法进入 进入方法 Thread.sleep()方法 设置了Timeout参数的Object.wait() 设置了Timeout参数的Thread.join() LockSupprot.parkNanos()方法 LockSupprot.parkUtil()方法 退出方法 时间结束 时间结束/Object.notify()/Objcet.notifyAll() \b时间结束/被调用的线程执行完毕 死亡 (Terminated)可以是线程结束任务之后自己结束，或者产生了异常而\b结束 二、使用线程有三种使用线程的方法: 实现 Runnable接口 实现 Callable接口 \b继承 Thread类 \b实现Runnable和Callable接口的类只能当做一个可以再线程中运行的任务，不是真正意义上的线程，因此最后还需要通过Thread\b来调用。可以说任务是通过线程驱动从而执行的 实现Runnable接口需要实现run()方法 通过Thread调用start()方法来启动线程 12345public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125; 12345public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; \b\b实现 Callable 接口与 Runnable相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 12345public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125; 1234567public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 继承 Thread 类同样也是需要实现run()方法，因为Thread类也实现了Runnable接口 当调用start()方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的run()方法 12345public class NyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125; 1234public static void main(String[] args) &#123; MyThread mt = new Thread(); mt.start();&#125; 实现接口 VS 继承 Thread实现接口会更好： Java 不支持多重继承，因此继承了 Thread 类就无法继承其他类，但是可以实现多个接口 类可能只要求可执行就行，继承整个 Thread 类开销过大 基础线程机制ExecutorExecutor 管理多个异步任务的执行，而无需程序员显示地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作 主要有三种 Executor: CachedThreadPool: 一个任务创建一个线程 FixedThreadPool: 所有任务只能使用固定大小的线程 SingleThreadExecutor: 相当于大小为1的 FixedThreadPool 1234567public static void main(Stringp[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; executorService.execute(new MyRunnable)); &#125; executorService.shutdown();&#125; Daemon守护线程时程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分 当所有非守护线程\b结束时，程序也就终止，同事会杀死所有守护线程 main() 属于非守护线程 使用 setDaemon() 方法将一个线程设置为守护线程 1234public static void main(String[] agrs) &#123; Thread thread = new Thread(new MyRunnable); thread.setDaemon(true);&#125; sleep()Thread.sleep(millisec)方法会休眠当前正在执行的线程，millisec 单位为\b毫秒 sleep() 可能会抛出 InterruptedException，因为一场不能夸线程传播回 main()中，因此必须在本地进行处理，线程中抛出的其他异常也需要再本地进行处理 1234567public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedExcetion e) &#123; e.printStackTrace(); &#125;&#125; yield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期\b中的最重要部分，可以切换给其他线程来执行。该方法只是\b对线程调度器的一个建议，而且也只是建议具有相同优先级的其他线程可以运行。 123public void run() &#123; Thread.yield();&#125; 四、中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束 InterruptedExcetion通过调用一个线程的 interrupt() 来\b中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedExcetion， 从而提前结束该线程。但是\b不能中断 I/O 阻塞和 synchronized 阻塞锁 对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep()方法，因此会抛出一个 InterruptedExcetion， 从而提前结束线程，不执行之后的语句 123456789101112131415161718192021public class InterruptedExample &#123; private static class MyThread1 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(\"Thread run\"); &#125; catch (InterruptedExcetion e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;```javaMain runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at InterruptExample.lambda$main$0(InterruptExample.java:5) at InterruptExample$$Lambda$1/713338599.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) interrupted()如果一个线程的 run() 方法执行一个无线循环，并且没有执行 sleep() 等会抛出 InterruptedExcetion 的操作，那么调用线程的 interrupt()方法就无法使线程提前结束 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。 因此可以再循环体中使用 interrupted() 方法来判断线程是否\b处于中断状态，从而提前结束线程 123456789101112public class InterruptExample &#123; private static class MyThread2 extends Thread &#123; @Override public void run() &#123; while (!interrupted()) &#123; // ... &#125; System.out.println(\"Thread end\"); &#125; &#125;&#125; 1234567public static void main(String[] agrs) &#123; Thread thread2 = new MyThread2(); thread2.start(); thread2.interrupt();&#125;Thread end Executor 的中断操作调用 Executor 的 shutdown()\b 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法 以下使用 Lambda 创建线程，相当于\b创建了一个匿名内部线程 12345678910111213public static void main(String[] agrs) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; try &#123; Thread.sleep(2000); System.out.println(\"Thread run\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); executorService.shutdownNow(); System.out.println(\"Mian run\");&#125; 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。 1234Future&lt;?&gt; future = executorService.submit(() -&gt; &#123; // ..&#125;);future.cancel(true); 五、互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。 synchronized 同步一个代码块 12345public void func() &#123; synchronized (this) &#123; // ... &#125;&#125; 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。 对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。 12345678910public class SynchronizedExample &#123; public void func1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + \" \"); &#125; &#125; &#125;&#125; 12345678public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e1.func1());&#125;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。 123456789public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e2.func1());&#125;0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 同步一个方法 123public synchronized void func () &#123; // ...&#125; 它和同步代码块一样，作用于同一个对象。 同步一个类 12345public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。 12345678910public class SynchronizedExample &#123; public void func2() &#123; synchronized (SynchronizedExample.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + \" \"); &#125; &#125; &#125;&#125; 12345678public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func2()); executorService.execute(() -&gt; e2.func2());&#125;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 同步一个静态方法 123public synchronized static void fun() &#123; // ...&#125; 作用于整个类。 ReentrantLock 可重入锁ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。 12345678910111213141516public class LockExample &#123; private Lock lock = new ReentrantLock(); public void func() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + \" \"); &#125; &#125; finally &#123; // 释放锁，从而避免死锁 lock.unlock(); &#125; &#125;&#125; 12345678public static void main(String[] agrs) &#123; LockExample lockExample = new LockExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; lockExample.execute()); executorService.execute(() -&gt; lockExample.execute());&#125;0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 比较 锁的实现 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 性能 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 等待可中断 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock 可中断，而 synchronized 不行。 公平锁 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 锁绑定多个条件 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其他部分之前完成\b，那么久需要对\b线程进行协调 join()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。 1234567891011121314151617181920212223242526272829303132333435public class JoinExample &#123; private class A extends Thread &#123; @Override public void run() &#123; System.out.println(\"A\"); &#125; &#125; private class B extends Thread &#123; private A a; B(A a) &#123; this.a = a; &#125; @Override public void run() &#123; try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"B\"); &#125; &#125; public void test() &#123; A a = new A(); B b = new B(a); b.start(); a.start(); &#125;&#125; 1234567public static void main(String[] agrs) &#123; JoinExample example = new JoinExample(); example.test();&#125;AB wait()，notify(),notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。 12345678910111213141516public class WaitNotifyExample &#123; public synchronized void before() &#123; System.out.print(\"before\"); notifyAll(); &#125; public synchronized void after() &#123; try &#123; wait(); &#125; catch (InterruptedException) &#123; e.printStackTrace(); &#125; System.out.print(\"after\"); &#125;&#125; 123456789public static void main(String[] agrs) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); WaitNotifyExample example = new WaitNotifyExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125;beforeafter wait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会。 await() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 使用 Lock 来获取一个 Condition 对象。 123456789101112131415161718192021222324252627public class AwaitSignalExample &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() &#123; lock.lock(); try &#123; System.out.println(\"before\"); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void after() &#123; lock.lock(); try &#123; condition.await(); System.out.println(\"after\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 123456789public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125;beforeafter 七、J.U.C - AQSjava.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。 CountDownLatch用来控制一个线程等待多个线程。 维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。 12345678910111213141516171819202122public class CountDownLatchExample &#123; public static void main(String[] agrs) &#123; final int totalThread = 10; CountDownLatch countDownLatch = new CountDownLatch(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print(\"run..\"); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); System.out.print(\"end..\"); executorService.shutdown(); &#125;&#125;打印 9 次 run \b，最后一次 end相当于让主线程等待\b循环的线程执行完之后，再执行run..run..run..run..run..run..run..run..run..run..end CyclicBarrier用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 awati() 方法而在等待的线程才能继续执行。 CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。 CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。 12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 1234567891011121314151617181920212223public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; final int totalThread = 10; CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print(\"before..\"); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.print(\"after..\"); &#125;); &#125; executorService.shutdown(); &#125;&#125;before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after.. SemaphoreSemaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。 1234567891011121314151617181920212223public class SemaphoreExample &#123; public static void main(String[] args) &#123; final int clientCount = 3; final int totalRequestCount = 10; Semaphore semaphore = new Semaphore(clientCount); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalRequestCount; i++) &#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire(); System.out.print(semaphore.availablePermits() + \" \"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; &#125;); &#125; executorService.shutdown(); &#125;&#125;2 1 2 2 2 2 2 1 2 2 八、J.U.C - 其它组件FutureTask在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。 1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; 1public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。 1234567891011121314151617181920212223242526272829public class FutureTaskExample &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int result = 0; for (int i = 0; i &lt; 100; i++) &#123; Thread.sleep(10); result += i; &#125; return result; &#125; &#125;); Thread computeThread = new Thread(futureTask); computeThread.start(); Thread otherThread = new Thread(() -&gt; &#123; System.out.println(\"other task is running...\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); otherThread.start(); System.out.println(futureTask.get()); &#125;&#125; 12other task is running...4950 BlockingQueuejava.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现： FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度） 优先级队列 ：PriorityBlockingQueue 提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。 使用 BlockingQueue 实现生产者消费者问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ProducerConsumer &#123; private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); private static class Producer extends Thread &#123; @Override public void run() &#123; try &#123; queue.put(\"product\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.print(\"produce..\"); &#125; &#125; private static class Consumer extends Thread &#123; @Override public void run() &#123; try &#123; String product = queue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.print(\"consume..\"); &#125; &#125;&#125;public static void main(String[] args) &#123; for (int i = 0; i &lt; 2; i++) &#123; Producer producer = new Producer(); producer.start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; Consumer consumer = new Consumer(); consumer.start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; Producer producer = new Producer(); producer.start(); &#125;&#125;produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.. ForkJoin主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。 123456789101112131415161718192021222324252627282930public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; &#123; private final int threshold = 5; private int first; private int last; public ForkJoinExample(int first, int last) &#123; this.first = first; this.last = last; &#125; @Override protected Integer compute() &#123; int result = 0; if (last - first &lt;= threshold) &#123; // 任务足够小则直接计算 for (int i = first; i &lt;= last; i++) &#123; result += i; &#125; &#125; else &#123; // 拆分成小任务 int middle = first + (last - first) / 2; ForkJoinExample leftTask = new ForkJoinExample(first, middle); ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last); leftTask.fork(); rightTask.fork(); result = leftTask.join() + rightTask.join(); &#125; return result; &#125;&#125; 123456public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ForkJoinExample example = new ForkJoinExample(1, 10000); ForkJoinPool forkJoinPool = new ForkJoinPool(); Future result = forkJoinPool.submit(example); System.out.println(result.get());&#125; ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。 1public class ForkJoinPool extends AbstractExecutorService ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。 九、线程不安全示例如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。 以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。 123456789101112public class ThreadUnsafeExample &#123; private int cnt = 0; public void add() &#123; cnt++; &#125; public int get() &#123; return cnt; &#125;&#125; 12345678910111213141516public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; ThreadUnsafeExample example = new ThreadUnsafeExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125;998 可以用 synchronized 同步 add()方法 十、Java 内存模型Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。 加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。 线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。 内存间交互操作Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。 read：把一个变量的值从主内存传输到工作内存中 load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中 use：把工作内存中一个变量的值传递给执行引擎 assign：把一个从执行引擎接收到的值赋给工作内存的变量 store：把工作内存的一个变量的值传送到主内存中 write：在 store 之后执行，把 store 得到的值放入主内存的变量中 lock：作用于主内存的变量 unlock 内存模型三大特性 原子性 Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock操作具有原子性 例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。 但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。 有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。 为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。 下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。 AtomicInteger 能保证多个线程修改的原子性。 使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现： 123456789101112public class AtomicExample &#123; private AtomicInteger cnt = new AtomicInteger(); public void add() &#123; cnt.incrementAndGet(); &#125; public int get() &#123; return cnt.get(); &#125;&#125; 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; AtomicExample example = new AtomicExample(); // 只修改这条语句 final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。 可见性 可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 主要有有三种实现可见性的方式： volatile synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。 有序性 有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 先行发生原则上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 单一线程原则 Single Thread rule 在一个线程内，在程序前面的操作先行发生于后面的操作。 管程锁定规则 Monitor Lock Rule 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 volatile 变量规则 Volatile Variable Rule 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则 Thread Start Rule Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 线程加入规则 Thread Join Rule Thread 对象的结束先行发生于 join() 方法返回。 线程中断规则 Thread Interruption Rule 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 对象终结规则 Finalizer Rule 一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性 Transitivity 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 十一、线程安全线程安全定义 一个类在可以被多个线程安全调用时就是线程安全的。 线程安全分类 线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变 不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。 多线程环境下，应当尽量使对象成为不可变，来满足线程安全。 不可变的类型： final 关键字修饰的基本数据类型 String 枚举类型 Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。 绝对线程安全 不管运行时环境如何，调用者都不需要任何额外的同步措施。 相对线程安全 相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。 对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。 线程兼容 线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。 线程对立 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。 线程安全的实现方法 互斥同步(阻塞同步) synchronized 和 ReentrantLock。 非阻塞同步 互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 （一）CAS 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。 （二）AtomicInteger J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。 以下代码使用了 AtomicInteger 执行了自增的操作。 12345private AtomicInteger cnt = new AtomicInteger();public void add() &#123; cnt.incrementAndGet();&#125; 以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; 以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; （三）ABA 如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 无同步方案 要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。 （一）栈封闭 多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 1234567891011121314151617public class StackClosedExample &#123; public void add100() &#123; int cnt = 0; for (int i = 0; i &lt; 100; i++) &#123; cnt++; &#125; System.out.println(cnt); &#125;&#125;public static void main(String[] args) &#123; StackClosedExample example = new StackClosedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; example.add100()); executorService.execute(() -&gt; example.add100()); executorService.shutdown();&#125; （二）线程本地存储（Thread Local Storage） 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。 其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。 1234567891011121314151617181920212223public class ThreadLocalExample &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal.set(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadLocal.get()); threadLocal.remove(); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal.set(2); threadLocal.remove(); &#125;); thread1.start(); thread2.start(); &#125;&#125;1 为了理解 ThreadLocal，先看以下代码： 12345678910111213141516public class ThreadLocalExample1 &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal1 = new ThreadLocal(); ThreadLocal threadLocal2 = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal1.set(1); threadLocal2.set(1); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal1.set(2); threadLocal2.set(2); &#125;); thread1.start(); thread2.start(); &#125;&#125; 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; get() 方法类似。 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。 在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。 （三）可重入代码（Reentrant Code） 这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 十二、锁优化这里的锁优化主要是指 JVM 对 synchronized 的优化。 自旋锁互斥同步进入阻塞状态的开销都很大，应该尽量避免 在许多应用中，共享数据的锁定状态只会持续很短的一段时间 自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。 自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。 在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 锁消除锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。 锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。 对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁： 123public static String concatString(String s1, String s2, String s3) &#123; return s1 + s2 + s3;&#125; String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作： 1234567public static String concatString(String s1, String s2, String s3) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; 每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。 上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。 轻量级锁JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 偏向锁偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。 当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。 当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。 十三、多线程开发良好的实践 给线程起个有意义的名字，这样可以方便找 Bug。 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。 使用 BlockingQueue 实现生产者消费者问题。 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。 Java 线程面试题 Top 50线程\b通信","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"VIM练习手册","slug":"VIM练习手册","date":"2019-07-25T06:42:48.000Z","updated":"2019-10-16T09:41:06.951Z","comments":true,"path":"VIM练习手册.html","link":"","permalink":"http://xiaoqinghua.site/VIM练习手册.html","excerpt":"","text":"==VIM命令==1.一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 1234567Ctrl+f 向下移动一页Ctrl+b 向上移动一页0 移动到这一行的最前面的字符处$ 移动到这一行的最后面的字符处G 移动到文本的最后一行gg 移动到文本的第一行，相当于1Gn&lt;Enter&gt; n为数字。光标向下移动n行 搜索替换 12345/word 向光标之下查询“word”的字符串n 查找到“word”之后,光标定位到下一个“word”N 与n相反,定位到上一个:n1,n2s/word1/word2/g 在n1行与n2行之间查询“word1”,并替换成“word2”:n1,$s/word1/word2/gc 在n1行与文本最后一行之间查询“word1”,并替换成“word2”,并提示用户 删除、复制、粘贴 1234567891011121314x(小写) 相当于[del]键X(大写) 相当于[backspace]键dd 删除光标所在的那一行ndd 删除光标所在的行下n行yy 复制光标所在的那一行nyy 复制光标所在的行下n行p(小写) 将复制的内容粘贴在光标下一行P(大写) 将复制的内容粘贴在光标上一行J(大写) 将当前光标行与下一行，拼成一行u 恢复Crtl+r 重做. 重复上一个命令注意: dd,yy 都可以与“0”,“$”,“G”配合使用 一般模式切换到编辑模式的可用的按钮说明12345678i 在当前光标处开始输入I 在当前行的第一个非空格处开始输入a 在当前光标的下一个字符处开始输入A 在当前行的最后一个字符处开始输入o 在当前行的下一行处输入新的一行O 在当前行的上一行处输入新的一行r 取代模式，只会取代光标所在字符一次R 取代模式，会一直取代光标所在的文字，直到按下ESC键 一般模式切换到命令行模式的可用的按钮说明123:w 保存，退出:q 仅仅是退出vi编辑器，如果没有修改直接退出，如果有修改会提示，可以使用:q!不存储修改部分，强制退出:wq 存储后退出 牛逼的技巧 单词移动 1234567W w 移动到下一个单词开头E e 移动到下一个单词结尾B b 倒退到上一个单词开头- E会忽略标点符号，如：I‘m，e会当成两个单词，E则不会- 2w，表示往下移动2个单词- 一般用小写的就可以了 整行移动 12340 移动到行首$ 移动到行末+ 移动到下一行开头- 移动到上一行开头 滚屏 1234567Ctrl+f 往前滚动一整屏Ctrl+b 往后滚动一整屏Ctrl+d 往前滚动半屏Ctrl+u 往后滚动半屏Ctrl+e 往后滚动一行 Ctrl+y 往前滚动一行 用z调整光标 123z&lt;Enter&gt; 将光标所在行移动到屏幕顶端z. 将光标所在行移动到屏幕中间z- 将光标所在行移动到屏幕低端 在屏幕中移动 123456H 移动到屏幕顶端的行M 移动到屏幕中央的行L 移动到屏幕底端的行nH 移动到屏幕顶端往下的第n行nL 移动到屏幕顶端往上的第n行 单词删除 12345dw 删除到下一个单词开头de 删除到本单词末尾dE 删除到本单词末尾包括标点在内db 删除到前一个单词dB 删除到前一个单词包括标点在内 单词修改 12cw 从光标处修改到单词结尾cb 从光标处修改到单词开头 行修改 123456c$ 从光标修改到本行末尾C 功能同上c0 从光标修改到本行开头cc 删除整行从头修改S 功能同上s 删除光标所在位置的字符，然后插入 单词和字符复制 123456ynl 向右复制n个字符ynh 向左复制n个字符ynw 向前复制n个单词ynb 向后复制n个单词e！ 全文恢复dt&quot; 删除所有的内容，直到遇到双引号—— &quot; 最强光标移动 12% : 匹配括号移动，包括 (, &#123;, [. （陈皓注：你需要把光标先移到括号上）;* 和 #: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/VIM练习手册.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Vim","slug":"Code/Vim","permalink":"http://xiaoqinghua.site/categories/Code/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://xiaoqinghua.site/tags/Vim/"}]},{"title":"Redis笔记","slug":"Redis笔记","date":"2019-07-01T15:04:49.000Z","updated":"2019-10-16T09:40:24.358Z","comments":true,"path":"Redis笔记.html","link":"","permalink":"http://xiaoqinghua.site/Redis笔记.html","excerpt":"","text":"Redis 重点笔记1、为什么使用 redis2、使用 redis 容易造成什么问题3、单线程的 redis 为什么这么快4、redis 的数据类型，以及每种数据类型的使用场景5、redis 的过期策略以及内存淘汰机制6、redis 和数据库双写一致性问题7、如何应对缓存穿透和缓存雪崩问题8、如何解决 redis 的并发竞争问题 笔记解析1、为什么使用 redis分析：在项目中使用 redis 主要考虑两点性能和并发。除此之外，redis 还具备做分布式锁等其他功能（// TODO 什么其他功能），但是如果只是为了分布式锁这些其他功能，完全还有其他中间件（如 zookeeper 等）代替，并不是非要用 redis。 性能 和 并发 性能： \b如下图所示，我们在碰到需要执行耗时特别久，且执行结果不频繁变动的 SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应，因此提高了性能。 并发： 如下图所示，在高并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 redis 做一个缓冲操作，让请求先访问到 redis，而不是直接访问数据库。 2、使用 redis 容易造成什么问题分析：诚然 redis 解决了很多问题，提高了系统性能，优化了系统处理并发的能力，但是使用 redis 也会遇到解决上述问题进而所产生的衍生问题。 主要是四个问题 缓存和数据库双写一致性问题 缓存雪崩（大面积的数据崩溃） 缓存击穿 缓存并发竞争问题 下文中给出解决方案。 3、单线程的 redis 为什么这么快分析：这个问题其实是对 redis 内部机制的一个考察。redis 是单线程的！！！！ 为什么快，主要是以下三点 纯内存操作 单线程操作，避免频繁切换上下文 采用非阻塞 I/O 多路复用机制（想到了 netty ） I/O 多路复用：单个线程，通过跟踪每个I/O流的状态，来管理多个I/O流。下图是类比到真实的 redis 线程模型：我们使用redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/O 多路复用的程序，将其置入队列之中（//TODO 可理解为一个线程模型，单线程处理），然后发送到文件事件分派器，依次去队列中取，转发到不同的事件处理器中。redis的这个I/O 多路复用机制，还体现在redis提供了select，epoll，evport，kqueue`等多路复用函数库。 4、redis的数据类型，以及每种数据类型的使用场景分析：这是一个基础问题，配合熟记食用更佳。 有五种数据类型 String 常规set/get操作，value可以是String也可以是数字。一般做一些复杂计算功能的缓存。 hash hash数据类型的value存放的是结构化的对象，比较方便的就是操作其中的某个字段。在做单点登录的时候，就可以用这种结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 list list数据结构，可以做简单的消息队列的功能。另外一个是，可以利用lrange命令，做基于redis的分页功能（lrange mylist 0 10），性能极佳，用户体验很好。 set set数据结构存放的是一堆不重复的集合。所以可以做全局去重的功能。可以使用交集、并集、差集等操作，可以计算共同喜好，全部喜好，自己独有喜好等功能。 sorted set sorted set多了一个权重参数score，集合中的元素能够按照score进行排列。可以做排行榜应用，取TOP N操作，延时任务，范围查找。 5、 redis的过期策略以及内存淘汰机制分析：假如redis只能存 5G 数据量，写入了 10G 的数据，就会删除 5G 数据，怎么删除，按照什么策略删除。 redis 采用 定期删除+惰性删除策略 为什么不用定时删除策略 定时删除，用一个定时器来负责监视 key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在高并发场景下，CPU 应该将时间应用在处理请求上，而不是删除 key，因此不采用这一种策略。 定期删除+惰性删除是如何工作的？ 定期删除，redis 默认每隔100ms检查是否有过期的key，有过期的key直接删除。需要说明的是，redis不是每隔100ms将所有的key检查一次，而是随机抽取进行检查（如果每隔100ms将所有的key检查一次，redis应该已经爆炸💥了），因此如果只采取定期删除策略，会导致很多过期的key没有被删除。于是，惰性删除派上用场了。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间，那么是否过期了？如果过期此时就会被删除。（感觉就是一波亡羊补牢的操作，不过能这样还是挺 NB 的） 采用定期删除+惰性删除就没其他问题了？？？ 不是的！，如果定期删除没有删除key。然后你也没有去get这个key，也就是说惰性删除没有生效。这样，redis的内存占用会越来越大。此时就应该采用内存淘汰机制。 在reids.conf中有一行配置： 1# maxmemory-policy volatile-lru 这个配置就是内存淘汰策略，一下是几种淘汰策略，解析一下： noeviction：当内存不足以容纳新写入的数据时，新写入操作会报错。这个应该没人用吧😂 allkeys-lru：当内存不足以容纳新写入的数据时，在键空间中，移除最近最少使用的key（least recently used）。推荐使用这一种策略。 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候采用。不推荐 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐 //TODO why volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐。 如果没有设置expire的key，不满足先决条件prerequisites；那么volatile-lru，volatile-random和volatile-ttl策略的行为和noeviction（不删除）基本一致。 6、redis 和数据库双写一致性问题分析：一致性问题是分布式常见的问题，还可以分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致问题。注意：有一个前提，如果对数据有强一致性要求，数据就不能存放在缓存。我们所做的一切只能保证最终一致性。另外，我们所做的方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。 1首先，采取正确的更新策略，先更新数据库，再删除缓存。其次，因为可能存在缓存删除失败的问题，提供一个补偿措施即可，例如利用消息队列。 7、如何应对缓存穿透和缓存雪崩问题分析：这个问题，一版高并发的项目可能会遇到，流量几百万左右。 缓存穿透 有人故意去请求缓存中不存在的数据，导致所有的请求怼到数据库上，从而数据库连接异常。 解决方案： 1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁之后，再去请求数据库。没得到锁，则休眠一端时间重试。 2、采用异步更新策略，无论是key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，就异步起一个线程去读数据库，更新缓存。这个方案，需要做缓存预热（羡慕启动前，先预加载缓存）操作。 3、提供一个能迅速判断请求是否有效的拦截机制。比如，利用布隆过滤器（bloom filter），内部维护一系列合法有效的key。迅速判断出，请求所携带的key是否合法有效。如果不合法，则直接返回。 缓存雪崩 缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都到了数据库上，从而导致数据库连接异常。 解决方案： 1、给缓存的失效时间，加上一个随机值，避免集体失效。 2、使用互斥锁，但是吞吐量明显下降了。 3、使用双缓存，两个缓存，A，B。缓存 A 的失效时间是20分钟，缓存 B 不设失效时间。自己做缓存预热操作。然后细分一下几个小点： 从缓存 A 读数据库，有则直接返回。 A 没有读到数据，直接从 B 读数据，有则直接返回，并异步启动一个更新线程。 更新线程同时更新缓存 A 和缓存 B。 8、如何解决 Redis 的并发竞争问题分析：这个问题大致就是，同时又多个子系统去set一个key。一般很多回答是使用redis的事务机制。但是因为我们的生产环境，一般都是redis集群环境，做了数据分片操作。你一个事务中所有涉及到多个key操作的时候，这个key不一定都存储在同一个redis-server上。因此，redis 的事务机制，有点鸡肋。（// TODO） 如下所示： 1、如果这个key操作，不要求顺序，可以准备一个分布式锁，大家去抢锁，抢到了锁就做set操作即可。 2、如果这个key操作，要求顺序，假设有一个key1，系统 A 需要将key1设置为valueA，系统 B 需要将 key1设置为valueB，系统 C 需要将key1设置为valueC。 我们期望按照key1的value值按照valueA–&gt;valueB–&gt;valueC的顺序变化。这时候我们在写入数据库的时候，就需要保存一个时间戳。假设时间戳如下： 123系统A key1 &#123;valueA 3:00&#125;系统B key1 &#123;valueB 3:05&#125;系统C key1 &#123;valueC 3:10&#125; 那么根据上述，假设是系统 B 先抢到锁，将key1设置为{valueB 3:05}。那么接下来，如果 A 抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那么久不做set操作了。 其他方法，如利用队列，将set方法变成串行访问也可以。 本文出处孤独烟，个人只是一字一字的解读，理解前辈总结的经验。我认为只是大致浏览一篇博文，看一篇公众号整理的干货文章，是没有用的，还是要多理解，多实践，加深记忆，才能深刻，涓涓细流，沁人心脾，强劲壮骨。这种方式只是我个人的学习方式，可能比较笨重，比较慢，但好记性不如烂笔头。这也是为什么写博客的原因。有幸","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Redis","slug":"Code/Redis","permalink":"http://xiaoqinghua.site/categories/Code/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://xiaoqinghua.site/tags/Redis/"}]},{"title":"Java虚拟机总结","slug":"Java虚拟机总结","date":"2018-11-19T02:50:07.000Z","updated":"2019-10-16T10:24:18.966Z","comments":true,"path":"Java虚拟机总结.html","link":"","permalink":"http://xiaoqinghua.site/Java虚拟机总结.html","excerpt":"","text":"一、运行时数据区域 程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 Java 虚拟机栈每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小： 1java -Xss512M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 本地方法栈本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 堆 (Heap)所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法，可以将堆分成两块： 新生代（Young Generation）分为 Eden survivor1 survicor2 8:1:1 老年代（Old Generation） 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 1java -Xms1M -Xmx2M HackTheJava 方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。 HotSpot 虚拟机(sun 公司实现的基于栈的虚拟机，google 也实现了一款基于程序计数器的，但是为了平台通用性和传输紧凑性，基于栈的设计优于基于计数器的实现，但是性能和空间又需要再一次权衡)把它当成永久代来进行垃圾回收。但是很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常 为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 运行时常量池运行时常量池是方法区的一部分 Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。 直接内存在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存（Native 堆），然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 二、垃圾收集垃圾收集主要是针对堆和方法区进行。 程序计数器、Java栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。 判断一个对象是否可被回收 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 1234567891011public class ReferenceCountingGC &#123; public Object instance = null; public static void main(String[] args) &#123; ReferenceCountingGC objectA = new ReferenceCountingGC(); ReferenceCountingGC objectB = new ReferenceCountingGC(); objectA.instance = objectB; objectB.instance = objectA; &#125;&#125; 可达性分析算法 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容： Java栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 方法区的回收 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 finalize() finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次， 引用类型无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型。 强引用 被强引用关联的对象不会被回收。 使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 软引用 被软引用关联的对象只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 弱引用 被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。 使用 WeakReference 类来实现弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; // 使对象只被弱引用关联 虚引用 又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。 使用 PhantomReference 来实现虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj = null; // 使对象只被虚引用关联 垃圾收集算法 标记 - 清除 将存活的对象进行标记，然后清理掉未被标记的对象。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 标记 - 整理 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 分代收集 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 Serial 收集器 Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 模式下的默认新生代收集器，因为在该应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。 Parallel Scavenge 收集器 与 ParNew 一样是多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。 这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。 如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC G1 收集器 G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多CPU 和大内存的场景下有很好的性能。HotSpot开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个Region垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 三、内存分配与回收策略Minor GC 和 Full GC Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 内存分配策略 对象优先在 Eden 分配 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 大对象直接进入老年代 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 长期存活的对象进入老年代 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 动态对象年龄判定 虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。 Full GC 的触发条件对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 调用 System.gc() 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 老年代空间不足 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 空间分配担保失败 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。 JDK 1.7 及以前的永久代空间不足 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 Concurrent Mode Failure 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 四、类加载机制类是在运行期间第一次使用时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。 类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。 加载 加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 验证 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中。 注意，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。 1public static final int value = 123; 解析 将常量池的符号引用替换为直接引用的过程。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 初始化 初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 &lt;clinit&gt;() 方法具有以下特点： 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 与类的构造函数（或者说实例构造器 &lt;init&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 &lt;clinit&gt;() 方法运行之前，父类的 () 方法已经执行结束。因此虚拟机中第一个执行 () 方法的类肯定为 java.lang.Object。 由于父类的 () 方法先执行，也就意 1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); // 2&#125; () 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 () 方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 () 方法。但接口与类不同的是，执行接口的 () 方法不需要先执行父接口的 () 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法。 虚拟机会保证一个类的 () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 类初始化时机 主动引用 虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 被动引用 以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 类与类加载器两个类相等需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。 类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），这个类加载器用C++实现，是虚拟机自身的一部分； 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。 下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 工作过程 一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时自己才尝试加载。 好处 使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 的类并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。 实现 以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ClassLoader &#123; // The parent class loader for delegation private final ClassLoader parent; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false); &#125; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125;&#125; 自定义类加载器实现FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。 深入理解Java虚拟机","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java集合框架源码分析","slug":"Java集合框架源码分析","date":"2018-10-04T13:04:20.000Z","updated":"2019-10-16T09:41:24.246Z","comments":true,"path":"Java集合框架源码分析.html","link":"","permalink":"http://xiaoqinghua.site/Java集合框架源码分析.html","excerpt":"","text":"如果没有特别说明，以下源码分析基于 JDK 1.8 ArrayList1. 概览实现了 RandomAccess 接口，因此支持随机访问。这是理所当然的，因为 ArrayList 是基于数组实现的。 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 数组的默认大小为 10。 1private static final int DEFAULT_CAPACITY = 10; 2. 扩容添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1)，也就是旧容量的 1.5 倍。 扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。 12345678910111213141516171819202122232425262728293031public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 3. 删除元素需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。 12345678910public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 4. Fail-FastmodCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。 在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 5. 序列化ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。 保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。 1transient Object[] elementData; // non-private to simplify nested class access ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。 123456789101112131415161718192021private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。 123ArrayList list = new ArrayList();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));oos.writeObject(list); Vector1. 同步它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。 123456public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; 123456public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; 2. 与 ArrayList 的比较Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 3. 替代方案可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); CopyOnWriteArrayList读写分离写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组。 1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 1234567final void setArray(Object[] a) &#123; array = a;&#125;@SuppressWarnings(\"unchecked\")private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 适用场景CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。 但是 CopyOnWriteArrayList 有其缺陷： 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。 LinkedList1. 概览基于双向链表实现，使用 Node 存储链表节点信息。 12345private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; 每个链表存储了 first 和 last 指针： 12transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; 2. 与 ArrayList 的比较 ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 HashMap为了便于理解，以下源码分析以 JDK 1.7 为主。 1. 存储结构内部包含了一个 Entry 类型的数组 table。 1transient Entry[] table; Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值相同的 Entry。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125;&#125; 2. 拉链法的工作原理1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"K1\", \"V1\");map.put(\"K2\", \"V2\");map.put(\"K3\", \"V3\"); 新建一个 HashMap，默认大小为 16； 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。 应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。 查找需要分成两步进行： 计算键值对所在的桶； 在链表上顺序查找，时间复杂度显然和链表的长度成正比。 3. put 操作1234567891011121314151617181920212223242526public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 插入新键值对 addEntry(hash, key, value, i); return null;&#125; HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 12345678910111213private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。 12345678910111213141516void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; // 头插法，链表头部指向新的键值对 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 123456Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h;&#125; 4. 确定桶下标很多操作都需要先确定一个键值对所在的桶下标。 12int hash = hash(key);int i = indexFor(hash, table.length); 1.计算 hash 值 1234567891011121314151617final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125; 2.取模 令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质： 12x : 00010000x-1 : 00001111 令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数： 123y : 10110010x-1 : 00001111y&amp;(x-1) : 00000010 这个性质和 y 对 x 取模效果是一样的： 123y : 10110010x : 00010000y%x : 00000010 我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。 确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。 123static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 5. 扩容-基本原理设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为O(N/M)。 为了让查找的成本降低，应该尽可能使得N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的N 值来调整 M 值，使得空间效率和时间效率都能得到保证。 和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。 capacity：table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。 size：table 的实际使用量。 threshold：size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。 loadFactor：装载因子，table 能够使用的比例，threshold = capacity * loadFactor。 123456789101112131415static final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount; 从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。 123456void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); if (size++ &gt;= threshold) resize(2 * table.length);&#125; 123456789101112131415161718192021222324252627282930void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor);&#125;void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125;&#125; 6. 扩容-重新计算桶下标在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。 假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32： 12capacity : 00010000new capacity : 00100000 对于一个 Key， 它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样； 如果为 1，那么得到的结果为原来的结果+16。 7. 扩容-计算数组容量HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。 先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到： 123mask |= mask &gt;&gt; 1 11011000mask |= mask &gt;&gt; 2 11111100mask |= mask &gt;&gt; 4 11111111 mask+1 是大于原始数字的最小的 2 的 n 次方。 12num 10010000mask+1 100000000 以下是 HashMap 中计算数组容量的代码： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 8. 链表转红黑树从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。 9. 与 HashTable 的比较 HashTable 使用 synchronized 来进行同步。 HashMap 可以插入键为 null 的 Entry。 HashMap 的迭代器是 fail-fast 迭代器。 HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 ConcurrentHashMap 存储结构 123456static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next;&#125; ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。 Segment 继承自 ReentrantLock。 1234567891011121314151617static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1; transient volatile HashEntry&lt;K,V&gt;[] table; transient int count; transient int modCount; transient int threshold; final float loadFactor;&#125; 1final Segment&lt;K,V&gt;[] segments; 默认的并发级别为 16，也就是说默认创建 16 个 Segment。 1static final int DEFAULT_CONCURRENCY_LEVEL = 16; 2. size 操作每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。 12345/** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */transient int count; 在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。 ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。 尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。 如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。 1234567/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2; 1234567891011121314151617181920212223242526272829303132333435363738394041public int size() &#123; // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn't retry try &#123; for (;;) &#123; // 超过尝试次数，则对每个 Segment 加锁 if (retries++ == RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; // 连续两次得到的结果一致，则认为这个结果是正确的 if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; 3. JDK 1.8 的改动JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。 JDK 1.8 使用了 CAS操作来支持更高的并发度，在CAS 操作失败时使用内置锁 synchronized。 并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。 LinkedHashMap存储结构继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 123456789/** * The head (eldest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * The tail (youngest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; tail; accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。 1final boolean accessOrder; LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。 12void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125; afterNodeAccess()当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; afterNodeInsertion()在 put 等操作之后执行，当 removeEldestEntry() 方法返回 ture 时会移除最晚的节点，也就是链表首部节点 first。 evict 只有在构建 Map 的时候才为 false，在这里为 true。 1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; LRU 缓存以下是使用 LinkedHashMap 实现的一个 LRU 缓存： 设定最大缓存空间 MAX_ENTRIES 为 3； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。 12345678910111213141516171819202122class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125; LRUCache() &#123; super(MAX_ENTRIES, 0.75f, true); &#125;&#125;public static void main(String[] args) &#123; LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, \"a\"); cache.put(2, \"b\"); cache.put(3, \"c\"); cache.get(1); cache.put(4, \"d\"); System.out.println(cache.keySet());&#125;[3, 1, 4] WeekHashMap存储结构 WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。 WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。 1private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt; ConcurrentCacheTomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。 ConcurrentCache 采取的是分代缓存： 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）； 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。 1234567891011121314151617181920212223242526272829303132public final class ConcurrentCache&lt;K, V&gt; &#123; private final int size; private final Map&lt;K, V&gt; eden; private final Map&lt;K, V&gt; longterm; public ConcurrentCache(int size) &#123; this.size = size; this.eden = new ConcurrentHashMap&lt;&gt;(size); this.longterm = new WeakHashMap&lt;&gt;(size); &#125; public V get(K k) &#123; V v = this.eden.get(k); if (v == null) &#123; v = this.longterm.get(k); if (v != null) this.eden.put(k, v); &#125; return v; &#125; public void put(K k, V v) &#123; if (this.eden.size() &gt;= size) &#123; this.longterm.putAll(this.eden); this.eden.clear(); &#125; this.eden.put(k, v); &#125;&#125; 参考文档： Java8 HashMap 实现探索 ConcurrentHashMap 高并发性的实现机制HashMap面试题","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java集合框架","slug":"Code/Java集合框架","permalink":"http://xiaoqinghua.site/categories/Code/Java集合框架/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://xiaoqinghua.site/tags/Java集合框架/"}]},{"title":"Java8的时间API","slug":"Java8的时间API","date":"2018-09-09T07:17:44.000Z","updated":"2018-09-12T08:30:30.773Z","comments":true,"path":"Java8的时间API.html","link":"","permalink":"http://xiaoqinghua.site/Java8的时间API.html","excerpt":"","text":"Java 8 中的时间处理API在Java 8以前，日期和时间处理一直被广大Java程序员抱怨太难用，首先是java.util和java.sql中，都包含Date类，如果要处理java.text.DateFormat类处理。同时java.util.Date中既包含了日期，又包含了时间，所以Java8新的日期和时间库，很好的解决了以前日期和时间类的很多弊端。并且也借鉴了第三方日期库joda很多的优点。 在Java8中，java.time包下主要包含下面几个主要的类： 123456789Instant：时间戳 Duration：持续时间，时间差 LocalDate：只包含日期，比如：2018-09-09 LocalTime：只包含时间，比如：15:45:23 LocalDateTime：包含日期和时间，比如：2018-09-09 15:45:23Period：时间段 ZoneOffset：时区偏移量，比如：+8:00 ZonedDateTime：带时区的时间 Clock：时钟，比如获取目前美国纽约的时间 以及java.time.format包中的 1DateTimeFormatter：时间格式化 1、获取今天的日期1234LocalDate todayDate = LocalDate.now(); System.out.println(\"今天的日期：\"+todayDate); //结果今天的日期：2018-09-09 2、指定日期，进行相应操作12345678910111213141516171819202122232425262728LocalDate todayDate = LocalDate.now(); //取2018年9月的第1天LocalDate firstDay = todayDate.with(TemporalAdjusters.firstDayOfMonth()); System.out.println(firstDay);//取2018年9月的第1天，另外一种写法LocalDate firstDay2 = todayDate.withDayOfMonth(1); System.out.println(firstDay2);//取2018年9月的最后1天，不用考虑大月，小月，平年，闰年LocalDate lastDay = todayDate.with(TemporalAdjusters.lastDayOfMonth()); System.out.println(lastDay);//当前日期＋1天LocalDate tomorrow = todayDate.plusDays(1); System.out.println(tomorrow);//判断是否为闰年boolean isLeapYear = tomorrow.isLeapYear(); System.out.println(isLeapYear);//运行结果2018-09-01 2018-09-012018-09-302018-09-10true 3、生日检查或者账单日检查开发过程中，经常需要为过生日的用户送上一些祝福，例如，用户的生日为1992-08-29，如果今天是2018-08-29，那么今天就是用户的生日（按公历／身份证日期来算），那么通过Java8新的日期库，我们该如何来进行判断？在Java8中，可以使用MonthDay，该类不包含年份信息，当然还有一个类是YearMonth 123456LocalDate birthday = LocalDate.of(1992, 08, 29); MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth()); MonthDay today = MonthDay.from(LocalDate.of(2018, 08, 29)); System.out.println(today.equals(birthdayMd)); //结果true 4、获取当前的时间使用LocalTime，该类不包含日期，只有时间信息 1234567891011121314//获取当前的时间LocalTime nowTime = LocalTime.now(); //结果15:38:18.624//如果不想显示毫秒LocalTime nowTime2 = LocalTime.now().withNano(0); //15:38:40//指定时间LocalTime time = LocalTime.of(14, 10, 21); //14:10:21 LocalTime time2 = LocalTime.parse(\"12:00:01\"); // 12:00:01//当前时间增加2小时LocalTime nowTimePlus2Hour = nowTime.plusHours(2); //17:38:18.625 //或者LocalTime nowTimePlus2Hour2 = nowTime.plus(2, ChronoUnit.HOURS); 5、日期前后比较比较2个日期哪个在前，哪个在后，Java8的LocalDate提供了2个方法，isAfter(),isBefore() 123LocalDate today = LocalDate.now(); LocalDate specifyDate = LocalDate.of(2008, 9, 20); System.out.println(today.isAfter(specifyDate)); //true 6、处理不同时区的时间Java8中，将日期，时间，时区都很好的进行了分离。 123456789101112131415161718192021222324//查看当前的时区ZoneId defaultZone = ZoneId.systemDefault(); System.out.println(defaultZone); //Asia/Shanghai//查看美国纽约当前的时间ZoneId america = ZoneId.of(\"America/New_York\"); LocalDateTime shanghaiTime = LocalDateTime.now(); LocalDateTime americaDateTime = LocalDateTime.now(america); System.out.println(shanghaiTime); //2016-11-06T15:20:27.996 System.out.println(americaDateTime); //2016-11-06T02:20:27.996 ，可以看到美国与北京时间差了13小时//查看美国纽约当前的时间ZoneId america = ZoneId.of(\"America/New_York\");LocalDateTime americaTime = LocalDateTime.now(america);LocalDateTime localDateTime = LocalDateTime.now();System.out.println(americaTime);System.out.println(localDateTime);// Asia/Shanghai// 2018-09-12T03:48:49.975// 2018-09-12T15:48:49.986 这里是12小时时差//带有时区的时间ZonedDateTime americaZoneDateTime = ZonedDateTime.now(america); System.out.println(americaZoneDateTime); // 2018-09-12T03:52:32.095-04:00[America/New_York] 可以看到上述例子中，纽约和上海的时差是不一样的，google一下: http://www.timeofdate.com/time/diff/China/Shanghai/with/United%20States/New%20York%20City 可以发现在\b一年中不同的时间段，时差是不一样的。 7、比较两个日期之前时间差在项目中，经常需要比较两个日期之间相差几天，或者相隔几个月，我们可以使用Java8的Period来进行处理。 1234567891011121314151617181920LocalDate now = LocalDate.now();LocalDate pastDate = LocalDate.of(2017, 8, 10);Period between = Period.between(pastDate,now);System.out.println(between.getDays());System.out.println(between.getMonths());System.out.println(between.getYears());System.out.println(pastDate.until(now, ChronoUnit.DAYS));System.out.println(pastDate.until(now, ChronoUnit.YEARS));System.out.println(pastDate.until(now, ChronoUnit.MONTHS));System.out.println(now.until(pastDate, ChronoUnit.DAYS));System.out.println(now.until(now, ChronoUnit.DAYS));//输出结果211398113-3980 我们可以看到，我们使用Period类比较天数，比较奇怪，他返回的值，并不是2个日期之间总共的天数差，而是一个相对天数差，比如，5月1日，和10月2日，他比较的是仅仅2个天之间的差，那1号和2号，相差1天，而实际上，因为中间相差了好几个月，所以真正的天数差肯定不是1天，所以我们可以使用until，并指明精度单位是days，就可以计算真正的天数差了。 8、日期时间格式解析、格式化在Java8之前，我们进行时间格式化主要是使用SimpleDateFormat，而在Java8中，主要是使用DateTimeFormatter,Java8中，预定义了一些标准的时间格式，我们可以直接将时间转换为标准的时间格式： 12345String myTime = \"19920829\";DateTimeFormatter basicIsoDate = DateTimeFormatter.BASIC_ISO_DATE;System.out.println(LocalDate.parse(myTime, basicIsoDate));//输出1992-08-29 当然，很多时间标准的时间格式可能也不满足我们的要求，我们需要转为自定义的时间格式 1234DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(\"YYYY MM dd\"); System.out.println(formatter2.format(LocalDate.now())); //结果2018 09 12 9、java8 时间类与Date类的相互转化在转换中，我们需要注意，因为Java8之前Date是包含日期和时间的，而Java8中LocalDate只包含日期，LocalTime只包含时间，所以与Date在互转中，势必会丢失日期或者时间，或者会使用起始时间。如果转LocalDateTime，那么就不存在信息误差。 12345678910111213141516171819//Date与Instant的相互转化Instant instant = Instant.now(); Date date = Date.from(instant); Instant instant2 = date.toInstant();//Date转为LocalDateTimeDate date2 = new Date(); LocalDateTime localDateTime2 = LocalDateTime.ofInstant(date2.toInstant(), ZoneId.systemDefault());//LocalDateTime转DateLocalDateTime localDateTime3 = LocalDateTime.now(); Instant instant3 = localDateTime3.atZone(ZoneId.systemDefault()).toInstant(); Date date3 = Date.from(instant);//LocalDate转Date//因为LocalDate不包含时间，所以转Date时，会默认转为当天的起始时间，00:00:00LocalDate localDate4 = LocalDate.now(); Instant instant4 = localDate4.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant(); Date date4 = Date.from(instant); 一个Java8的时间工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class TimeUtil &#123; public static final DateTimeFormatter YYYY_MM_DD_HH_MM_SS = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); public static final DateTimeFormatter YYYY_MM_DD = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); public static final DateTimeFormatter HH_MM_SS = DateTimeFormatter.ofPattern(\"HH:mm:ss\"); /** * @return 返回格式yyyy-MM-dd */ public static String date() &#123; return LocalDate.now().format(YYYY_MM_DD); &#125; /** * @return 返回当前年份 */ public static int year() &#123; return LocalDate.now().getYear(); &#125; /** * @return 返回当前月份 */ public static int month() &#123; return LocalDate.now().getMonthValue(); &#125; /** * @return 返回今日是月份中的第几天 */ public static int dayOfMonth() &#123; return LocalDate.now().getDayOfMonth(); &#125; /** * @return 返回今日是一年中的第几天 */ public static int dayOfYear() &#123; return LocalDate.now().getDayOfYear(); &#125; /** * @return 返回今日星期几 1-7 */ public static int dayOfWeek() &#123; return LocalDate.now().getDayOfWeek().getValue(); &#125; /** * @param year * @param month * @param day * @return 返回指定日期 */ public static String newDate(int year, int month, int day) &#123; return LocalDate.of(year, month, day).toString(); &#125; /** * @param year * 指定年份 * @param day * 指定年份中的天数 * @return 根据条件返回日期 */ public static String newDate(int year, int dayNum) &#123; return LocalDate.ofYearDay(year, dayNum).toString(); &#125; /** * @return 返回当前时间 HH:mm:ss.xxx */ public static String time() &#123; return LocalTime.now().format(HH_MM_SS); &#125; /** * @return 当前小时 */ public static int hour() &#123; return LocalTime.now().getHour(); &#125; /** * @return 当前分钟 */ public static int minute() &#123; return LocalTime.now().getMinute(); &#125; /** * @return 当前秒 */ public static int second() &#123; return LocalTime.now().getSecond(); &#125; /** * @return 返回格式 yyyy-MM-dd HH:mm:ss */ public static String dateTime() &#123; return LocalDateTime.now().format(YYYY_MM_DD_HH_MM_SS); &#125; /** * @param time * 从1970-01-01T00:00:00到现在的毫秒数 */ public static LocalDateTime parseDateTime(long time) &#123; return LocalDateTime.ofInstant(Instant.ofEpochMilli(time), ZoneId.systemDefault()); &#125; /** * @param time * yyyy-MM-dd HH:mm:ss */ public static LocalDateTime parseDateTime(String time) &#123; return LocalDateTime.parse(time, YYYY_MM_DD_HH_MM_SS); &#125; /** * @param time * 从1970-01-01T00:00:00到现在的毫秒数 * @return */ public static LocalDate parseDate(long time) &#123; return LocalDate.from(parseDateTime(time)); &#125; /** * @param time * yyyy-MM-dd * @return */ public static LocalDate parseDate(String time) &#123; return LocalDate.parse(time, YYYY_MM_DD); &#125; /** * yyyy-MM-dd * * @param date * @return */ public static String format(LocalDate date) &#123; return date.format(YYYY_MM_DD); &#125; /** * @param dateTime * @return */ public static String format(LocalDateTime dateTime) &#123; return dateTime.format(YYYY_MM_DD_HH_MM_SS); &#125; /** * 转化为毫秒，默认为 * @param date * @return */ public static long millis(LocalDate date) &#123; return millis(date.atStartOfDay()); &#125; /** * 转化为毫秒 * @param dateTime * @return */ public static long millis(LocalDateTime dateTime) &#123; return dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli(); &#125;&#125; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/iterm2小技巧.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"JAVA 8","slug":"Code/JAVA-8","permalink":"http://xiaoqinghua.site/categories/Code/JAVA-8/"}],"tags":[{"name":"JAVA 8","slug":"JAVA-8","permalink":"http://xiaoqinghua.site/tags/JAVA-8/"}]},{"title":"易燃易爆炸(程序员版)","slug":"易燃易爆炸(程序员版)","date":"2018-08-24T16:12:09.000Z","updated":"2018-09-08T07:00:17.567Z","comments":true,"path":"易燃易爆炸(程序员版).html","link":"","permalink":"http://xiaoqinghua.site/易燃易爆炸(程序员版).html","excerpt":"","text":"张悬是大海，雷光夏是星空。陈绮贞是太阳，曹方是风。陈粒是火和光。 一直很喜欢陈粒这首歌，不仅原版歌词写得意味深长，节奏旋律更是深入人心； 改编一首程序员版的，撸代码的时候，听这首真的很来劲！ 由于版权保护，不能外链原版的易燃易爆炸-陈粒，放一首个人觉得风格还不错的plus版本吧； 想听原版的：原版-易燃易爆炸(陈粒) 以下是程序员版的： 123456789101112131415161718192021222324252627282930313233343536373839易燃易爆炸(程序员版)作曲: 陈粒作词: 小清华盼我重构还盼我优雅不消瘦想我健壮还想我安全不跌宕要我一致还要我服务分布式戏我设计模式还戏我异常日志赐我梦境还赐我很快就清醒与我沉睡还与我调度抢栈堆爱我解锁还爱我成功不报错看我后进先出还看我孑孓孤独愿我平滑还愿我效率高又炸看我集成还看我并发不再等要我异步还要我单调又冷酷祝我从此幸福还祝我bug全无为我解锁还为我谢绝反射图我封装还图我泛型抽象与我注解还与代理却拦截夸我负载均衡还夸我一视同仁 赐我梦境还赐我很快就清醒与我哈希还与我撒盐又加密爱我自增还爱我递归又不深看我增删改查还看我海角天涯为我轮询还为我解耦集群图我缓存还图我出库俭省与我重载还与我互斥多态夸我面向对象还夸我装模作样 请我编码还请我bug全缉拿似我循环还似我真假难判断由我桥接还由我遍历不停歇怨我全局撤销还怨我固执回调 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/易燃易爆炸(程序员版).html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！ 123456789101112131415161718192021222324252627282930313233343536373839原版歌词作曲: 陈粒作词: 尚梦迪/骈然盼我疯魔还盼我孑孓不独活想我冷艳还想我轻佻又下贱要我阳光还要我风情不摇晃戏我哭笑无主还戏我心如枯木赐我梦境还赐我很快就清醒与我沉睡还与我蹉跎无慈悲爱我纯粹还爱我赤裸不靡颓看我自弹自唱还看我痛心断肠愿我如烟还愿我曼丽又懒倦看我痴狂还看我风趣又端庄要我美艳还要我杀人不眨眼祝我从此幸福还祝我枯萎不渡为我撩人还为我双眸失神图我情真还图我眼波销魂与我私奔还与我做不贰臣夸我含苞待放还夸我欲盖弥彰 赐我梦境还赐我很快就清醒与我沉睡还与我蹉跎无慈悲爱我纯粹还爱我赤裸不靡颓看我自弹自唱还看我痛心断肠为我撩人还为我双眸失神图我情真还图我眼波销魂与我私奔还与我做不贰臣夸我含苞待放还夸我欲盖弥彰 请我迷人还请我艳情透渗似我盛放还似我缺氧乖张由我美丽还由我贪恋着迷怨我百岁无忧还怨我徒有泪流","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"Computer Principles","slug":"计算机世界的潜规则","date":"2018-08-24T15:21:38.000Z","updated":"2018-08-25T07:18:41.723Z","comments":true,"path":"计算机世界的潜规则.html","link":"","permalink":"http://xiaoqinghua.site/计算机世界的潜规则.html","excerpt":"","text":"序又到了夜深人静的时候，思维渐渐顿了下来，想想自己每天都在写代码，debug，面对着这冰冷的程序，一行一行的输出，却不知道其背后真正的运行规律，掌握着的这门吃饭的语言，也只是知其然，就算知其所以然，也感觉苍茫无力，因为这是两个世界；物理世界与计算机世界，世界万物由原子构成，原子由原子核和电子构成，电子绕着原子核运动，产生世间万物，不同的运行规律产生不同的物质（能量）；可在我理解的计算机世界即使不把这个世界抽象成最小的CPU指令集运行的最细小的组件上，还是有与这现实物理世界不同的法则，这是一套专门为计算机世界定下的规则，你运行计算机，写一段程序亦或是做一次运算，你都被这强大的计算机世界的基础法则所震慑； 不确定是有迹可循的：局部性原理在这个世界里，一段时间内，一个程序的执行仅限于这个程序的某个部分，诚然，程序访问的存储空间也局限于某一个内存区域； 时间局部性：一旦一个程序的某个指令一旦执行，则在未来的某个时间里，这个指令将再次被执行； 空间局部性：一旦一个程序访问了某个存储单元，则在未来的某个时间里，其附近的存储单元也将被访问； This is the god princples. 这个原理的影响是巨大的，你我天天写的 Java，运行在 Java 虚拟机中，原本是解释执行.class文件，但是这样性能真的不高，但是加持局部性原理的光环😇，就可以找到那些常用的，热点的代码，然后 JVM 会把他们编译成本地原生代码native code，这样执行效率就和执行C/C++差不多了； 博尔特在前面等你：缓存在计算机的世界里，CPU 的速度远远大于内存和硬盘，CPU &gt; 100倍内存 &gt; 1000万倍硬盘。 假设博尔特和你在跑接力赛，如果这个博尔特每次交接棒的时候都要等你，就像在计算机世界，如果运行一套程序，CPU 一直都要等着硬盘和内存的话，那计算机就太慢了。 所以，运用局部性原理，操作系统会把经常需要用的数据从硬盘取到内存，CPU会把经常用的数据从内存取到自己的缓存中。 通过这种方法，各方的速度不匹配问题，得到了几大的缓解； 在 web 开发中，缓存更显得非常常见，由于数据库（硬盘）太慢，大部分 web 系统都会把最常用的业务数据放到内存中缓存起来 抛弃细节： 抽象抽象是计算机科学中最为重要的概念之一。 当我们遇到复杂问题的时候， 抽象是非常重要的武器。 《深入理解计算机系统》一书中提到：“指令集是对CPU的抽象， 文件是对输入/输出设备的抽象， 虚拟存储器是对程序存储的抽象， 进程是对一个正在运行的程序的抽象， 而虚拟机是对整个计算机（包括操作系统、处理器和程序）的抽象。”— 感觉完全可以背下来，经典中的经典 CPU集成电路硬件无比复杂， 但是我们写程序肯定不用接触这些硬件细节， 那样就累死了， 我们只要遵循CPU的指令集， 程序就可以正确的运行， 而不用关心指令在硬件层次到底是怎么运行的。 硬盘也是这样， 有磁道，柱面，扇区， 我们写应用层程序也不用和这些烦人的细节打交道， 在操作系统和设备驱动的配合下， 我们只需要面对一个个“文件”，打开，读取，关闭就行了。 操作系统会把逻辑的文件翻译成物理磁盘上的字节。 再比如为了实现数据的共享，数据的一致性和安全性，需要大量的，复杂的程序代码来实现， 每个应用程序都实现一份肯定不是现实的。 所以计算机科学抽象出了一个叫数据库的东西， 你只需要安装数据库软件， 使用SQL和事务就能实现多用户对数据的安全访问了。 我只想和邻居打交道：分层原理说程序员比较宅，计算机的世界也一样，都比较懒（其实是为了效率），不愿意跨越更多的区域去做一件事； 分层其实也是抽象的一种，它通过层次把复杂的，可能变化的东西隔离开来， 某一层只能访问它的直接上层和下层， 不能跨层访问。 例如网络协议分层： OSI 的经典7层网络模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 TCP/IP 5层模型 应用层 传输层 网络层 数据链路层 物理层 再比如 Web 开发中的分层： 表示层 业务逻辑层 数据访问层 DB 分层的好处就是隔离变化， 在接口不变的情况下， 某一层的变化只会局限于本层次内。即使是接口变化， 也仅仅会影响调用方。 都是急性子：异步调用当你的程序需要等待一个长时间的操作而被阻塞住时而无所事事的时候， 异步调用就派上用场了。 异步调用简单就是说： 我等不及你了， 先去做别的事情， 你做完了告诉我一声。 回到最早的那个CPU的例子， CPU速度太快， 当它想读取硬盘文件的时候，是不会等待慢1000多万倍的硬盘的， 它会启动一个DMA , 不用通过CPU， 直接把数据从硬盘读到内存， 读完以后通过中断的方式来通知CPU。 Node.js 和 Web服务器Nginx 也是这样， 一个线程或若干个线程处理所有的请求， 遇到耗时的操作， 绝不等待， 马上去干别的事情，等到耗时操作完成后，再来通知这些干活的线程。 还有著名的AJAX , 当浏览器中的javascript发出一个Http 请求的时候, 也不会等待从服务器端返回数据， 只是设置一个回调函数， 服务器响应数据回来的时候调用一下就行了。 分而治之分而治之的基本思想是将一个规模比较大的问题分解为多个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，最后组合起来就可得到原问题的解。 由于子问题和原问题性质相同， 所以很多时候可以用递归。 归并排序就是一个经典的例子， 数据结构与算法书上到处都是， 这里就不在赘述了。 如果把分而治之泛化一下， 到软件设计领域， 就可以认为是把一个大问题逐步分解的过程","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Computer Principles","slug":"Code/Computer-Principles","permalink":"http://xiaoqinghua.site/categories/Code/Computer-Principles/"}],"tags":[{"name":"Computer Principles","slug":"Computer-Principles","permalink":"http://xiaoqinghua.site/tags/Computer-Principles/"}]},{"title":"Follow 算法过程验算","slug":"follow算法过程验算","date":"2018-07-10T07:08:15.000Z","updated":"2018-08-25T06:48:47.520Z","comments":true,"path":"follow算法过程验算.html","link":"","permalink":"http://xiaoqinghua.site/follow算法过程验算.html","excerpt":"","text":"举个栗子🌰 1follow(cs1,cs2) --&gt; follow(\"Z:z&gt;4|2=m=b-1+2+3$abcde\", \"Z:z&gt;1|2=m=b=1+2-1$fg\") 12345678910111213141516把cs1,cs2展开cs1:op1.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op1.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op1.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op1.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op1.5:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;charBank=&apos;abcde&apos;cs2:op2.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2.3:&#123; opcode: &apos;=&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2.5:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;charBank=&apos;fg&apos; 在follow函数中有一个applyZip的函数,其实这是一个迭代器,zip有拉链的意思,在迭代的过程中不断的两两运算,就像拉链一样一颗颗缝合起来: 1234567891011121314151617181920exports.applyZip = function (in1, idx1, in2, idx2, func) &#123; var iter1 = exports.opIterator(in1, idx1); var iter2 = exports.opIterator(in2, idx2); var assem = exports.smartOpAssembler(); var op1 = exports.newOp(); var op2 = exports.newOp(); var opOut = exports.newOp(); while (op1.opcode || iter1.hasNext() || op2.opcode || iter2.hasNext()) &#123; if ((!op1.opcode) &amp;&amp; iter1.hasNext()) iter1.next(op1); if ((!op2.opcode) &amp;&amp; iter2.hasNext()) iter2.next(op2); func(op1, op2, opOut); if (opOut.opcode) &#123; //print(opOut.toSource()); assem.append(opOut); opOut.opcode = ''; &#125; &#125; assem.endDocument(); return assem.toString();&#125;; 1234567891011开始迭代(循环)前,需要做一些准备工作:1、新建两个空的op1,op2对象，用于接收展开的cs1,cs2中所有的op对象的值Op op1 = new Op();op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;Op op2 = new Op();op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、新建一个opOut对象,用于接收每一次迭代完后我们得到的运算结果opOp opOut = new Op();opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125; 1234567891011121314第1次迭代:1、初始:按照顺序会使用cs1中的op1.1和cs2中的op2.1和一个刚刚new出来的新的op对象op1.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;ops : &quot;|2=m&quot;说明:both keep,follow之后op1,op2都没opcode,所以重新赋值next() 对应第1次迭代的具体代码:12345678910111213141516171819// both keepsopOut.opcode = '=';opOut.attribs = exports.followAttributes(op1.attribs, op2.attribs, pool);if (op1.chars &lt;= op2.chars) &#123; opOut.chars = op1.chars; opOut.lines = op1.lines; op2.chars -= op1.chars; op2.lines -= op1.lines; op1.opcode = ''; if (!op2.chars) &#123; op2.opcode = ''; &#125;&#125; else &#123; opOut.chars = op2.chars; opOut.lines = op2.lines; op1.chars -= op2.chars; op1.lines -= op2.lines; op2.opcode = '';&#125; 123456789101112第2次迭代:1、初始:op1.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b&quot;说明:both keep,follow之后op1,op2都没opcode,所以重新赋值next() 对应第2次迭代的具体代码:12345678910111213141516171819// both keepsopOut.opcode = '=';opOut.attribs = exports.followAttributes(op1.attribs, op2.attribs, pool);if (op1.chars &lt;= op2.chars) &#123; opOut.chars = op1.chars; opOut.lines = op1.lines; op2.chars -= op1.chars; op2.lines -= op1.lines; op1.opcode = ''; if (!op2.chars) &#123; op2.opcode = ''; &#125;&#125; else &#123; opOut.chars = op2.chars; opOut.lines = op2.lines; op1.chars -= op2.chars; op1.lines -= op2.lines; op2.opcode = '';&#125; 123456789101112第3次迭代:1、初始:op1.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2.3:&#123; opcode: &apos;=&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b&quot;说明:op1-,op2=,follow之后op1,op2都没opcode,所以重新赋值next() 对应第3次迭代的具体代码: 12345678910111213141516if (!op2.opcode) &#123; op1.opcode = '';&#125; else &#123; if (op1.chars &lt;= op2.chars) &#123; op2.chars -= op1.chars; op2.lines -= op1.lines; op1.opcode = ''; if (!op2.chars) &#123; op2.opcode = ''; &#125; &#125; else &#123; op1.chars -= op2.chars; op1.lines -= op2.lines; op2.opcode = ''; &#125;&#125; 123456789101112第4次迭代:1、初始:op1.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b=2&quot;说明:both+,follow之后op1没opcode,所以重新赋值next() 对应第4次迭代的具体代码:123456789101112131415161718192021222324252627282930313233343536373839404142var whichToDo;if (op2.opcode != '+') &#123; whichToDo = 1;&#125; else if (op1.opcode != '+') &#123; whichToDo = 2;&#125; else &#123; // both + var firstChar1 = chars1.peek(1); var firstChar2 = chars2.peek(1); var insertFirst1 = hasInsertFirst(op1.attribs); var insertFirst2 = hasInsertFirst(op2.attribs); if (insertFirst1 &amp;&amp; !insertFirst2) &#123; whichToDo = 1; &#125; else if (insertFirst2 &amp;&amp; !insertFirst1) &#123; whichToDo = 2; &#125; // insert string that doesn't start with a newline first so as not to break up lines else if (firstChar1 == '\\n' &amp;&amp; firstChar2 != '\\n') &#123; whichToDo = 2; &#125; else if (firstChar1 != '\\n' &amp;&amp; firstChar2 == '\\n') &#123; whichToDo = 1; &#125; // break symmetry: else if (reverseInsertOrder) &#123; whichToDo = 2; &#125; else &#123; whichToDo = 1; &#125;&#125;if (whichToDo == 1) &#123; chars1.skip(op1.chars); opOut.opcode = '='; opOut.lines = op1.lines; opOut.chars = op1.chars; opOut.attribs = ''; op1.opcode = '';&#125; else &#123; // whichToDo == 2 chars2.skip(op2.chars); exports.copyOp(op2, opOut); op2.opcode = '';&#125; 123456789101112第5次迭代:1、初始:op1.5:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;(第4次循环follow算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b=2=3&quot;说明:both+,follow之后op1没opcode,所以重新赋值next(),但此时已没有next(),故还是使用op1原有值 对应第5次迭代的具体代码:123456789101112131415161718192021222324252627282930313233343536373839404142var whichToDo;if (op2.opcode != '+') &#123; whichToDo = 1;&#125; else if (op1.opcode != '+') &#123; whichToDo = 2;&#125; else &#123; // both + var firstChar1 = chars1.peek(1); var firstChar2 = chars2.peek(1); var insertFirst1 = hasInsertFirst(op1.attribs); var insertFirst2 = hasInsertFirst(op2.attribs); if (insertFirst1 &amp;&amp; !insertFirst2) &#123; whichToDo = 1; &#125; else if (insertFirst2 &amp;&amp; !insertFirst1) &#123; whichToDo = 2; &#125; // insert string that doesn't start with a newline first so as not to break up lines else if (firstChar1 == '\\n' &amp;&amp; firstChar2 != '\\n') &#123; whichToDo = 2; &#125; else if (firstChar1 != '\\n' &amp;&amp; firstChar2 == '\\n') &#123; whichToDo = 1; &#125; // break symmetry: else if (reverseInsertOrder) &#123; whichToDo = 2; &#125; else &#123; whichToDo = 1; &#125;&#125;if (whichToDo == 1) &#123; chars1.skip(op1.chars); opOut.opcode = '='; opOut.lines = op1.lines; opOut.chars = op1.chars; opOut.attribs = ''; op1.opcode = '';&#125; else &#123; // whichToDo == 2 chars2.skip(op2.chars); exports.copyOp(op2, opOut); op2.opcode = '';&#125; 123456789101112第6次迭代:1、初始:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;(第5次循环follow算法后的op1)op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;(第4次循环follow算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b=2=3+2&quot;说明:op2+,follow之后op1，op2没opcode,所以重新赋值next(),但此时已没有next(),故还是使用op1，op2原有值 对应第6次迭代的具体代码:123456789101112131415161718192021222324252627282930313233343536373839404142var whichToDo;if (op2.opcode != '+') &#123; whichToDo = 1;&#125; else if (op1.opcode != '+') &#123; whichToDo = 2;&#125; else &#123; // both + var firstChar1 = chars1.peek(1); var firstChar2 = chars2.peek(1); var insertFirst1 = hasInsertFirst(op1.attribs); var insertFirst2 = hasInsertFirst(op2.attribs); if (insertFirst1 &amp;&amp; !insertFirst2) &#123; whichToDo = 1; &#125; else if (insertFirst2 &amp;&amp; !insertFirst1) &#123; whichToDo = 2; &#125; // insert string that doesn't start with a newline first so as not to break up lines else if (firstChar1 == '\\n' &amp;&amp; firstChar2 != '\\n') &#123; whichToDo = 2; &#125; else if (firstChar1 != '\\n' &amp;&amp; firstChar2 == '\\n') &#123; whichToDo = 1; &#125; // break symmetry: else if (reverseInsertOrder) &#123; whichToDo = 2; &#125; else &#123; whichToDo = 1; &#125;&#125;if (whichToDo == 1) &#123; chars1.skip(op1.chars); opOut.opcode = '='; opOut.lines = op1.lines; opOut.chars = op1.chars; opOut.attribs = ''; op1.opcode = '';&#125; else &#123; // whichToDo == 2 chars2.skip(op2.chars); exports.copyOp(op2, opOut); op2.opcode = '';&#125; 123456789101112第7次迭代:1、初始:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;(第6次循环follow算法后的op1)op2.5:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b=2=3+2-1&quot;说明:判断，op1,op2都没有opcode,也没有next()了,停止 对应第7次迭代的具体代码:12345678910111213141516171819exports.copyOp(op2, opOut);if (!op1.opcode) &#123; op2.opcode = '';&#125; else if (op2.chars &lt;= op1.chars) &#123; // delete part or all of a keep op1.chars -= op2.chars; op1.lines -= op2.lines; op2.opcode = ''; if (!op1.chars) &#123; op1.opcode = ''; &#125;&#125; else &#123; // delete all of a keep, and keep going opOut.lines = op1.lines; opOut.chars = op1.chars; op2.lines -= op1.lines; op2.chars -= op1.chars; op1.opcode = '';&#125; 算法结果12345678910111213141516171819202122232425261 Changeset = require(\"./src/static/js/Changeset\");2 var csA = \"Z:z&gt;4|2=m=b-1+2+3$abcde\";3 var csB = \"Z:z&gt;1|2=m=b=1+2-1$fg\";45 var doc = \"Hello World\\n\\n Hello World Hello Wor\";67 var appliedA = Changeset.applyToText(csA,doc);8 var appliedB = Changeset.applyToText(csB,doc);910 console.log('apply csA:', appliedA, ',apply csB: ', appliedB);1112 var csA1 = Changeset.follow(csB,csA,true,null);13 var csB1 = Changeset.follow(csA,csB,false,null);1415 console.log('csA1:', csA1, 'csB1: ', csB1);1617 // X * csA * csB1 = Y18 // X * csB * csA1 = Y1920 var leftY = Changeset.applyToText(csB1, appliedA);21 var rightY = Changeset.applyToText(csA1, appliedB);2223 console.log('final left:', leftY, ',final right: ', rightY);24 if (leftY === rightY) &#123;25 console.log('bingo');26 &#125; 12345678910111213141516171819202122apply csA: Hello World Hello World Hello Wabcderapply csB: Hello World Hello World Hello WofgcsA1: Z:10&gt;4|2=m=b-1+5$abcdecsB1: Z:13&gt;1|2=m=g-1+2$fgfinal left: Hello World Hello World Hello Wabcdefgfinal right: Hello World Hello World Hello Wabcdefgbingo 123456789&gt; var cs1 = \"Z:z&gt;4|2=m=b-1+2+3$abcde\";&gt; var cs2 = \"Z:z&gt;1|2=m=b=1+2-1$fg\";&gt; Changeset.follow(cs1,cs2,false,null);'Z:13&gt;1|2=m=g-1+2$fg'最终的CS:'Z:13&gt;1|2=m=g-1+2$fg' 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/follow算法过程验算.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"Follow 算法图解","slug":"follow算法图解","date":"2018-07-09T07:09:28.000Z","updated":"2018-08-25T06:48:26.023Z","comments":true,"path":"follow算法图解.html","link":"","permalink":"http://xiaoqinghua.site/follow算法图解.html","excerpt":"","text":"01 02 03 04 05 06 07 08 09 10 11 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/follow算法图解.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"FollowAttributes 算法解析","slug":"followAttributes算法解析","date":"2018-06-19T07:09:01.000Z","updated":"2018-08-25T06:48:11.575Z","comments":true,"path":"followAttributes算法解析.html","link":"","permalink":"http://xiaoqinghua.site/followAttributes算法解析.html","excerpt":"","text":"何时用 followAttributes在follow算法中，op两两进行运算，包含15种情况，何时进行属性的合并即followAttributes，在代码中我们可以发现，仅在op1，op2的opcode同时为‘=’时进行\bfollowAttributes。 为何用 followAttributes followAttributes函数注释\b 123456// The merge of two sets of attribute changes to the same text// takes the lexically-earlier value if there are two values// for the same key. Otherwise, all key/value changes from// both attribute sets are taken. This operation is the \"follow\",// so a set of changes is produced that can be applied to att1// to produce the merged set. 1234以上注释大概意思：两个属性改变集的合并作用于同一段文，如果同一个key有两个不同的值则采取字典排序在前的值。否则，所有的键值都将改变因为两个属性集都被采取。此操作为‘follow’，因此产生了一组可以应用于‘att1’属性的变更，去生成合并集。 \b通过follow算法我们了解到，仅在op1，op2的opcode同时为‘=’时，\b此时的op1，op2两两运算才是操作的同一段文本字符(\b如\bop1为+，op2为-)操作的不是同一处文本。 followAttributes 过程 准备AttributePool 1234567var p = new AttributePool();p.putAttrib(['x', '']);p.putAttrib(['x', 'abc']);p.putAttrib(['x', 'def']);p.putAttrib(['y', '']);p.putAttrib(['y', 'abc']);p.putAttrib(['y', 'def']); 构造运算 12assertEqualStrings('*3', Changeset.followAttributes('*0*4', '*2*3', p));assertEqualStrings('*0', Changeset.followAttributes('*2*3', '*0*4', p)); AttributePool中\b依次存入了6个属性: 1234567891011121314151617181920212223242526&#123; \"0\": [ \"x\", \"\" ], \"1\": [ \"x\", \"abc\" ], \"2\": [ \"x\", \"def\" ], \"3\": [ \"y\", \"\" ], \"4\": [ \"y\", \"abc\" ], \"5\": [ \"y\", \"def\" ]&#125; op1使用的属性为\b&quot;0&quot;: [&quot;x&quot;,&quot;&quot;]、&quot;4&quot;: [&quot;y&quot;,&quot;abc&quot;]，op2使用的属性为\b&quot;2&quot;: [&quot;x&quot;,&quot;def&quot;]、&quot;3&quot;: [&quot;y&quot;,&quot;&quot;] 代码详解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static String followAttributes(String att1, String att2, AttributePool pool) &#123; // 在上述的示例中 att1，att2 均不为空，故可忽略下面两行代码 // 但是在 att2 为空，pool 为空的情况下，followAttributes 返回空，为何？ // 因为在上层函数 follow 中即 follow(op1,op2)，op1 是已经应用的操作，\b当 op2 使用的属性为空时， // 我们最终所需要的操作 opOut 相当于保持 op1 的操作 /* 对应上层函数follow中这段代码，同样的 attribs 返回空字符串 if (whichToDo == 1) &#123; opOut.opcode = Op.OPCODE_KEEP; opOut.lines = op1.lines; opOut.chars = op1.chars; opOut.attribs = EMPTY_STRING; &#125; */ if (isEmpty(att2) || pool == null) &#123; return EMPTY_STRING; &#125; // 同理可证 /* 对应层函数follow中这段代码，同样的 attribs 使用的是 op2 的 'attribs' &#125; else if (!op1.hasOpcode()) &#123; Op.copyOp(op2, opOut); op2.clearOpcode(); &#125; */ if (isEmpty(att1)) &#123; return att2; &#125; // 新建一个空的集合即我们想要的最后结果属性集 // 下面做的操作就是把 att2 的属性加到 atts 中，其实 atts 就是 att2 List&lt;Attribute&gt; atts = Lists.newArrayList(); // 在上述实例中，经过不断的正则匹配迭代，atts=[ [\"x\",\"def\"],[\"y\",\"\"] ] Matcher matcher = PATTERN_ATTRIBUTE.matcher(att2); while (matcher.find()) &#123; atts.add(pool.getAttrib(parseNum(matcher.group(1)))); &#125; // 这里使用嵌套循环，相当于两两对比 att1 和 att2 相同 key 对应的属性值的字典排序\b值的大小 // 只是我们最终得到的都是att2的值，在一次次比较中删除或不删除 att2 中的值 matcher = PATTERN_ATTRIBUTE.matcher(att1); while (matcher.find()) &#123; Attribute pair1 = pool.getAttrib(parseNum(matcher.group(1))); for (int i = 0; i &lt; atts.size(); i++) &#123; Attribute pair2 = atts.get(i); if (pair1.getKey().equals(pair2.getKey())) &#123; // winner of merge is pair1, delete this attribute // 第一次比较 '' &lt; 'def',则删除 atts 中的 '[\"x\",\"def\"]' ,atts=[ [\"y\",\"\"] ] // 第二次比较 'abc' &gt; '',没有操作 ,最终 atts=[ [\"y\",\"\"] ] // TODO 此处为何根据值的字典排序比较？ if (pair1.getValue().compareTo(pair2.getValue()) &lt;= 0) &#123; // 移除 atts.remove(i); &#125; &#125; &#125; &#125; // we've only removed attributes, so they're already sorted StringAssembler buf = new StringAssembler(); for (int i = 0; i &lt; atts.size(); i++) &#123; buf.append(\"*\"); // atts=[ [\"y\",\"\"] ] 中 [\"y\",\"\"]在 pool 中 index=3 buf.append(numToString(pool.putAttrib(atts.get(i)))); &#125; return buf.toString();&#125;; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/followAttributes算法解析.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"etherpad 技术分析","slug":"etherpad技术分析","date":"2018-06-19T07:07:54.000Z","updated":"2018-08-25T06:47:49.706Z","comments":true,"path":"etherpad技术分析.html","link":"","permalink":"http://xiaoqinghua.site/etherpad技术分析.html","excerpt":"","text":"Etherpad \b技术分析领域模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Pad &#123; head atext apool&#125;class PadRevision &#123; author revision changeset timestamp&#125;class Changeset &#123; oldLength newLength ops charBank&#125;class Op &#123; opcode lines chars attribs&#125;class AText &#123; text attribs&#125;class AttributePool &#123; nextNum numToAttrib attribToNum&#125;class Attribute &#123; key value&#125;Pad o---&gt; PadRevisionPad o---&gt; ATextPad o---&gt; AttributePoolPadRevision o--&gt; ChangesetChangeset o--&gt; OpAttributePool o..&gt; Attribute Padpad 在 etherpad 中对应一篇文档，是多人协作的基本单位。 对 pad 的每一次编辑操作，都会生成一个 revision, 类似于版本控制系统(尤其类似于 svn)中的一次提交，revision 从零开始往上递增，head 指向当前最新的 revision。对所有的 revision 依次计算，可以得出 pad 的正文，但是对于有大量编辑操作的 pad, 打开 pad 时大量的计算势必影响加载速度，所以 pad 中包含 atext 字段表示当前\b的内容，以空间换时间。atext 包含两部分： text 和 attribs, text 就是该文档的正文，attribs 是描述正文的内容都有哪些属性。 \bapool 是属性 “池”，\b记录了属性编号对应的属性。 ATextAtext 示例数据： 1234&#123; \"text\": \"Welcome to Etherpad!\\n\\nThis pad text is synchronized as you type, so that everyone viewing this page sees the same text. This allows you to collaborate seamlessly on documents!\\n\\nGet involved with Etherpad at http://etherpad.org\\n\\nsdf\\n\\ns\\nsdf\\nsefssss\\n\\nsss\\nsdf\\nsss\\n\\nsefffsdfsssef\\nesssdfsd\\ns\\nsdfsdfsd\\n\\ncvb\\nsdfsdf\\n\\naaaaaaaaaaaaaaaaa第三方斯蒂芬\\n\\nsdf\\n\\nsdsssdf\\n\\nabc\\n\\nabccccfbcfcvbcfgrddfgddddd\\n\\nsdfesfsges\\n\\nsdfdsses\\n\\nsseg\\n\\n\\nsdfesgessdf\\n\\n\\n\\nsdfessefgdfg\\n\", \"attribs\": \"|2+m+1o*4+7|2+2g*3+1d*0|5+9*1+3*0|1+1*0+7|1+1*1|1+1*0+3*1|2+5*0+3*1|2+2*0+5*2+8*1|2+a*2+1*1|3+b*2+3*1|3+9*1+n*2|3+6*0|5+f*0+3*2+b*0|1+d*2|1+1*0+a*2|2+2*2+5*0+3*2|2+2*0+4*2|1+1*0|2+2*0+7*2|4+8*2+7*0+5|1+1\"&#125; AttributePoolAttributePoolJson 是 AttributePool 保存到数据库中的形式，加载到内存时会做一次转换。 AttributePool 多了一个 Attribute -&gt; num 的反向索引，用于快速的通过 Attribute 找到对应的编号。 etherpad 的设计中， AttributePool 的属于某个 pad 的 “命名空间” 的， 也就是说，每个 pad 都会有自己的 AttributePool。 AttributePoolJson 示例数据： 12345678910111213141516171819202122232425&#123; \"numToAttrib\": &#123; \"0\": [ \"author\", \"a.lbCJXik3gn5kFmZn\" ], \"1\": [ \"author\", \"a.QOApinD3T5GQ57t6\" ], \"2\": [ \"author\", \"a.EAPXEvFdNybN83aD\" ], \"3\": [ \"strikethrough\", \"true\" ], \"4\": [ \"bold\", \"true\" ] &#125;, \"nextNum\": 5&#125; PadRevision每个 revision 都记录了 author 和 timestamp, 因此可以回到任意的历史编辑状态。 revision 的主要内容是 changeset. Changeset一个 changeset 代表对文档的变更。 changeset 的结构: 图片来源: http://slix.rocks/%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E4%B8%AD-easysync2-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/ Opetherpad 共有四种操作： 1234*N: 应用某个属性=N: 保留 N 个字符+N: 增加 N 个字符-N: 删除 N 个字符 在线 demo。 etherpad 的 OT 实现实时协同编辑的核心算法是 OT，而 Etherpad 中 OT 的实现是一个名为 follow 的函数。 详见 follow 算法。 client server 协议长连接etherpad 使用开源 SocketIO 库，这个库在\b浏览器支持 websocket 时，\b会使用 websocket, 在老旧的浏览器中会 fallback 到 long polling 上。 SocketIO 也有不少批评的声音，例如: https://github.com/rethinkdb/horizon/issues/413 。 考虑到目前主流的浏览器都已经支持 websocket 了，可以考虑\b用原生 websocket, 如果必须支持老旧浏览器，则可以考虑 sockjs(onlyoffice 好像用的这个)。 服务端逻辑多人编辑是一定会出现冲突的，通过两个办法解决冲突: \b服务端通过\b排队的方式，把\b并发修改的的操作\b串行化； 如果某次修改的 baseRev 不是当前 pad 的 head, 则通过 OT 算法\b\b对于已经 commit 的修改依次计算，这个过程有点类似于 git 的 rebase。 1234567891011121314151617181920212223242526272829autonumberskinparam ParticipantPadding 90title 服务端处理流程\\n\\nClient -&gt; Server: baseRev + CSServer -&gt; Server: enqueue baseRev + CS|||loopServer -&gt; Server: follownote leftwhile (baseRev &lt; head) &#123; CS = follow(R(baseRev), CS); baseRev++;&#125;end noteend|||Server -&gt; Server: save revisionServer -&gt; Client: accept commit|||Server -&gt; &quot;Other clients&quot;: CS(head + 1) 客户端逻辑 将新的输入合并到本地变更 ace2_inner.js 12var editor = new Ace2Inner()editor.init(); ace.js 1234567891011121314151617181、editor.init = function(containerId, initialCode, doneFunc)&#123;&#125;2、doActionsPendingInit()3、aceFunctionsPendingInit.getFormattedCode4、ace2_inner.jsfunction getFormattedCode()&#123; inCallStackIfNecessary(\"getFormattedCode\", incorporateUserChanges);&#125;5、function observeSuspiciousNodes()6、function incorporateUserChanges(isTimeUp)fastIncorp()inCallStackIfNecessary(\"handleKeyEvent\", function()&#123;&#125; 向服务器提交变更集 12345671、collab_client.js2、function getCollabClient(ace2editor, serverVars, initialUserInfo, options, _pad)&#123;&#125;3、editor.setUserChangeNotificationCallback(wrapRecordingErrors(\"handleUserChanges\", handleUserChanges));4、handleUserChanges() 回复确认已提交的变更集(ack) 监听其他客户的变更集 连接到服务器并请求初始文档 pad.html 1&lt;script type=\"text/javascript\"&gt; pad.init(); &lt;/script&gt; pad.js 123456781、init: function()2、function handshake()3、socket.once('connect', function () &#123; sendClientReady(false); &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475skinparam ParticipantPadding 90title 客户端处理流程\\n\\n||||||Server &lt;- Client: first connect &lt;&lt; unique ID &gt;&gt;note rightasync.waterfall()end notenote right of A #aqua收到服务器确认的变更状态end notenote right of X #aqua把变更发到服务器时的状态end notenote right of Y #aqua用户已输入的状态end notenote right of E #aqua用户正在输入end note|||Client &lt;- Server: HEADTEXT|||note over Client , Aidentity mappingend note|||A &lt;-[#0000FF]- X: A=X*A|||X &lt;-[#0000FF]- Y:note rightY=Y*Eend note|||Y &lt;-[#ED3EEE] E: types|||Y -[#0000FF]-&gt; Server: submit &lt;&lt; cs+uid &gt;&gt;|||note over A , Yevery 500msend note|||A &lt;-- Server: acknowledgement |||&quot;Other clients&quot; &lt;-- Client : monitor other client|||&quot;Other clients&quot; --&gt; Server: other cs|||Client -&gt; Client: composenote leftmakeChangesetTracker()end note|||Server -&gt; Server: server logic||| 后续产品化工作\b 长连接多机分布 数据库扩展 账户系统 运维自动化系统 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/etherpad技术分析.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"EtherPad","slug":"Code/EtherPad","permalink":"http://xiaoqinghua.site/categories/Code/EtherPad/"}],"tags":[{"name":"EtherPad","slug":"EtherPad","permalink":"http://xiaoqinghua.site/tags/EtherPad/"}]},{"title":"ComposeAttributes 算法解析","slug":"composeAttributes算法解析","date":"2018-06-18T07:10:02.000Z","updated":"2018-08-25T06:46:49.131Z","comments":true,"path":"composeAttributes算法解析.html","link":"","permalink":"http://xiaoqinghua.site/composeAttributes算法解析.html","excerpt":"","text":"何时用 composeAttributes在compose算法中，op两两进行运算，何时进行属性的合并即composeAttributes，在代码中我们可以发现，仅在op1，op2的opcode同时为‘=’时，或者op2的opcode为‘=’，op1的opcode为‘+’时进行\bcomposeAttributes。 为何用 composeAttributes composeAttributes函数注释\b 12345678910111213// att1 and att2 are strings like \"*3*f*1c\", asMutation is a boolean.// Sometimes attribute (key,value) pairs are treated as attribute presence// information, while other times they are treated as operations that// mutate a set of attributes, and this affects whether an empty value// is a deletion or a change.// Examples, of the form (att1Items, att2Items, resultIsMutation) -&gt; result// ([], [(bold, )], true) -&gt; [(bold, )]// ([], [(bold, )], false) -&gt; []// ([], [(bold, true)], true) -&gt; [(bold, true)]// ([], [(bold, true)], false) -&gt; [(bold, true)]// ([(bold, true)], [(bold, )], true) -&gt; [(bold, )]// ([(bold, true)], [(bold, )], false) -&gt; []// pool can be null if att2 has no attributes. 123以上注释大概意思：att1和att2是类似于“*3*f*1c”的字符串，resultIsMutation是一个布尔值。有时属性(键、值)对被视为属性存在信息，而有时它们被视为改变一组属性的操作，这将影响空值是删除还是更改。 \b通过compose算法我们了解到，仅在op1，op2的opcode同时为‘=’时，\b此时的op1，op2两两运算才是操作的同一段文本字符(\b如\bop1为+，op2为-)操作的不是同一处文本。 composeAttributes 过程 准备AttributePool 1234567var p = new AttributePool();p.putAttrib(['x', '']);p.putAttrib(['x', 'abc']);p.putAttrib(['x', 'def']);p.putAttrib(['y', '']);p.putAttrib(['y', 'abc']);p.putAttrib(['y', 'def']); 构造运算 12assertEqualStrings('*0*3', Changeset.composeAttributes('*0*4', '*2*3', true, p));assertEqualStrings('*0*4', Changeset.composeAttributes('*2*3', '*0*4', true, p)); AttributePool中\b依次存入了6个属性: 1234567891011121314151617181920212223242526&#123; \"0\": [ \"x\", \"\" ], \"1\": [ \"x\", \"abc\" ], \"2\": [ \"x\", \"def\" ], \"3\": [ \"y\", \"\" ], \"4\": [ \"y\", \"abc\" ], \"5\": [ \"y\", \"def\" ]&#125; op1使用的属性为\b&quot;0&quot;: [&quot;x&quot;,&quot;&quot;]、&quot;4&quot;: [&quot;y&quot;,&quot;abc&quot;]，op2使用的属性为\b&quot;2&quot;: [&quot;x&quot;,&quot;def&quot;]、&quot;3&quot;: [&quot;y&quot;,&quot;&quot;] 代码详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static String composeAttributes(String att1, String att2, boolean resultIsMutation, AttributePool pool) &#123; // 这两步其实和 followAttributes 相似，在外层函数，都有对应情况的代码 if (isEmpty(att1) &amp;&amp; resultIsMutation) &#123; // In the case of a mutation (i.e. composing two exportss), // an att2 composed with an empy att1 is just att2. If att1 // is part of an attribution string, then att2 may remove // attributes that are already gone, so don't do this optimization. return att2; &#125; if (isEmpty(att2)) &#123; return att1; &#125; // 新建一个空的集合即我们想要的最后结果属性集 // 下面做的操作就是把 att1 的属性加到 atts 中，其实 atts 就是 att1 List&lt;Attribute&gt; atts = new LinkedList&lt;&gt;(); // 经过不断的正则匹配迭代 atts==att1 Matcher matcher = PATTERN_ATTRIBUTE.matcher(att1); while (matcher.find()) &#123; String attId = matcher.group(1); atts.add(pool.getAttrib(parseNum(attId))); &#125; // 这里使用嵌套循环，相当于两两对比 att1 和 att2 相同 key 对应是否有值或者是否突变 // 只是我们最终得到的都是att2的值，在一次次比较中删除 att2 中的值，或者 设置成以前 att1 的值 matcher = PATTERN_ATTRIBUTE.matcher(att2); while (matcher.find()) &#123; String attId = matcher.group(1); Attribute pair = pool.getAttrib(parseNum(attId)); boolean found = false; for (int i = 0; i &lt; atts.size(); i++) &#123; Attribute oldPair = atts.get(i); if (oldPair.getKey().equals(pair.getKey())) &#123; if (pair.hasValue() || resultIsMutation) &#123; // 注意这里是 set, 即替换成 att2 的值 // 遇到相同的 key, 如果 att2 有值或者是突变，就把 att1 中的值替换成 att2 的值 atts.set(i, oldPair.withValue(pair.getValue())); &#125; else &#123; // 遇到相同的 key, 如果 att2 没有值，则删除 att1 中的值(即 atts 的值) atts.remove(i); &#125; found = true; break; &#125; &#125; // 如果没有找到相同的 key 则直接用 att2 if ((!found) &amp;&amp; (pair.hasValue() || resultIsMutation)) &#123; atts.add(pair); &#125; &#125; // atts 这里进行了自然排序，所以在 followAttributes 的时候按照自然排序取值 // 在 js 源码中，atts.sort(); // atts.sort();没有 compareFunction 参数，所以排序时直接将数组的元素转换成字符串，按照字符串的 Unicode 排序 atts.sort(Comparator.comparing(Attribute::toString)); StringAssembler buf = new StringAssembler(); for (int i = 0; i &lt; atts.size(); i++) &#123; buf.append(\"*\"); buf.append(numToString(pool.putAttrib(atts.get(i)))); &#125; //print(att1+\" / \"+att2+\" / \"+buf.toString()); return buf.toString();&#125; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/composeAttributes算法解析.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"Compose 算法过程验算","slug":"compose算法过程验算","date":"2018-06-18T07:09:51.000Z","updated":"2018-08-25T06:47:07.463Z","comments":true,"path":"compose算法过程验算.html","link":"","permalink":"http://xiaoqinghua.site/compose算法过程验算.html","excerpt":"","text":"举个栗子🌰 1compose(cs1,cs2) --&gt; compose(\"Z:z&gt;4|2=m=b-1+2+3$abcde\", \"Z:13&gt;1|2=m=g-1+2$fg\") 123456789101112131415把cs1,cs2展开cs1:op1.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op1.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op1.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op1.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op1.5:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;charBank=&apos;abcde&apos;cs2:op2.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2.2:&#123; opcode: &apos;=&apos;, chars: 16, lines: 0, attribs: &apos;&apos; &#125;op2.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;charBank=&apos;fg&apos; 同follow函数一样，在compose函数中也有一个applyZip的函数,其实这是一个迭代器,同时还有一个_slicerZipperFunc的分片迭代器，是专门为compose准备的函数。zip有拉链的意思,在迭代的过程中不断的两两运算,就像拉链一样一颗颗缝合起来: applyZip函数 1234567891011121314151617181920exports.applyZip = function (in1, idx1, in2, idx2, func) &#123; var iter1 = exports.opIterator(in1, idx1); var iter2 = exports.opIterator(in2, idx2); var assem = exports.smartOpAssembler(); var op1 = exports.newOp(); var op2 = exports.newOp(); var opOut = exports.newOp(); while (op1.opcode || iter1.hasNext() || op2.opcode || iter2.hasNext()) &#123; if ((!op1.opcode) &amp;&amp; iter1.hasNext()) iter1.next(op1); if ((!op2.opcode) &amp;&amp; iter2.hasNext()) iter2.next(op2); func(op1, op2, opOut); if (opOut.opcode) &#123; //print(opOut.toSource()); assem.append(opOut); opOut.opcode = ''; &#125; &#125; assem.endDocument(); return assem.toString();&#125;; _slicerZipperFunc函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * Function used as parameter for applyZip to apply a Changeset to an attribute */ private static Op _slicerZipperFunc(Op attOp, Op csOp, AttributePool pool) &#123; // attOp is the op from the sequence that is being operated on, either an // attribution string or the earlier of two exportss being composed. // pool can be null if definitely not needed. //print(csOp.toSource()+\" \"+attOp.toSource()+\" \"+opOut.toSource()); // 在 compose 中 ，attOp 是正在被操作的即 op1 Op opOut = new Op(); if (attOp.isMinus()) &#123; // 如果 op1 是 - ，则我们需要的 opOut 使用 op1 Op.copyOp(attOp, opOut); // 清空 op1 操作 attOp.clearOpcode(); &#125; else if (!attOp.hasOpcode()) &#123; // 如果 op1 没有操作，则使用 op2 Op.copyOp(csOp, opOut); // 清空 op2 操作 csOp.clearOpcode(); &#125; else &#123; switch (csOp.opcode) &#123; case Op.OPCODE_MINUS: &#123; // 如果 op2 操作的字符小于等于 op1 操作的字符 if (csOp.chars &lt;= attOp.chars) &#123; // delete or delete part if (attOp.isKeep()) &#123; // 如果 op2 是 -,op1 是 = // 合并后的是-，可以理解为，先=后- opOut.opcode = Op.OPCODE_MINUS; // 取小的部分 opOut.chars = csOp.chars; opOut.lines = csOp.lines; opOut.attribs = EMPTY_STRING; &#125; // 如果 op2 是 -,op1 是 + // 得到是空的 opOut ，相当于不做任何操作，直至没有下一次运算 attOp.chars -= csOp.chars; attOp.lines -= csOp.lines; csOp.clearOpcode(); if (attOp.chars == 0) &#123; attOp.clearOpcode(); &#125; &#125; else &#123; // 如果 op2 操作的字符大于 op1 操作的字符 // delete and keep going if (attOp.isKeep()) &#123; // 如果 op2 是 -,op1 是 = // 合并后的是-，可以理解为，先=后- opOut.opcode = Op.OPCODE_MINUS; // 取小的部分 opOut.chars = attOp.chars; opOut.lines = attOp.lines; opOut.attribs = EMPTY_STRING; &#125; // 取相减的部分 csOp.chars -= attOp.chars; csOp.lines -= attOp.lines; attOp.clearOpcode(); &#125; break; &#125; case Op.OPCODE_PLUS: &#123; // insert // 如果 op2 是 +，则合并后还是 + Op.copyOp(csOp, opOut); csOp.clearOpcode(); break; &#125; case Op.OPCODE_KEEP: &#123; // 如果 op2 是 = // 如果 op2 操作的字符小于等于 op1 操作的字符 if (csOp.chars &lt;= attOp.chars) &#123; // keep or keep part 保持或者保持一部分(保持 op1 的操作和全部的操作字符串和换行 或者 保持 op1 的操作和一部分的操作字符串和换行) // 可以理解为：op1增加或者保持了n个字符，op2保持了m个字符(m&lt;=n) opOut.opcode = attOp.opcode; opOut.chars = csOp.chars; opOut.lines = csOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); csOp.clearOpcode(); // 剩余部分 attOp.chars -= csOp.chars; attOp.lines -= csOp.lines; if (attOp.chars == 0) &#123; attOp.clearOpcode(); &#125; &#125; else &#123; // 如果 op2 操作的字符大于 op1 操作的字符 // keep and keep going 保持并且继续 opOut.opcode = attOp.opcode; opOut.chars = attOp.chars; opOut.lines = attOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); attOp.clearOpcode(); // 剩余部分 csOp.chars -= attOp.chars; csOp.lines -= attOp.lines; &#125; break; &#125; case EMPTY_STRING: &#123; // 如果 op2 是 空操作，则合并后还是 op1 的操作 Op.copyOp(attOp, opOut); attOp.clearOpcode(); break; &#125; &#125; &#125; return opOut; &#125; 1234567891011开始迭代(循环)前,需要做一些准备工作:1、新建两个空的op1,op2对象，用于接收展开的cs1,cs2中所有的op对象的值Op op1 = new Op();op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;Op op2 = new Op();op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、新建一个opOut对象,用于接收每一次迭代完后我们得到的运算结果opOp opOut = new Op();opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125; 1234567891011121314第1次迭代:1、初始:按照顺序会使用cs1中的op1.1和cs2中的op2.1和一个刚刚new出来的新的op对象op1.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;assem : &quot;|2=m&quot;说明:both keep,compose之后op1,op2都没opcode,所以重新赋值next() 对应第1次迭代的具体代码:1234567891011121314151617181920case Op.OPCODE_KEEP: &#123; // 如果 op2 是 = // 如果 op2 操作的字符小于等于 op1 操作的字符 if (csOp.chars &lt;= attOp.chars) &#123; // keep or keep part 保持或者保持一部分(保持 op1 的操作和全部的操作字符串和换行 或者 保持 op1 的操作和一部分的操作字符串和换行) // 可以理解为：op1增加或者保持了n个字符，op2保持了m个字符(m&lt;=n) opOut.opcode = attOp.opcode; opOut.chars = csOp.chars; opOut.lines = csOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); csOp.clearOpcode(); // 剩余部分 attOp.chars -= csOp.chars; attOp.lines -= csOp.lines; if (attOp.chars == 0) &#123; attOp.clearOpcode(); &#125; &#125; 123456789101112第2次迭代:1、初始:op1.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2.2:&#123; opcode: &apos;=&apos;, chars: 16, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 5, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;说明:both keep,compose之后op2还有opcode,所以重新赋值next() 对应第2次迭代的具体代码:12345678910111213else &#123; // 如果 op2 操作的字符大于 op1 操作的字符 // keep and keep going 保持并且继续 opOut.opcode = attOp.opcode; opOut.chars = attOp.chars; opOut.lines = attOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); attOp.clearOpcode(); // 剩余部分 csOp.chars -= attOp.chars; csOp.lines -= attOp.lines;&#125; 123456789101112第3次迭代:1、初始:op1.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 5, lines: 0, attribs: &apos;&apos; &#125;(第2次循环compose算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 5, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;，minusAssem : &quot;-1&quot;说明:op1-,op2=,compose之后op2还有opcode,所以重新赋值next() 对应第3次迭代的具体代码: 1234// 如果 op1 是 - ，则我们需要的 opOut 使用 op1Op.copyOp(attOp, opOut);// 清空 op1 操作attOp.clearOpcode(); 123456789101112第4次迭代:1、初始:op1.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 5, lines: 0, attribs: &apos;&apos; &#125;(第3次循环compose算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;, minusAssem : &quot;-1&quot;, plusAssem : &quot;+2&quot;说明:op1+,op2=,compose之后op1没opcode,所以重新赋值next() 对应第4次迭代的具体代码:12345678910111213&#125; else &#123; // 如果 op2 操作的字符大于 op1 操作的字符 // keep and keep going 保持并且继续 opOut.opcode = attOp.opcode; opOut.chars = attOp.chars; opOut.lines = attOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); attOp.clearOpcode(); // 剩余部分 csOp.chars -= attOp.chars; csOp.lines -= attOp.lines;&#125; 123456789101112第5次迭代:1、初始:op1.5:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;(第4次循环compose算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;, minusAssem : &quot;-1&quot;, plusAssem : &quot;+2+3&quot;说明:op1+,op2=,compose之后op1,op2都没opcode,所以重新赋值next(),但此时op1已没有next(),故op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125; 对应第5次迭代的具体代码:12345678910111213141516if (csOp.chars &lt;= attOp.chars) &#123; // keep or keep part 保持或者保持一部分(保持 op1 的操作和全部的操作字符串和换行 或者 保持 op1 的操作和一部分的操作字符串和换行) // 可以理解为：op1增加或者保持了n个字符，op2保持了m个字符(m&lt;=n) opOut.opcode = attOp.opcode; opOut.chars = csOp.chars; opOut.lines = csOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); csOp.clearOpcode(); // 剩余部分 attOp.chars -= csOp.chars; attOp.lines -= csOp.lines; if (attOp.chars == 0) &#123; attOp.clearOpcode(); &#125;&#125; 123456789101112第6次迭代:1、初始:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;(next()没有下一个时，是返回一个新的op)op2.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;, minusAssem : &quot;-1-1&quot;, plusAssem : &quot;+2+3&quot;说明:op2-,compose之后op1，op2没opcode,所以重新赋值next() 对应第6次迭代的具体代码:1234// 如果 op1 没有操作，则使用 op2Op.copyOp(csOp, opOut);// 清空 op2 操作csOp.clearOpcode(); 123456789101112第7次迭代:1、初始:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;(next()没有下一个时，是返回一个新的op)op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;, minusAssem : &quot;-1-1&quot;, plusAssem : &quot;+2+3+2&quot;说明:op2+，compose之后op1,op1,op2都没有opcode,也没有next()了,停止 对应第7次迭代的具体代码:1234// 如果 op1 没有操作，则使用 op2Op.copyOp(csOp, opOut);// 清空 op2 操作csOp.clearOpcode(); 算法结果12345678910111213141516171819202122231 Changeset = require(\"./src/static/js/Changeset\");2 var csA = \"Z:z&gt;4|2=m=b-1+2+3$abcde\";3 var csB = \"Z:13&gt;1|2=m=g-1+2$fg\";45 var doc1 = \"Hello World\\n\\n Hello World Hello Wor\";6 var doc2 = \"Hello World\\n\\n Hello World Hello Wabcder\";78 var appliedA = Changeset.applyToText(csA,doc1);9 console.log('apply csA:', appliedA);10 console.log('');11 console.log('appliedA==doc2:', appliedA==doc2);1213 console.log('');14 var appliedB = Changeset.applyToText(csB,doc2);1516 console.log('apply csB:', appliedB);17 console.log('');1819 var cs = Changeset.compose(csA,csB,false,null);20 var applied = Changeset.applyToText(cs,doc1);2122 console.log('final doc:', applied);23 1234567891011121314apply csA: Hello World Hello World Hello WabcderappliedA==doc2: trueapply csB: Hello World Hello World Hello Wabcdefgfinal doc: Hello World Hello World Hello Wabcdefg 123456789&gt; var cs1 = \"Z:z&gt;4|2=m=b-1+2+3$abcde\";&gt; var cs2 = \"Z:13&gt;1|2=m=g-1+2$fg\";&gt; Changeset.compose(cs1,cs2,false,null);'Z:z&gt;5|2=m=b-2+7$abcdefg'最终的CS:'Z:z&gt;5|2=m=b-2+7$abcdefg' 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/compose算法过程验算.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"成都","slug":"成都","date":"2018-05-21T08:38:55.000Z","updated":"2019-10-23T08:58:28.437Z","comments":true,"path":"成都.html","link":"","permalink":"http://xiaoqinghua.site/成都.html","excerpt":"","text":"在这里生根，在这里发芽，在这里埋葬 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成都地铁规划成都地铁规划 123456789\"city\":&#123; \"name\":\"chengdu\", \"abbreviation01\":\"cdc\", \"abbreviation02\":\"splendid officer city\", \"abbreviation03\":\"hibiscus city\", \"slogan_en\":\"living and enjoy in your home forever\", \"slogan_ch\":\"一座来了就不想离开的城市\" \"xiaoqinghua\":\"I love you , I love my city\"&#125; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/成都.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"City","slug":"City","permalink":"http://xiaoqinghua.site/tags/City/"}]},{"title":"Hackpad 技术分析","slug":"hackpad技术分析","date":"2018-05-20T05:58:53.000Z","updated":"2018-08-25T06:49:03.444Z","comments":true,"path":"hackpad技术分析.html","link":"","permalink":"http://xiaoqinghua.site/hackpad技术分析.html","excerpt":"","text":"hackpad 技术分析前言 1、hackpad 是基于 etherpad 二次开发，增加了很多产品化的功能，如\b账户系统，文档权限等。\b腾讯文档也是基于 hackpad 开发，\b腾讯文档的表格则是基于开源项目 hansontable 作为前端载体，在协作算法上对 easysync 进行了略微的修改。 2、hackpad 同样是基于 client + server模式开发，通讯协议大体相同，做了小幅修改，OT算法\b都是使用easysync，\b客户端服务端流程可以参考 etherpad 技术分析。 3、hackpad 项目是由 scala + java + js 的组合，hackpad使用了Jetty在scala上搭建的Websocket Server (在infrastructure目录下的main.scala中完成) 实现通讯，同时也使用了etherpad使用的开源 SocketIO 库，来完成基于双向通信的实时协同。 4、以下技术调研\b是在etherpad的调研基础下对hackpad表格，图片，协议等方面的梳理。 1、行 &amp; 表格换行操作hackpad光标每一次换行，客户端都会发送 CLIENT_MESSAGE ，其中负载&quot;type&quot;:&quot;caret&quot;，changeBy\b代表作者，如图： 上述协议相当于定位的作用，结合左侧的用户实时行定位\b功能如下图： 综上：标题 &quot;caret&quot;:0, 正文的第一行 &quot;caret&quot;:1 ,正文的第n行 &quot;caret&quot;:n 例: 在标题行插入一个 a，客户端会同时发送两条协议数据 1、CLIENT_MESSAGE \b负载 caret 位置信息 1234567891011&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"CLIENT_MESSAGE\", \"payload\": &#123; \"type\": \"caret\", \"caret\": 0, \"changedBy\": \"p.1\" &#125; &#125;&#125; 2、USER_CHANGES，数据结构较于 etherpad 没有变化 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 59, \"changeset\": \"Z:1&gt;1*0+1$a\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"author\", \"p.1\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 插入表格 在正文第一行插入一个表格(table)，客户端会同时发送三条协议数据 1、CLIENT_MESSAGE \b负载 caret 位置信息 插入之前，光标位置 1234567891011&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"CLIENT_MESSAGE\", \"payload\": &#123; \"type\": \"caret\", \"caret\": 1, \"changedBy\": \"p.1\" &#125; &#125;&#125; 插入之后，光标位置 1234567891011&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"CLIENT_MESSAGE\", \"payload\": &#123; \"type\": \"caret\", \"caret\": 3, \"changedBy\": \"p.1\" &#125; &#125;&#125; 2、USER_CHANGES 123456789101112131415161718192021&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 61, \"changeset\": \"Z:3&gt;3|1=2*0|1+1*0*1+1*0|1+1$\\n*\\n\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"author\", \"p.1\" ], \"1\": [ \"table\", \"123\" ] &#125;, \"nextNum\": 2 &#125; &#125;&#125; 根据changeset规范解析上述通信协议数据 123pack the changeset `Z:3&gt;3|1=2*0|1+1*0*1+1*0|1+1$\\n*\\n`&#123; oldLen: 3,newLen: 6,ops: '|1=2*0|1+1*0*1+1*0|1+1',charBank: '\\n*\\n' &#125; operator:12345678910&#123; opcode: '=', chars: 2, lines: 1, attribs: '' &#125;插入一个空行 \\n&#123; opcode: '+', chars: 1, lines: 1, attribs: '*0' &#125;插入一个表格 * (*代表表格，图片，嵌入的文件)(img/embed/table)&#123; opcode: '+', chars: 1, lines: 0, attribs: '*0*1' &#125;插入一个空行 \\n&#123; opcode: '+', chars: 1, lines: 1, attribs: '*0' &#125; 插入表格代码： 123456789101112131415161718var rep = ace.getRep();// don't insert tables in title linevar selStart = [rep.selStart[0], rep.selStart[1]];var selEnd = [rep.selEnd[0], rep.selEnd[1]];if (selStart[0] == 0) &#123; selStart = [1, 0]; selEnd = [1, 0]; // make sure the table is on its own line, // (and not the title line) ace.replaceRange(selStart, selStart, '\\n\\n', []);&#125; else &#123; // make sure the table is on its own line, // (and not the title line) ace.replaceRange(selStart, selEnd, '\\n\\n', []); selStart = [selStart[0] + 1, 0];&#125;ace.replaceRange(selStart, selStart, '*', [['table', '123']]);padeditor.ace.focus(); 12345678910111213141516/** * Replace a range of text with new text. * @param &#123;Array.&lt;number&gt;&#125; start The line/column of the range start. * @param &#123;Array.&lt;number&gt;&#125; end The line/column of the range end. * @param &#123;string&#125; text The new text. * @param &#123;Array&#125; attribs The new attributes for this text. * @param &#123;boolean&#125; insertsAfterSelection The new text goes after the range. */self.replaceRange = function(start, end, text, attribs, insertsAfterSelection) &#123; self.inCallStackIfNecessary('replaceRange', function() &#123; self.fastIncorp(); self.performDocumentReplaceRange(start, end, text, attribs, insertsAfterSelection); &#125;);&#125; 编辑表格数据 在表格的第一个格子坐标(0:0)位置插入一个字符b 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 67, \"changeset\": \"Z:7&gt;0|2=3*0=1$\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"0:0\", \"b\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 在表格的第一个格子坐标(0:0)位置追加一个字符c 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 68, \"changeset\": \"Z:7&gt;0|2=3*0=1$\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"0:0\", \"bc\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 在表格的第一个格子坐标(0:1)位置插入一个字符d 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 69, \"changeset\": \"Z:7&gt;0|2=3*0=1$\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"0:1\", \"d\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 在表格的第一个格子坐标(1:0)位置插入一个字符e 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 70, \"changeset\": \"Z:7&gt;0|2=3*0=1$\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"1:0\", \"e\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 综上： 插入一个表格，会直接在apool 增加一个[&#39;table&#39;, &#39;123&#39;]属性 表格有位置坐标 | (0,0) | (0,1) | | — | — | | (1,0) | (1,1) | | (2,0) | (2,1) | 替换每个坐标里的值，会在apool中新生成一个[&quot;1:0&quot;, &quot;abc&quot;] 往每个坐标里追加值，会在apool中替换已生成的坐标位置一样的新值[&quot;1:0&quot;, &quot;123&quot;] 表格里的字符是不能使用加粗，下划线，等\b附加属性的，这个功能还有待开发（\b如果基于hackpad现有的表格设计，使用apool中的属性，已经很难再设计出附加属性的添加，猜测腾讯文档应该是做了其他的优化） 上述这些\b增加，追加的方式编辑表格数据，通过对属性apool的操作，\b\b然后根据 Changeset.applyToText(cs,str)方法，从而不需要\b把表格那一个range的 text(文本数据)进行OT算法实现就可以实现文档中表格数据的协同编辑\b。 2、图片直接\b copy 图片 url123456789101112131415161718192021&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 8, \"changeset\": \"Z:s&gt;15|4=q*0*1+1*0|1+1*0+13$*\\nhttps://p.upyun.com/docs/cloud/demo.jpg\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"author\", \"p.1\" ], \"1\": [ \"img\", \"https://p.upyun.com/docs/cloud/demo.jpg\" ] &#125;, \"nextNum\": 2 &#125; &#125;&#125; 直接 copy 图片 url, 是直接在charbank:{*\\nurl}\b ,*表示图片，\\n表示换一行，url表示图片链接,和 etherpad 不同在于*表示图片。 和插入表格一样，都会在\bapool里新增属性&quot;1&quot;:[&quot;img&quot;,&quot;https://p.upyun.com/docs/cloud/demo.jpg&quot;] 上传本地图片 hackpad 图片存储使用 AWS 的 S3 存储服务 12345678910111213141516171819202122232425&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 37, \"changeset\": \"Z:f&gt;1|4=e*0*1*2+1$*\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"attachmentPlaceholder\", \"attachment-1531119782428\" ], \"1\": [ \"author\", \"p.1\" ], \"2\": [ \"img\", \"/static/img/pixel.gif\" ] &#125;, \"nextNum\": 3 &#125; &#125;&#125; 1234567891011awsUser = __aws_key_id__awsPass = __aws_secret__s3Bucket = __aws_attachments_bucket__s3Region = us-east-1相关代码:editor.performDocumentReplaceRange(start, end, '*', [ ['img', '/static/img/pixel.gif'], ['attachmentPlaceholder', attachmentId]]); 上传图片的方法： 构造FormData数据，使用ajax上传到S3\b 12345678910111213141516171819202122232425262728$.ajax(&#123; xhr: function() &#123; var xhr = new window.XMLHttpRequest(); xhr.upload.addEventListener(\"progress\", function(evt) &#123; if (evt.lengthComputable) &#123; var progress = evt.loaded / evt.total; editor.callWithAce(function (ace) &#123; setAttachmentUrlProgress(attachmentId, progress); &#125;); &#125; &#125;, false); return xhr; &#125;, url: s3host, data: form, processData: false, contentType: false, type: \"POST\", success: function() &#123; setTimeout(function() &#123; editor.callWithAce(function (ace) &#123; setAttachmentUrl(attachmentId, s3host + path, path); &#125;); observer.trigger('track', ['file-attach', null, null, &#123; success: true, padId: clientVars.padId, userId: clientVars.userId, type: file.type, path: path, size: file.size, uploadSize: shrunk.size &#125;]); &#125;, 500&#125;) 3、Ace编辑器 &amp; Changeset变更集 &amp; AttribPool属性池hackpad 的项目结构： hackpad bin 构建项目和启动项目的命令 contrib cron 包含一个清理的定时任务 glue 包含一些 python 脚本 runit 包含设置容器的一些脚本 scripts 设置数据库和服务的一些脚本 testing 测试\b目录 etherpad bin 在本地启动项目的命令 data 本地的数据，包含日志和 solr 全文搜索服务器 etc 一些\b配置文件 solr solr 全文搜索服务器 src etherpad etherpad\b 产品功能代码 locals \b语言设置 static etherpad 静态代码\b包含 ace 编辑器 easy_sync 算法等\b themes \b主题文件 .ejs 模板 appjet-eth-dev.jar 编译 infrastructure 目录下的.scala 文件生成的项目 infrastructure Scala \b目录，目前不是太懂 lib 包含一个数据库连接件 1、ace 编辑器 相对于\betherpad，ace编辑器\b功能没有太大的变化，整个ace目录结构分离，同时增加了ace_table表格，ace_media\b\b，ace_caret等抽象模块。 2、Changeset 变更集 相对于\betherpad，changeset\b功能没有变化，即便是加了table，image还是和etherpad的相同。 hackpad的changeset结构上做了分离。抽离成easysync1.js，easysync2.js。 easysync1.js包含changeset自身的一些方法，包括Changeset.decodeFromString，Changeset.numberArrayToString等。 easysync2.js包含changeset的OT功能上的一些方法，包括Changeset.follow，Changeset.compose等。 3、AttribPool 属性池 相对于\betherpad，AttribPool\b则没有改变。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/hackpad技术分析.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"云文档的难点","slug":"云文档的难点","date":"2018-04-05T06:50:30.000Z","updated":"2018-08-05T06:57:09.278Z","comments":true,"path":"云文档的难点.html","link":"","permalink":"http://xiaoqinghua.site/云文档的难点.html","excerpt":"","text":"1. 多人协作，实时同步在云文档上同时编写的客户可能会非常多，如果一个成员更新了别的成员无法及时看到，或者几个成员无法同时更新，那就不可能实现团队协作，甚至会出现业务错误风险。在石墨文档上，用户输入的每一个文字都需要在毫秒级尺度内实时计算，并传给同一个文档的其他协作者。为此，石墨文档引用了 NATS 数据管道，对进入服务器的所有流量进行削峰填谷的处理。在数据高峰期引入服务器的数据进行延时处理，等待空闲时间再计算，从而使服务器可以平稳运行。同时基于此，还实现了根据数据流量对后端服务器自动扩容，当数据量突然增大时，自动增加服务器，提高整个系统负载能力。 2.多客户端实时同步 互联网时代，各种终端层出不穷，每个人日常中至少会使用两种设备，手机和电脑，如果一个人同时在手机和电脑上编辑同一份笔记，出现冲突时，很多笔记类应用会为每一个冲突创建独立的副本，需要用户手工合并，使得用户使用笔记便利性大大下降； 为了支持实时协作，石墨文档技术团队对算法进行了改进，这个算法可以解决一段文字，多个客户端同时修改引起的冲突合并问题。另外到目前为止，已经适配了 50 种不同的机器和浏览器。 3.离线编辑，避免冲突离线编辑，用户同步过来的数据往往是他几个小时编写的成果，此时，这个版本或已经与服务器的版本相差甚远了，按着此前方法，如何解决文档冲突是个问题。 对此，石墨文档尽可能多地记录用户编辑过程中的每一步操作，然后利用各用户端的历史操作信息挨个重放，从而还原用户编辑的本意。比如，对于“今天天气很好”，第一个人可能会删除中间的“天气”两字，变成“今天很好”；而另外一个人可能会加上一个“真”字，变成“今天天气真的很好”，按着石墨文档的基于还原用户意图的算法，最后合并的结果则是“今天真的很好”，既满足删除“天气”，又满足增加“真”的双方意图。当然，这种合并方法也并非百分百完美，但李子骅表示这是最适合目前编写体验的。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Cloud-Office","slug":"Code/Cloud-Office","permalink":"http://xiaoqinghua.site/categories/Code/Cloud-Office/"}],"tags":[{"name":"Cloud-Office","slug":"Cloud-Office","permalink":"http://xiaoqinghua.site/tags/Cloud-Office/"}]},{"title":"Hibernate总结","slug":"Hibernate总结","date":"2017-12-10T05:22:36.000Z","updated":"2018-09-08T05:19:05.187Z","comments":true,"path":"Hibernate总结.html","link":"","permalink":"http://xiaoqinghua.site/Hibernate总结.html","excerpt":"","text":"什么是Hibernate框架Hibernate是一种ORM框架，全称为 Object Relative DateBase-Mapping，在Java对象与关系数据库之间建立某种映射，以实现直接存取Java对象 为什么要使用Hibernate既然Hibernate是关于Java对象和关系数据库之间的联系的话，也就是我们MVC中的数据持久层-&gt;在编写程序中的DAO层… 首先，我们来回顾一下我们在DAO层写程序的历程吧： 在DAO层操作XML，将数据封装到XML文件上，读写XML文件数据实现CRUD 在DAO层使用原生JDBC连接数据库，实现CRUD 嫌弃JDBC的Connection\\Statement\\ResultSet等对象太繁琐，使用对原生JDBC的封装组件–&gt;DbUtils组件 我们来看看使用DbUtils之后，程序的代码是怎么样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CategoryDAOImpl implements zhongfucheng.dao.CategoryDao &#123; @Override public void addCategory(Category category) &#123; QueryRunner queryRunner = new QueryRunner(Utils2DB.getDataSource()); String sql = \"INSERT INTO category (id, name, description) VALUES(?,?,?)\"; try &#123; queryRunner.update(sql, new Object[]&#123;category.getId(), category.getName(), category.getDescription()&#125;); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public Category findCategory(String id) &#123; QueryRunner queryRunner = new QueryRunner(Utils2DB.getDataSource()); String sql = \"SELECT * FROM category WHERE id=?\"; try &#123; Category category = (Category) queryRunner.query(sql, id, new BeanHandler(Category.class)); return category; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; @Override public List&lt;Category&gt; getAllCategory() &#123; QueryRunner queryRunner = new QueryRunner(Utils2DB.getDataSource()); String sql = \"SELECT * FROM category\"; try &#123; List&lt;Category&gt; categories = (List&lt;Category&gt;) queryRunner.query(sql, new BeanListHandler(Category.class)); return categories; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 其实使用DbUtils时，DAO层中的代码编写是很有规律的。 当插入数据的时候，就将JavaBean对象拆分，拼装成SQL语句 当查询数据的时候，用SQL把数据库表中的列组合，拼装成JavaBean对象 也就是说：JavaBean对象和数据表中的列存在映射关系!如果程序能够自动生成SQL语句就好了….那么Hibernate就实现了这个功能！ 简单来说：我们使用Hibernate框架就不用我们写很多繁琐的SQL语句，从而简化我们的开发！ ORM概述在介绍Hibernate的时候，说了Hibernate是一种ORM的框架。那什么是ORM呢？ORM是一种思想 O代表的是Objcet R代表的是Relative M代表的是Mapping ORM-&gt;对象关系映射….ORM关注是对象与`数据库中的列的关系 Hibernate快速入门编写对象和对象映射编写一个User对象-&gt;User.java 123456789public class User &#123; private int id; private String username; private String password; private String cellphone; //各种setter和getter&#125; 编写对象映射-&gt;User.hbm.xml。一般它和JavaBean对象放在同一目录下 我们是不知道该XML是怎么写的，可以搜索一下Hibernate文件夹中后缀为.hbm.xml。看看它们是怎么写的。然后复制一份过来: 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- This mapping demonstrates content-based discrimination for the table-per-hierarchy mapping strategy, using a formula discriminator.--&gt;&lt;hibernate-mapping package=\"org.hibernate.test.array\"&gt; &lt;class name=\"A\" lazy=\"true\" table=\"aaa\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;array name=\"bs\" cascade=\"all\" fetch=\"join\"&gt; &lt;key column=\"a_id\"/&gt; &lt;list-index column=\"idx\"/&gt; &lt;one-to-many class=\"B\"/&gt; &lt;/array&gt; &lt;/class&gt; &lt;class name=\"B\" lazy=\"true\" table=\"bbb\"&gt; &lt;id name=\"id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在上面的模板上修改～下面会具体讲解这个配置文件! 12345678910111213141516171819&lt;!--在domain包下--&gt;&lt;hibernate-mapping package=\"xiaoqinghua.domain\"&gt; &lt;!--类名为User，表名也为User--&gt; &lt;class name=\"User\" table=\"user\"&gt; &lt;!--主键映射，属性名为id，列名也为id--&gt; &lt;id name=\"id\" column=\"id\"&gt; &lt;!--根据底层数据库主键自动增长--&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!--非主键映射，属性和列名一一对应--&gt; &lt;property name=\"username\" column=\"username\"/&gt; &lt;property name=\"cellphone\" column=\"cellphone\"/&gt; &lt;property name=\"password\" column=\"password\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 主配置文件hibernate.cfg.xml 如果使用Intellij Idea生成的Hibernate可以指定生成出主配置文件hibernate.cfg.xml，它是要放在src目录下的 如果不是自动生成的，我们可以在Hibernate的hibernate-distribution-3.6.0.Final\\project\\etc这个目录下可以找到 它长得这个样子： 1234567891011121314&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=\"connection.url.\"/&gt; &lt;property name=\"connection.driver_class\"/&gt; &lt;property name=\"connection.username\"/&gt; &lt;property name=\"connection.password\"/&gt; &lt;!-- DB schema will be updated if needed --&gt; &lt;!-- &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; --&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 通过上面的模板进行修改 12345678910111213141516171819202122232425262728&lt;hibernate-configuration&gt; &lt;!-- 通常，一个session-factory节点代表一个数据库 --&gt; &lt;session-factory&gt; &lt;!-- 1. 数据库连接配置 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///xiaoqinghua&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;!-- 数据库方法配置， hibernate在运行的时候，会根据不同的方言生成符合当前数据库语法的sql --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!-- 2. 其他相关配置 --&gt; &lt;!-- 2.1 显示hibernate在运行时候执行的sql语句 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 2.2 格式化sql --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 2.3 自动建表 --&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;create&lt;/property&gt; &lt;!--3. 加载所有映射--&gt; &lt;mapping resource=\"xiaoqinghua/domain/User.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试12345678910111213141516171819202122232425262728293031323334353637public class App &#123; public static void main(String[] args) &#123; //创建对象 User user = new User(); user.setPassword(\"123\"); user.setCellphone(\"122222\"); user.setUsername(\"nihao\"); //获取加载配置管理类 Configuration configuration = new Configuration(); //不给参数就默认加载hibernate.cfg.xml文件， configuration.configure(); //创建Session工厂对象 SessionFactory factory = configuration.buildSessionFactory(); //得到Session对象 Session session = factory.openSession(); //使用Hibernate操作数据库，都要开启事务,得到事务对象 Transaction transaction = session.getTransaction(); //开启事务 transaction.begin(); //把对象添加到数据库中 session.save(user); //提交事务 transaction.commit(); //关闭Session session.close(); &#125;&#125; 值得注意的是：JavaBean的主键类型只能是int类型，因为在映射关系中配置是自动增长的，String类型是不能自动增长的。如果是你设置了String类型，又使用了自动增长，那么就会报出下面的错误！ 1Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table 'xiaoqinghua.user' does 执行完程序后，Hibernate就为我们创建对应的表，并把数据存进了数据库了 Configuration配置管理类：主要管理配置文件的一个类 它拥有一个子类AnnotationConfiguration，也就是说：我们可以使用注解来代替XML配置文件来配置相对应的信息 configure方法configure()方法用于加载配置文件 加载主配置文件的方法 如果指定参数，那么加载参数的路径配置文件 如果不指定参数，默认加载src/目录下的hibernate.cfg.xml buildSessionFactory方法buildSessionFactory()用于创建Session工厂 SessionFactorySessionFactory–&gt;Session的工厂，也可以说代表了hibernate.cfg.xml这个文件…hibernate.cfg.xml的就有&lt;session-factory&gt;这么一个节点 openSession方法 创建一个Session对象 getCurrentSession方法 创建Session对象或取出Session对象 SessionSession是Hibernate最重要的对象，Session维护了一个连接（Connection），只要使用Hibernate操作数据库，都需要用到Session对象 通常我们在DAO层中都会有以下的方法，Session也为我们提供了对应的方法来实现！ 1234567891011public interface IEmployeeDao &#123; void save(Employee emp); void update(Employee emp); Employee findById(Serializable id); List&lt;Employee&gt; getAll(); List&lt;Employee&gt; getAll(String employeeName); List&lt;Employee&gt; getAll(int index, int count); void delete(Serializable id);&#125; 更新操作我们在快速入门中使用到了save(Objcet o)方法，调用了这个方法就把对象保存在数据库之中了。Session对象还提供着其他的方法来进行对数据库的更新 session.save(obj); 保存一个对象 session.update(obj); 更新一个对象 session.saveOrUpdate(obj); 保存或者更新的方法 没有设置主键，执行保存； 有设置主键，执行更新操作; 如果设置主键不存在报错！ 我们来使用一下update()方法吧….既然是更新操作了，那么肯定需要设置主键的，不设置主键，数据库怎么知道你要更新什么。将id为1的记录修改成如下： 1234user.setId(1);user.setPassword(\"fhjdlashf\");user.setCellphone(\"100865\");user.setUsername(\"xiaoqinghua\"); 主键查询通过主键来查询数据库的记录，从而返回一个JavaBean对象 session.get(javaBean.class, int id); 传入对应的class和id就可以查询 session.load(javaBean.class, int id); 支持懒加载 User重写toString()来看一下效果： 1234User user1 = (User) session.get(User.class, 1);System.out.println(user1);User&#123;id=1，username='xiaoqinghua'，password='fhjdlashf'，cellphone='100865'&#125; HQL查询HQL:hibernate query language 即hibernate提供的面向对象的查询语言 查询的是对象以及对象的属性它查询的是对象以及属性，因此是区分大小写的！。 SQL：Struct query language 结构化查询语言 查询的是表以及列不区分大小写 HQL是面向对象的查询语言，可以用来查询全部的数据！ 123Query query = session.createQuery(\"FROM User\");List list = query.list();System.out.println(list); 也可以传递参数进去查询 1234567Query query = session.createQuery(\"FROM User WHERE id=?\");//这里的？号是从0开始的，并不像JDBC从1开始的！query.setParameter(0, user.getId());List list = query.list();System.out.println(list); QBC查询QBC查询: query by criteria 完全面向对象的查询 从上面的HQL查询，我们就可以发现：HQL查询是需要SQL的基础的，因为还是要写少部分的SQL代码….QBC查询就是完全的面向对象查询…但是呢，我们用得比较少 我们来看一下怎么使用吧： 123456789//创建关于user对象的criteria对象Criteria criteria = session.createCriteria(User.class);//添加条件criteria.add(Restrictions.eq(\"id\", 1));//查询全部数据List list = criteria.list();System.out.println(list); 本地SQL查询有的时候，如果SQL是非常复杂的，我们不能靠HQL查询来实现功能的话，我们就需要使用原生的SQL来进行复杂查询了！ 但是呢，它有一个缺陷：它是不能跨平台的…因此我们在主配置文件中已经配置了数据库的“方言“了。 我们来简单使用一下把： 123456//将所有的记录封装成User对象存进List集合中SQLQuery sqlQuery = session.createSQLQuery(\"SELECT * FROM user\").addEntity(User.class);List list = sqlQuery.list();System.out.println(list); beginTransaction方法开启事务，返回的是一个事务对象….Hibernate规定所有的数据库操作都必须在事务环境下进行，否则报错！ 主配置文件主配置文件主要配置： 数据库的信息 其他参数 加载映射文件 常用的配置信息都可以在hibernate-distribution-3.6.0.Final\\project\\etc\\hibernate.properties目录下可以找到 数据库信息123456789&lt;!-- 1. 数据库连接配置 --&gt;&lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;&lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hib_demo&lt;/property&gt;&lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;&lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt;&lt;!-- 数据库方法配置， hibernate在运行的时候，会根据不同的方言生成符合当前数据库语法的sql【大致可以理解成：不同的版本对应的SQL不同】 --&gt;&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; 其他参数信息常用的有那么三个： 1234567&lt;!-- 2. 其他相关配置 --&gt;&lt;!-- 2.1 显示hibernate在运行时候执行的sql语句 --&gt;&lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt;&lt;!-- 2.2 格式化sql --&gt;&lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt;&lt;!-- 2.3 自动建表 --&gt;&lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; 需要我们注意的是自动建表，其中它有几个参数： create-drop 每次在创建sessionFactory时候执行创建表。当调用sesisonFactory的close方法的时候，删除表！ create 每次都重新建表； 如果表已经存在就先删除再创建 update 如果表不存在就创建； 表存在就不创建； validate (生成环境时候) 执行验证： 当映射文件的内容与数据库表结构不一样的时候就报错！ 加载映射文件值得注意的是：mapping的属性使用的是resource! 12&lt;!--3. 加载映射文件--&gt;&lt;mapping resource=\"xiaoqinghua/domain/User.hbm.xml\"/&gt; 加载映射文件其实我们可以在程序中加载，不一定在配置文件中配置….一般地，我们在测试的时候一般使用程序的方式去加载映射文件 那么怎么在程序中加载映射文件呢？ 在Configuration对象中提供了addClass()的方法。 一般地我们的映射配置文件和JavaBean对象是放在同一个包下的。并且映射文件的命名是有规范的。因此Hibernate是可以通过提供的JavaBean对象从而找到相对应的映射文件！ 12345//获取加载配置管理类Configuration configuration = new Configuration();//加载User的映射文件！configuration.configure().addClass(User.class); 映射配置文件映射文件: 映射一个实体类对象； 描述一个对象最终实现可以直接保存对象数据到数据库中 通常地，我们都是一个JavaBean对象对应一个映射配置文件，并且配置文件和JavaBean对象是放在同一个目录下的 我们按照快速入门的映射配置文件一步一步来讲解： 12345678910111213141516171819&lt;!--在domain包下--&gt;&lt;hibernate-mapping package=\"xiaoqinghua.domain\"&gt; &lt;!--类名为User，表名也为User--&gt; &lt;class name=\"User\" table=\"user\"&gt; &lt;!--主键映射，属性名为id，列名也为id--&gt; &lt;id name=\"id\" column=\"id\"&gt; &lt;!--根据底层数据库主键自动增长--&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;!--非主键映射，属性和列名一一对应--&gt; &lt;property name=\"username\" column=\"username\"/&gt; &lt;property name=\"cellphone\" column=\"cellphone\"/&gt; &lt;property name=\"password\" column=\"password\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; hibernate-mapping节点 常用的属性： package 要映射的对象所在的包(可选,如果不指定,此文件所有的类都要指定全路径) auto-import 默认为true， 在写hql的时候自动导入包名 如果指定为false, 再写hql的时候必须要写上类的全名； class节点 class 映射某一个对象的(一般情况，一个对象写一个映射文件，即一个class节点) 常用的属性： name 指定要映射的对象的类型 table 指定对象对应的表 如果没有指定，默认与对象名称一样 property节点 property是普通属性的映射，即JavaBean普通的成员变量属性就使用property来描述！ 常用的属性： name 指定对象的属性名称 column 指定对象属性对应的表的字段名称 如果不写默认与对象属性一致。 length 指定字符的长度, 默认为255 type 指定映射表的字段的类型，如果不指定会匹配属性的类型 java类型： 必须写全名【例：java.lang.String】 hibernate类型： 直接写类型，都是小写 值得注意的是：如果列名称为数据库关键字，需要用反引号或改列名。当然啦，我们一般不使用关键字来作为列名 id节点 id是主键映射…. name 指定对象的属性名 column 指定对象属性对应的表的字段名称 &lt;id&gt;节点下还有子节点&lt;generator class=&quot;&quot;/&gt; 主键的自动生成策略 identity 自增长(mysql,db2) sequence 自增长(序列)， oracle中自增长是以序列方法实现 native 自增长会根据底层数据库自增长的方式选择identity或sequence 如果是mysql数据库, 采用的自增长方式是identity 如果是oracle数据库， 使用sequence序列的方式实现自增长 increment 自增长(会有并发访问的问题，一般在服务器集群环境使用会存在问题。) 指定主键生成策略为手动指定主键的值 assigned 指定主键生成策略为UUID生成的值 uuid foreign(外键的方式， one-to-one讲) composite-id 主键一般分为两种： 单列主键 多列复合主键 单列主键就是上面那种，那么如果要使用多列复合主键就需要使用&lt;composite-id&gt;节点来配置了 现在我有这么下面的一个对象，我想使用username和password作为复合主键 将username和password抽取成一个类—-&gt;CompositeKey….必须实现Serializable接口 在User2中需要指定一个变量来维护这个主键对象","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Hibernate","slug":"Code/Hibernate","permalink":"http://xiaoqinghua.site/categories/Code/Hibernate/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://xiaoqinghua.site/tags/Hibernate/"}]},{"title":"MyBatis总结","slug":"MyBatis总结","date":"2017-12-10T05:22:36.000Z","updated":"2018-09-07T12:51:32.148Z","comments":true,"path":"MyBatis总结.html","link":"","permalink":"http://xiaoqinghua.site/MyBatis总结.html","excerpt":"","text":"MyBatis 简介MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。 持久层： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。 优点： 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价 缺点：慢（相对于内存而言） 为什么使用 MyBatis在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 第一个 MyBatis 程序来实际开发一个 MyBatis 程序，感受一下。 准备数据库 首先我们创建一个数据库【mybatis】，编码方式设置为 UTF-8，然后再创建一个名为【student】的表，插入几行数据： 1234567891011121314DROP DATABASE IF EXISTS mybatis;CREATE DATABASE mybatis DEFAULT CHARACTER SET utf8;use mybatis;CREATE TABLE student( id int(11) NOT NULL AUTO_INCREMENT, studentID int(11) NOT NULL UNIQUE, name varchar(255) NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO student VALUES(1,1,'小清华');INSERT INTO student VALUES(2,2,'小清华');INSERT INTO student VALUES(3,3,'小清华'); 创建实体类 在 Package【pojo】下新建实体类【Student】，用于映射表 student： 12345678910package pojo;public class Student &#123; int id; int studentID; String name; /* getter and setter */&#125; 配置文件 mybatis-config.xml 在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等，我们在后面说明： 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"pojo\"/&gt; &lt;/typeAliases&gt; &lt;!-- 数据库环境 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"pojo/Student.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 配置文件 Student.xml 在 Package【pojo】下新建一个【Student.xml】文件： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pojo\"&gt; &lt;select id=\"listStudent\" resultType=\"Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 由于上面配置了 &lt;typeAliases&gt; 别名，所以在这里的 resultType 可以直接写 Student，而不用写类的全限定名 pojo.Student namespace 属性其实就是对 SQL 进行分类管理，实现不同业务的 SQL 隔离 SQL 语句的增删改查对应的标签 编写测试类 在 Package【test】小创建测试类【TestMyBatis】： 1234567891011121314151617181920212223242526272829package test;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import pojo.Student;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestMyBatis &#123; public static void main(String[] args) throws IOException &#123; // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 最后通过 session 的 selectList() 方法调用 sql 语句 listStudent List&lt;Student&gt; listStudent = session.selectList(\"listStudent\"); for (Student student : listStudent) &#123; System.out.println(\"ID:\" + student.getId() + \",NAME:\" + student.getName()); &#125; &#125;&#125; 输出： 1234ID:1,NAME:小清华ID:2,NAME:小清华ID:3,NAME:小清华 基本原理 应用程序找 MyBatis 要数据 MyBatis 从数据库中找来数据 1.通过 mybatis-config.xml 定位哪个数据库 2.通过 Student.xml 执行对应的 sql 语句 3.基于 Student.xml 把返回的数据库封装在 Student 对象中 4.把多个 Student 对象装载一个 Student 集合中 返回一个 Student 集合 CRUD 操作我们来看看常规的一套增删改查应该怎么实现： 配置 Student.xml 首先，我们在 SQL 映射文件中新增语句，用来支撑 CRUD 的系列操作 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"pojo\"&gt; &lt;select id=\"listStudent\" resultType=\"Student\"&gt; select * from student &lt;/select&gt; &lt;insert id=\"addStudent\" parameterType=\"Student\"&gt; insert into student (id, studentID, name) values (#&#123;id&#125;,#&#123;studentID&#125;,#&#123;name&#125;) &lt;/insert&gt; &lt;delete id=\"deleteStudent\" parameterType=\"Student\"&gt; delete from student where id = #&#123;id&#125; &lt;/delete&gt; &lt;select id=\"getStudent\" parameterType=\"_int\" resultType=\"Student\"&gt; select * from student where id= #&#123;id&#125; &lt;/select&gt; &lt;update id=\"updateStudent\" parameterType=\"Student\"&gt; update student set name=#&#123;name&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; parameterType：要求输入参数的类型 resultType：输出的类型 实现增删改查1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package test;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import pojo.Student;import java.io.IOException;import java.io.InputStream;import java.util.List;public class TestMyBatis &#123; public static void main(String[] args) throws IOException &#123; // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 增加学生 Student student1 = new Student(); student1.setId(4); student1.setStudentID(4); student1.setName(\"新增加的学生\"); session.insert(\"addStudent\", student1); // 删除学生 Student student2 = new Student(); student2.setId(1); session.delete(\"deleteStudent\", student2); // 获取学生 Student student3 = session.selectOne(\"getStudent\", 2); // 修改学生 student3.setName(\"修改的学生\"); session.update(\"updateStudent\", student3); // 最后通过 session 的 selectList() 方法调用 sql 语句 listStudent List&lt;Student&gt; listStudent = session.selectList(\"listStudent\"); for (Student student : listStudent) &#123; System.out.println(\"ID:\" + student.getId() + \",NAME:\" + student.getName()); &#125; // 提交修改 session.commit(); // 关闭 session session.close(); &#125;&#125; 通过 session.insert(“addStudent”, student1); 增加了一个 ID 和 studentID 都为 4，名字为“新增加的学生” 的学生 通过 session.delete(“deleteStudent”, student2); 删除了 ID = 1 的学生 通过 Student student3 = session.selectOne(“getStudent”, 2); 获取了 ID = 2的学生 通过 session.update(“updateStudent”, student3); 将 ID = 2 的学生的名字修改为 “修改的学生” 通过 session.commit() 来提交事务，也可以简单理解为更新到数据库 模糊查询如果要对数据库中的 student 表进行模糊查询，需要通过匹配名字中的某个字来查询该用户。 我们首先在 Student.xml 配置文件中配置 SQL 映射： 123&lt;select id=\"findStudentByName\" parameterMap=\"java.lang.String\" resultType=\"Student\"&gt; SELECT * FROM student WHERE name LIKE '%$&#123;value&#125;%' &lt;/select&gt; select 标签对中 SQL 语句的 “${}” 符号，表示拼接 SQL 串，将接受的参数内容不加任何修饰地拼接在 SQL 中，在 “${}” 中只能使用 value 来代表其中的参数 因为是模糊查询，所以得到的查询结果可能不止一个，所以我们使用 SqlSession 的 selectList() 方法，写一个测试方法： 12345678910111213141516@Testpublic void test() throws IOException &#123; // 根据 mybatis-config.xml 配置的信息得到 sqlSessionFactory String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 然后根据 sqlSessionFactory 得到 session SqlSession session = sqlSessionFactory.openSession(); // 模糊查询 List&lt;Student&gt; students = session.selectList(\"findStudentByName\", \"小\"); for (Student student : students) &#123; System.out.println(\"ID:\" + student.getId() + \",NAME:\" + student.getName()); &#125;&#125; 总结： 关于 parameterType： 就是用来在 SQL 映射文件中指定输入参数类型的，可以指定为基本数据类型（如 int、float 等）、包装数据类型（如 String、Interger 等）以及用户自己编写的 JavaBean 封装类 关于 resultType： 在加载 SQL 配置，并绑定指定输入参数和运行 SQL 之后，会得到数据库返回的响应结果，此时使用 resultType 就是用来指定数据库返回的信息对应的 Java 的数据类型。 关于 “#{}” ： 在传统的 JDBC 的编程中，占位符用 “?” 来表示，然后再加载 SQL 之前按照 “?” 的位置设置参数。而 “#{}” 在 MyBatis 中也代表一种占位符，该符号接受输入参数，在大括号中编写参数名称来接受对应参数。当 “#{}” 接受简单类型时可以用 value 或者其他任意名称来获取。 关于 “${}” ： 在 SQL 配置中，有时候需要拼接 SQL 语句（例如模糊查询时），用 “#{}” 是无法达到目的的。在 MyBatis 中，“${}” 代表一个 “拼接符号” ，可以在原有 SQL 语句上拼接新的符合 SQL 语法的语句。使用 “${}” 拼接符号拼接 SQL ，会引起 SQL 注入，所以一般不建议使用 “${}”。 MyBatis 使用场景： 通过上面的入门程序，不难看出在进行 MyBatis 开发时，我们的大部分精力都放在了 SQL 映射文件上。 MyBatis 的特点就是以 SQL 语句为核心的不完全的 ORM（关系型映射）框架。与 Hibernate 相比，Hibernate 的学习成本比较高，而 SQL 语句并不需要开发人员完成，只需要调用相关 API 即可。这对于开发效率是一个优势，但是缺点是没办法对 SQL 语句进行优化和修改。而 MyBatis 虽然需要开发人员自己配置 SQL 语句，MyBatis 来实现映射关系，但是这样的项目可以适应经常变化的项目需求。所以使用 MyBatis 的场景是：对 SQL 优化要求比较高，或是项目需求或业务经常变动。 MyBatis 缓存结构在 Web 系统中，最重要的操作就是查询数据库中的数据。但是有些时候查询数据的频率非常高，这是很耗费数据库资源的，往往会导致数据库查询效率极低，影响客户的操作体验。于是我们可以将一些变动不大且访问频率高的数据，放置在一个缓存容器中，用户下一次查询时就从缓存容器中获取结果。 MyBatis 拥有自己的缓存结构，可以用来缓解数据库压力，加快查询速度。 Mybatis 一级缓存是一个SqlSession级别，sqlsession只能访问自己的一级缓存的数据 二级缓存是跨sqlSession，是mapper级别的缓存，对于mapper级别的缓存不同的sqlsession是可以共享的。 一级查询缓存一级缓存存在于每一个 SqlSession 类的实例对象中，当第一次查询某一个数据时，SqlSession 类的实例对象会将该数据存入一级缓存区域，在没有收到改变该数据的请求之前，用户再次查询该数据，都会从缓存中获取该数据，而不是再次连接数据库进行查询。 MyBatis 的一级缓存原理： 第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一个 map key：hashcode + sql + sql输入参数 + 输出参数（sql的唯一标识） value：用户信息 同一个 sqlsession 再次发出相同的 sql，就从缓存中取不走数据库。如果两次中间出现 commit 操作（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。 MyBatis 一级缓存值得注意的地方： MyBatis 默认就是支持一级缓存的，并不需要我们配置. MyBatis 和 spring 整合后进行 mapper 代理开发，不支持一级缓存，mybatis 和 spring 整合，spring 按照 mapper 的模板去生成 mapper 代理对象，模板中在最后统一关闭 sqlsession。 二级查询缓存问题： 有些时候，在 Web 工程中会将执行查询操作的方法封装在某个 Service 方法中，当查询完一次后，Service 方法结束，此时 SqlSession 类的实例对象就会关闭，一级缓存就会被清空。 二级缓存原理： 二级缓存的范围是 mapper 级别（mapper即同一个命名空间），mapper 以命名空间为单位创建缓存数据结构，结构是 map。 要开启二级缓存，需要进行两步操作 在 MyBatis 的全局配置文件 mybatis-config.xml 中配置 setting属性，设置名为 “cacheEnable” 的属性值为 “true” 即可： 1234&lt;settings&gt; &lt;!-- 开启二级缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 注意： settings 配置的位置一定是在 properties 后面，typeAliases前面！ 然后由于二级缓存是 Mapper 级别的，还要在需要开启二级缓存的具体 mapper.xml 文件中开启二级缓存，只需要在相应的 mapper.xml 中添加一个 cache 标签即可： 12&lt;!-- 开启本 Mapper 的 namespace 下的二级缓存 --&gt;&lt;cache /&gt; 开启二级缓存之后，我们需要为查询结果映射的 POJO 类实现 java.io.serializable 接口，二级缓存可以将内存的数据写到磁盘，存在对象的序列化和反序列化，所以要实现java.io.serializable接口。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"MyBatis","slug":"Code/MyBatis","permalink":"http://xiaoqinghua.site/categories/Code/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://xiaoqinghua.site/tags/MyBatis/"}]},{"title":"Spring MVC总结","slug":"Spring-MVC总结","date":"2017-12-09T05:22:36.000Z","updated":"2018-09-07T10:58:51.813Z","comments":true,"path":"Spring-MVC总结.html","link":"","permalink":"http://xiaoqinghua.site/Spring-MVC总结.html","excerpt":"","text":"MVC 设计概述在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1： 弊端： JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起 要求开发者不仅要掌握 Java ，还要有高超的前端水平 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试 代码难以复用 正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）就像下图这样： 首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。 Spring MVC 的架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案： 传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。 特点： 结构松散，几乎可以在 Spring MVC 中使用各类视图 松耦合，各个模块分离 与 Spring 无缝集成 Hello Soring MVC 在 IDEA 中新建一个 Spring MVC 项目 修改 web.xml 把&lt;url-pattern&gt;元素的值改为 / ，表示要拦截所有的请求，并交由Spring MVC的后台控制器来处理，改完之后： 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编辑 dispatcher-servlet.xml 这个文件名的开头 dispatcher 与上面 web.xml 中的 &lt;servlet-name&gt; 元素配置的 dispatcher 对应，这是 Spring MVC 的映射配置文件（xxx-servlet.xml），我们编辑如下： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"simpleUrlHandlerMapping\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt; &lt;prop key=\"/hello\"&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"helloController\" class=\"controller.HelloController\"&gt;&lt;/bean&gt;&lt;/beans&gt; 编写 HelloController 在 Packagecontroller下创建 HelloController类，并实现 org.springframework.web.servlet.mvc.Controller 接口： 1234567891011package controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;public class HelloController implements Controller&#123; @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; return null; &#125;&#125; 出现了问题： javax.servlet 包找不到 解决： 将本地 Tomcat 服务器的目录下lib文件夹下的 servlet-api.jar 包拷贝到工程lib文件夹下，添加依赖 Spring MVC 通过 ModelAndView 对象把模型和视图结合在一起 12ModelAndView mav = new ModelAndView(\"index.jsp\");mav.addObject(\"message\", \"Hello Spring MVC\"); 这里表示视图的是index.jsp 模型数据的是 message，内容是 “Hello Spring MVC” 12345678910111213package controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;public class HelloController implements Controller &#123; public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mav = new ModelAndView(\"index.jsp\"); mav.addObject(\"message\", \"Hello Spring MVC\"); return mav; &#125;&#125; 准备 index.jsp 将 index.jsp 的内容修改为： 1234&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" isELIgnored=\"false\"%&gt; &lt;h1&gt;$&#123;message&#125;&lt;/h1&gt; 内容很简单，用El表达式显示 message 的内容。 部署到 Tomcat 及相关环境 重启服务，浏览器输入地址：localhost/hello 跟踪 Spring MVC 的请求每当用户在 Web 浏览器中点击链接或者提交表单的时候，请求就开始工作了，像是邮递员一样，从离开浏览器开始到获取响应返回，它会经历很多站点，在每一个站点都会留下一些信息同时也会带上其他信息，下图为 Spring MVC 的请求流程： DispatcherServlet 从请求离开浏览器以后，第一站到达的就是 DispatcherServlet，看名字这是一个 Servlet，通过 J2EE 的学习，我们知道 Servlet 可以拦截并处理 HTTP 请求，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。 12345678910&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;!-- 拦截所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; DispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。 处理器映射（HandlerMapping） 问题：典型的应用程序中可能会有多个控制器，这些请求到底应该发给哪一个控制器呢？ 所以 DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会根据请求所携带的 URL 信息来进行决策，例如上面的例子中，我们通过配置 simpleUrlHandlerMapping 来将 /hello 地址交给 helloController 处理： 12345678910&lt;bean id=\"simpleUrlHandlerMapping\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt; &lt;prop key=\"/hello\"&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"helloController\" class=\"controller.HelloController\"&gt;&lt;/bean&gt; 处理适配器 (HandlerAdapter) 在请求到达控制器之前，首先会经过一个适配器 HttpMessageConverter 请求经过控制器之后，会经过一系列的数据验证，数据处理等，最后到达Handler控制器，DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息： 1234public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; // 处理逻辑 ....&#125; 返回 DispatcherServlet 当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为模型（Model）。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个视图（view），通常会是 JSP。 控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。 123456public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; // 处理逻辑 .... // 返回给 DispatcherServlet return mav;&#125; 视图解析器 这样一来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。 DispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP 视图 既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了。 它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。 1234&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" isELIgnored=\"false\"%&gt;&lt;h1&gt;$&#123;message&#125;&lt;/h1&gt; 使用注解配置 Spring MVC上面我们已经对 Spring MVC 有了一定的了解，并且通过 XML 配置的方式创建了第一个 Spring MVC 程序，我们来看看基于注解应该怎么完成上述程序的配置： 为 HelloController 添加注解 123456789101112131415package controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class HelloController&#123; @RequestMapping(\"/hello\") public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mav = new ModelAndView(\"index.jsp\"); mav.addObject(\"message\", \"Hello Spring MVC\"); return mav; &#125;&#125; 把实现的接口也给去掉 @Controller 注解： 很明显，这个注解是用来声明控制器的，但实际上这个注解对 Spring MVC 本身的影响并不大。（Spring 实战说它仅仅是辅助实现组件扫描，可以用 @Component 注解代替，但我自己尝试了一下并不行，因为上述例子没有配置 JSP 视图解析器我还自己配了一个仍没有成功...） @RequestMapping 注解： 很显然，这就表示路径 /hello 会映射到该方法上 取消之前的 XML 注释 在 dispatcher-servlet.xml 文件中，注释掉之前的配置，然后增加一句组件扫描： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--&lt;bean id=\"simpleUrlHandlerMapping\"--&gt; &lt;!--class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt;--&gt; &lt;!--&lt;property name=\"mappings\"&gt;--&gt; &lt;!--&lt;props&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash; /hello 路径的请求交给 id 为 helloController 的控制器处理&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;prop key=\"/hello\"&gt;helloController&lt;/prop&gt;--&gt; &lt;!--&lt;/props&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;bean id=\"helloController\" class=\"controller.HelloController\"&gt;&lt;/bean&gt;--&gt; &lt;!-- 扫描controller下的组件 --&gt; &lt;context:component-scan base-package=\"controller\"/&gt;&lt;/beans&gt; 重启服务器 当配置完成，重新启动服务器，输入 localhost/hello 地址仍然能看到效果 @RequestMapping 注解细节如果 @RequestMapping 作用在类上，那么就相当于是给该类所有配置的映射地址前加上了一个地址，例如： 12345678@Controller@RequestMapping(\"/xiaoqinghua\")public class HelloController &#123; @RequestMapping(\"/hello\") public ModelAndView handleRequest(....) throws Exception &#123; .... &#125;&#125; 则访问地址： localhost/wmyskxz/hello 配置视图解析器还记得我们 Spring MVC 的请求流程吗，视图解析器负责定位视图，它接受一个由 DispaterServlet 传递过来的逻辑视图名来匹配一个特定的视图。 需求： 有一些页面我们不希望用户用户直接访问到，例如有重要数据的页面，例如有模型数据支撑的页面。 造成的问题： 我们可以在web根目录下放置一个test.jsp模拟一个重要数据的页面，我们什么都不用做，重新启动服务器，网页中输入 localhost/test.jsp 就能够直接访问到了，这会造成数据泄露… 另外我们可以直接输入 localhost/index.jsp 试试，根据我们上面的程序，这会是一个空白的页面，因为并没有获取到 ${message} 参数就直接访问了，这会影响用户体验 解决方案我们将我们的 JSP 文件配置在WEB-INF文件夹中的page文件夹下，WEB-INF是 Java Web 中默认的安全目录，是不允许用户直接访问的（也就是你说你通过 localhost/WEB-INF/ 这样的方式是永远访问不到的） 但是我们需要将这告诉给视图解析器，我们在 dispatcher-servlet.xml 文件中做如下配置： 12345&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/page/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 这里配置了一个 Spring MVC 内置的一个视图解析器，该解析器是遵循着一种约定：会在视图名上添加前缀和后缀，进而确定一个 Web 应用中视图资源的物理路径的。让我们实际来看看效果： 修改 HelloContoller 123456@RequestMapping(\"/hello\") public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mav = new ModelAndView(\"index\"); mav.addObject(\"message\", \"Hello Spring MVC\"); return mav; &#125; 配置视图解析器： 按照上述的配置，完成： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--&lt;bean id=\"simpleUrlHandlerMapping\"--&gt; &lt;!--class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt;--&gt; &lt;!--&lt;property name=\"mappings\"&gt;--&gt; &lt;!--&lt;props&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash; /hello 路径的请求交给 id 为 helloController 的控制器处理&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;prop key=\"/hello\"&gt;helloController&lt;/prop&gt;--&gt; &lt;!--&lt;/props&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;bean id=\"helloController\" class=\"controller.HelloController\"&gt;&lt;/bean&gt;--&gt; &lt;!-- 扫描controller下的组件 --&gt; &lt;context:component-scan base-package=\"controller\"/&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/page/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 剪贴 index.jsp 文件 在WEB-INF文件夹下新建一个page文件夹，并将index.jsp文件剪贴到里面： 更新资源重启服务器 访问 localhost/hello 路径，看到正确效果 我们传入的逻辑视图名为 index ，再加上 “/WEB-INF/page/” 前缀和 “.jsp” 后缀，就能确定物理视图的路径了，这样我们以后就可以将所有的视图放入page文件夹下了！ 控制器接收请求数据使用控制器接收参数往往是 Spring MVC 开发业务逻辑的第一步，为探索 Spring MVC 的传参方式，为此我们先来创建一个简单的表单用于提交数据： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*\" isELIgnored=\"false\"%&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Spring MVC 传参方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/param\" role=\"form\"&gt; 用户名：&lt;input type=\"text\" name=\"userName\"&gt;&lt;br/&gt; 密码：&lt;input type=\"text\" name=\"password\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提 交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 使用 Servlet 原生 API 实现：我们很容易知道，表单会提交到 /param 这个目录，我们先来使用 Servlet 原生的 API 来获取到数据： 12345678910@RequestMapping(\"/param\")public ModelAndView getParam(HttpServletRequest request, HttpServletResponse response) &#123; String userName = request.getParameter(\"userName\"); String password = request.getParameter(\"password\"); System.out.println(userName); System.out.println(password); return null;&#125; 使用同名匹配规则我们可以把方法定义的形参名字设置成和前台传入参数名一样的方法，来获取到数据（同名匹配规则）： 1234567@RequestMapping(\"/param\")public ModelAndView getParam(String userName, String password) &#123; System.out.println(userName); System.out.println(password); return null;&#125; 问题： 这样又会和前台产生很强的耦合，这是我们不希望的 解决： 使用 @RequestParam(&quot;前台参数名&quot;) 来注入： @RequestParam 注解细节： 该注解有三个变量：value、required、defaultvalue value ：指定 name 属性的名称是什么，value 属性都可以默认不写 required ：是否必须要有该参数，可以设置为true或者false defaultvalue ：设置默认值 使用模型传参要求： 前台参数名字必须和模型中的字段名一样 让我们先来为我们的表单创建一个 User 模型： 123456789package pojo;public class User &#123; String userName; String password; /* getter and setter */&#125; 中文乱码问题注意： 跟 Servlet 中的一样，该方法只对 POST 方法有效（因为是直接处理的 request） 我们可以通过配置 Spring MVC 字符编码过滤器来完成，在 web.xml 中添加： 12345678910111213&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;!-- 设置编码格式 --&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 控制器回显数据通过上面，我们知道了怎么接受请求数据，并能解决 POST 乱码的问题，那么我们怎么回显数据呢？为此我们在page下创建一个test2.jsp： 1234567891011&lt;!DOCTYPE html&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"java.util.*\" isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring MVC 数据回显&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;回显数据：$&#123;message&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 使用 Servlet 原生 API 来实现我们先用 Servlet 原生的 API 完成这个任务： 123456@RequestMapping(\"/value\")public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) &#123; request.setAttribute(\"message\",\"成功！\"); return new ModelAndView(\"test1\");&#125; 使用 Spring MVC 所提供的 ModelAndView 对象1234567@RequestMapping(\"/value\")public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) &#123; ModelAndView mav = new ModelAndView(\"test1\"); mav.addObject(\"message\",\"成功！\"); return mav;&#125; 使用 Model 对象在 Spring MVC 中，我们通常都是使用这样的方式来绑定数据， 12345@RequestMapping(\"/value\")public String handleRequest(Model model) &#123; model.addAttribute(\"message\",\"成功！\") return \"test1\";&#125; 使用 @ModelAttribute 注解： 123456789@ModelAttributepublic void model(Model model) &#123; model.addAttribute(\"message\", \"注解成功\");&#125;@RequestMapping(\"/value\")public String handleRequest() &#123; return \"test1\";&#125; 这样写就会在访问控制器方法 handleRequest() 时，会首先调用 model() 方法将 message 添加进页面参数中去，在视图中可以直接调用，但是这样写会导致该控制器所有的方法都会首先调用 model() 方法，但同样的也很方便，因为可以加入各种各样的数据。 客户端跳转前面不管是地址 /hello 跳转到 index.jsp 还是 /test 跳转到 test.jsp，这些都是服务端的跳转，也就是 request.getRequestDispatcher(&quot;地址&quot;).forward(request, response); 那我们如何进行客户端跳转呢？我们继续在 HelloController 中编写： 123456789101112@RequestMapping(\"/hello\")public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mav = new ModelAndView(\"index\"); mav.addObject(\"message\", \"Hello Spring MVC\"); return mav;&#125;@RequestMapping(\"/jump\")public ModelAndView jump() &#123; ModelAndView mav = new ModelAndView(\"redirect:/hello\"); return mav;&#125; 我们使用 redirect:/hello 就表示我们要跳转到 /hello 这个路径，我们重启服务器，在地址栏中输入：localhost/jump ，会自动跳转到 /hello 路径下 也可以这样用： 1234@RequestMapping(\"/jump\")public String jump() &#123; return \"redirect: ./hello\";&#125; 文件上传我们先来回顾一下传统的文件上传和下载：传送门 我们再来看一下在 Spring MVC 中如何实现文件的上传和下载 注意： 需要先导入 commons-io-1.3.2.jar 和 commons-fileupload-1.2.1.jar 两个包 配置上传解析器 在 dispatcher-servlet.xml 中新增一句： 1&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"/&gt; 开启对上传功能的支持 编写 JSP 文件名为 upload.jsp，仍创建在page下： 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;测试文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"picture\"&gt; &lt;input type=\"submit\" value=\"上 传\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 编写控制器 在 Packagecontroller下新建UploadController类： 12345678910111213141516171819202122package controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class UploadController &#123; @RequestMapping(\"/upload\") public void upload(@RequestParam(\"picture\") MultipartFile picture) throws Exception &#123; System.out.println(picture.getOriginalFilename()); &#125; @RequestMapping(\"/test2\") public ModelAndView upload() &#123; return new ModelAndView(\"upload\"); &#125;&#125; 测试 在浏览器地址栏中输入：localhost/test2 ，选择文件点击上传，测试成功","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Spring","slug":"Code/Spring","permalink":"http://xiaoqinghua.site/categories/Code/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoqinghua.site/tags/Spring/"}]},{"title":"Spring AOP总结","slug":"Spring-AOP总结","date":"2017-12-08T05:22:36.000Z","updated":"2018-09-07T10:28:46.108Z","comments":true,"path":"Spring-AOP总结.html","link":"","permalink":"http://xiaoqinghua.site/Spring-AOP总结.html","excerpt":"","text":"Spring AOP 简介如果说 IoC 是 Spring 的核心，那么面向切面编程(AOP)就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。 AOP 即 Aspect Oriented Program 面向切面编程 首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 &quot;编织&quot; 在一起，这就叫AOP AOP 的目的AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 AOP 当中的概念： 切入点（Pointcut） 在哪些类，哪些方法上切入（where） 通知（Advice） 在方法执行的什么时机（when:方法前/方法后/方法前后）做什么（what:增强的功能） 切面（Aspect） 切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强！ 织入（Weaving） 把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成） 举个栗子： 房东的核心业务就是签合同，收房租，那么这就够了，带租客看房，交钥匙等部分都是重复且边缘的事，交给中介就好了，这就是AOP AOP 的一个思想：让关注点代码与业务代码分离！ show me the code: 在 Packagepojo下新建一个Landlord类 12345678910111213package pojo;import org.springframework.stereotype.Component;@Component(\"landlord\")public class Landlord &#123; public void service() &#123; // 仅仅只是实现了核心的业务功能 System.out.println(\"签合同\"); System.out.println(\"收房租\"); &#125;&#125; 在 Packageaspect下新建一个中介商Broker类： 12345678910111213141516171819202122package aspect;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Component@Aspectclass Broker &#123; @Before(\"execution(* pojo.Landlord.service())\") public void before()&#123; System.out.println(\"带租客看房\"); System.out.println(\"谈价格\"); &#125; @After(\"execution(* pojo.Landlord.service())\") public void after()&#123; System.out.println(\"交钥匙\"); &#125;&#125; 在 applicationContext.xml 中配置自动注入，并告诉 Spring IoC 容器去哪里扫描这两个 Bean： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:component-scan base-package=\"aspect\" /&gt; &lt;context:component-scan base-package=\"pojo\" /&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 在 Packagetest下编写测试代码： 1234567891011121314151617package test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Landlord;public class TestSpring &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Landlord landlord = (Landlord) context.getBean(\"landlord\", Landlord.class); landlord.service(); &#125;&#125; 在 Landlord 的 service() 方法中仅仅实现了核心的业务代码，其余的关注点功能是根据我们设置的切面自动补全的。 使用注解来开发 Spring AOP使用注解的方式已经逐渐成为了主流，所以我们利用上面的例子来说明如何用注解来开发 Spring AOP 第一步：选择连接点Spring 是方法级别的 AOP 框架，我们主要也是以某个类的某个方法作为连接点，另一种说法就是：选择哪一个类的哪一方法用以增强功能。 1234567// ....public void service() &#123; // 仅仅只是实现了核心的业务功能 System.out.println(\"签合同\"); System.out.println(\"收房租\");&#125;// .... 我们在这里就选择上述 Landlord 类中的 service() 方法作为连接点。 第二步：创建切面选择好了连接点就可以创建切面了，我们可以把切面理解为一个拦截器，当程序运行到连接点的时候，被拦截下来，在开头加入了初始化的方法，在结尾也加入了销毁的方法而已，在 Spring 中只要使用 @Aspect 注解一个类，那么 Spring IoC 容器就会认为这是一个切面了： 12345678910111213141516171819202122package aspect;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Component@Aspectclass Broker &#123; @Before(\"execution(* pojo.Landlord.service())\") public void before()&#123; System.out.println(\"带租客看房\"); System.out.println(\"谈价格\"); &#125; @After(\"execution(* pojo.Landlord.service())\") public void after()&#123; System.out.println(\"交钥匙\"); &#125;&#125; 注意： 被定义为切面的类仍然是一个 Bean ，需要 @Component 注解标注 @Before: 前置通知，在连接点方法前调用 @Around: 环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法，后面会讲 @After: 后置通知，在连接点方法后调用 @AfterReturning: 返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常 @AfterThrowing: 异常通知，当连接点方法异常时调用 第三步：定义切点在上面的注解中定义了 execution 的正则表达式，Spring 通过这个正则表达式判断具体要拦截的是哪一个类的哪一个方法： 1execution(* pojo.Landlord.service()) 依次对这个表达式作出分析： execution：代表执行方法的时候会触发 ：代表任意返回类型的方法 pojo.Landlord：代表类的全限定名 service()：被拦截的方法名称 通过上面的表达式，Spring 就会知道应该拦截 pojo.Lnadlord 类下的 service() 方法。上面的演示类还好，如果多出都需要写这样的表达式难免会有些复杂，我们可以通过使用 @Pointcut 注解来定义一个切点来避免这样的麻烦： 123456789101112131415161718192021222324252627package aspect;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspectclass Broker &#123; @Pointcut(\"execution(* pojo.Landlord.service())\") public void lService() &#123; &#125; @Before(\"lService()\") public void before() &#123; System.out.println(\"带租客看房\"); System.out.println(\"谈价格\"); &#125; @After(\"lService()\") public void after() &#123; System.out.println(\"交钥匙\"); &#125;&#125; 环绕通知我们来探讨一下环绕通知，这是 Spring AOP 中最强大的通知，因为它集成了前置通知和后置通知，它保留了连接点原有的方法的功能，所以它及强大又灵活，让我们来看看： 1234567891011121314151617181920212223242526272829303132333435363738package aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;@Component@Aspectclass Broker &#123;// 注释掉之前的 @Before 和 @After 注解以及对应的方法// @Before(\"execution(* pojo.Landlord.service())\")// public void before() &#123;// System.out.println(\"带租客看房\");// System.out.println(\"谈价格\");// &#125;//// @After(\"execution(* pojo.Landlord.service())\")// public void after() &#123;// System.out.println(\"交钥匙\");// &#125; // 使用 @Around 注解来同时完成前置和后置通知 @Around(\"execution(* pojo.Landlord.service())\") public void around(ProceedingJoinPoint joinPoint) &#123; System.out.println(\"带租客看房\"); System.out.println(\"谈价格\"); try &#123; joinPoint.proceed(); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; System.out.println(\"交钥匙\"); &#125;&#125;","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Spring","slug":"Code/Spring","permalink":"http://xiaoqinghua.site/categories/Code/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoqinghua.site/tags/Spring/"}]},{"title":"Spring Bean总结","slug":"Spring-Bean总结","date":"2017-12-03T05:22:36.000Z","updated":"2018-09-07T10:28:28.979Z","comments":true,"path":"Spring-Bean总结.html","link":"","permalink":"http://xiaoqinghua.site/Spring-Bean总结.html","excerpt":"","text":"装配 Bean 的概述大部分场景下，我们都会使用 ApplicationContext 的具体实现类，因为对应的 Spring IoC容器功能相对强大。 而在 Spring 中提供了 3 种方法进行配置： 在 XML 文件中显式配置 在 Java 的接口和类中实现配置 隐式 Bean 的发现机制和自动装配原则 方式选择的原则在现实的工作中，这 3 种方式都会被用到，并且在学习和工作之中常常混合使用，所以这里给出一些关于这 3 种优先级的建议： 最优先：通过隐式 Bean 的发现机制和自动装配的原则: 基于约定由于配置的原则，这种方式应该是最优先的 好处：减少程序开发者的决定权，简单又不失灵活。 其次：Java 接口和类中配置实现配置: 在没有办法使用自动装配原则的情况下应该优先考虑此类方法 好处：避免 XML 配置的泛滥，也更为容易。 典型场景：一个父类有多个子类，比如学生类有两个子类，一个男学生类和女学生类，通过 IoC 容器初始化一个学生类，容器将无法知道使用哪个子类去初始化，这个时候可以使用 Java 的注解配置去指定。 最后：XML 方式配置: 在上述方法都无法使用的情况下，那么也只能选择 XML 配置的方式。 好处：简单易懂（当然，特别是对于初学者） 典型场景：当使用第三方类的时候，有些类并不是我们开发的，我们无法修改里面的代码，这个时候就通过 XML 的方式配置使用了。 通过 XML 配置装配 Bean使用 XML 装配 Bean 需要定义对应的 XML，这里需要引入对应的 XML 模式（XSD）文件，这些文件会定义配置 Spring Bean 的一些元素，当我们在 IDEA 中创建 XML 文件时，会有友好的提示： 一个简单的 XML 配置文件如下： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 这就只是一个格式文件，引入了一个 beans 的定义，引入了 xsd 文件，它是一个根元素，这样它所定义的元素将可以定义对应的 Spring Bean 装配简易值先来一个最简单的装配： 123&lt;bean id=\"myBean\" class=\"com.xiaoqinghua.TestBean\"&gt; &lt;property name=\"name\" value=\"测试\" /&gt;&lt;/bean&gt; id 属性是 Spring 能找到当前 Bean 的一个依赖的编号，遵守 XML 语法的 ID 唯一性约束。必须以字母开头，可以使用字母、数字、连字符、下划线、句号、冒号，不能以 / 开头。不过 id 属性不是一个必需的属性，name 属性也可以定义 bean 元素的名称，能以逗号或空格隔开起多个别名，并且可以使用很多的特殊字符，比如在 Spring 和 Spring MVC的整合中，就得使用 name 属性来定义 bean 的名称，并且使用 / 开头。注意： 从 Spring 3.1 开始，id 属性也可以是 String 类型了，也就是说 id 属性也可以使用 / 开头，而 bean 元素的 id 的唯一性由容器负责检查。如果 id 和 name 属性都没有声明的话，那么 Spring 将会采用 “全限定名#{number}” 的格式生成编号。 例如这里，如果没有声明 “id=&quot;myBean&quot;” 的话，那么 Spring 为其生成的编号就是 “com.xiaoqinghua.TestBean#0”，当它第二次声明没有 id 属性的 Bean 时，编号就是 “com.xiaoqinghua.TestBean#1”，以此类推。 class 属性显然就是一个类的全限定名 property 元素是定义类的属性，其中的 name 属性定义的是属性的名称，而 value 是它的值。 装配集合有些时候我们需要装配一些复杂的东西，比如 Set、Map、List、Array 和 Properties 等，新建一个 ComplexAssembly 类： 12345678910111213141516import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class ComplexAssembly &#123; private Long id; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; private Properties properties; private Set&lt;String&gt; set; private String[] array; /* setter and getter */&#125; 这个 Bean 没有任何的实际意义，只是为了介绍如何装配这些常用的集合类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;bean id=\"complexAssembly\" class=\"pojo.ComplexAssembly\"&gt; &lt;!-- 装配Long类型的id --&gt; &lt;property name=\"id\" value=\"1\"/&gt; &lt;!-- 装配List类型的list --&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;value-list-1&lt;/value&gt; &lt;value&gt;value-list-2&lt;/value&gt; &lt;value&gt;value-list-3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 装配Map类型的map --&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"key1\" value=\"value-key-1\"/&gt; &lt;entry key=\"key2\" value=\"value-key-2\"/&gt; &lt;entry key=\"key3\" value=\"value-key-2\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 装配Properties类型的properties --&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"prop1\"&gt;value-prop-1&lt;/prop&gt; &lt;prop key=\"prop2\"&gt;value-prop-2&lt;/prop&gt; &lt;prop key=\"prop3\"&gt;value-prop-3&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 装配Set类型的set --&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;value-set-1&lt;/value&gt; &lt;value&gt;value-set-2&lt;/value&gt; &lt;value&gt;value-set-3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 装配String[]类型的array --&gt; &lt;property name=\"array\"&gt; &lt;array&gt; &lt;value&gt;value-array-1&lt;/value&gt; &lt;value&gt;value-array-2&lt;/value&gt; &lt;value&gt;value-array-3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 总结： List 属性为对应的 &lt;list&gt; 元素进行装配，然后通过多个 &lt;value&gt; 元素设值 Map 属性为对应的 &lt;map&gt; 元素进行装配，然后通过多个 &lt;entry&gt; 元素设值，只是 entry 包含一个键值对(key-value)的设置 Properties 属性为对应的 &lt;properties&gt; 元素进行装配，通过多个 元素设值，只是 properties 元素有一个必填属性 key ，然后可以设置值 Set 属性为对应的 &lt;set&gt; 元素进行装配，然后通过多个 &lt;value&gt; 元素设值 对于数组而言，可以使用 &lt;array&gt; 设置值，然后通过多个 &lt;value&gt; 元素设值。 上面看到了对简单 String 类型的各个集合的装载，但是有些时候可能需要更为复杂的装载，比如一个 List 可以是一个系列类的对象，为此需要定义注入的相关信息，其实跟上面的配置没什么两样，只不过加入了 ref 这一个属性而已： 集合注入总结： List 属性使用 元素定义注入，使用多个 元素的 Bean 属性去引用之前定义好的 Bean 123456&lt;property name=\"list\"&gt; &lt;list&gt; &lt;ref bean=\"bean1\"/&gt; &lt;ref bean=\"bean2\"/&gt; &lt;/list&gt;&lt;/property&gt; Map 属性使用 元素定义注入，使用多个 元素的 key-ref 属性去引用之前定义好的 Bean 作为键，而用 value-ref 属性引用之前定义好的 Bean 作为值 12345&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key-ref=\"keyBean\" value-ref=\"valueBean\"/&gt; &lt;/map&gt;&lt;/property&gt; Set 属性使用 元素定义注入，使用多个 元素的 bean 去引用之前定义好的 Bean 12345&lt;property name=\"set\"&gt; &lt;set&gt; &lt;ref bean=\"bean\"/&gt; &lt;/set&gt;&lt;/property&gt; 命名空间装配除了上述的配置之外， Spring 还提供了对应的命名空间的定义，只是在使用命名空间的时候要先引入对应的命名空间和 XML 模式（XSD）文件。 c-命名空间 c-命名空间是在 Spring 3.0 中引入的，它是在 XML 中更为简洁地描述构造器参数的方式，要使用它的话，必须要在 XML 的顶部声明其模式： 注意：是通过构造器参数的方式 现在假设我们现在有这么一个类： 1234567891011public class Student &#123; int id; String name; public Student(int id, String name) &#123; this.id = id; this.name = name; &#125; // setter and getter&#125; 在 c-命名空间和模式声明之后，我们就可以使用它来声明构造器参数了： 123456789&lt;!-- 引入 c-命名空间之前 --&gt;&lt;bean name=\"student1\" class=\"pojo.Student\"&gt; &lt;constructor-arg name=\"id\" value=\"1\" /&gt; &lt;constructor-arg name=\"name\" value=\"学生1\"/&gt;&lt;/bean&gt;&lt;!-- 引入 c-命名空间之后 --&gt;&lt;bean name=\"student2\" class=\"pojo.Student\" c:id=\"2\" c:name=\"学生2\"/&gt; c-命名空间属性名以 “c:” 开头，也就是命名空间的前缀。接下来就是要装配的构造器参数名，在此之后如果需要注入对象的话则要跟上 -ref（如c:card-ref=&quot;idCard1&quot;，则对 card 这个构造器参数注入之前配置的名为 idCard1 的 bean） 很显然，使用 c-命名空间属性要比使用 &lt;constructor-arg&gt; 元素精简，并且会直接引用构造器之中参数的名称，这有利于我们使用的安全性。 我们有另外一种替代方式： 12&lt;bean name=\"student2\" class=\"pojo.Student\" c:_0=\"3\" c:_1=\"学生3\"/&gt; 我们将参数的名称替换成了 “0” 和 “1” ，也就是参数的索引。因为在 XML 中不允许数字作为属性的第一个字符，因此必须要添加一个下划线来作为前缀。 p-命名空间 c-命名空间通过构造器注入的方式来配置 bean，p-命名空间则是用setter的注入方式来配置 bean ，同样的，我们需要引入声明： 然后我们就可以通过 p-命名空间来设置属性： 123456789&lt;!-- 引入p-命名空间之前 --&gt;&lt;bean name=\"student1\" class=\"pojo.Student\"&gt; &lt;property name=\"id\" value=\"1\" /&gt; &lt;property name=\"name\" value=\"学生1\"/&gt;&lt;/bean&gt;&lt;!-- 引入p-命名空间之后 --&gt;&lt;bean name=\"student2\" class=\"pojo.Student\" p:id=\"2\" p:name=\"学生2\"/&gt; 我们需要先删掉 Student 类中的构造函数，不然 XML 约束会提示我们配置 &lt;constructor-arg&gt; 元素。 同样的，如果属性需要注入其他 Bean 的话也可以在后面跟上 -ref： 12&lt;bean name=\"student2\" class=\"pojo.Student\" p:id=\"2\" p:name=\"学生2\" p:cdCard-ref=\"cdCard1\"/&gt; util-命名空间 工具类的命名空间，可以简化集合类元素的配置，同样的我们需要引入其声明（无需担心怎么声明的问题，IDEA会有很友好的提示）： 我们来看看引入前后的变化： 12345678910111213&lt;!-- 引入util-命名空间之前 --&gt;&lt;property name=\"list\"&gt; &lt;list&gt; &lt;ref bean=\"bean1\"/&gt; &lt;ref bean=\"bean2\"/&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- 引入util-命名空间之后 --&gt;&lt;util:list id=\"list\"&gt; &lt;ref bean=\"bean1\"/&gt; &lt;ref bean=\"bean2\"/&gt;&lt;/util:list&gt; &lt;util:list&gt; 只是 util-命名空间中的多个元素之一，下表提供了 util-命名空间提供的所有元素： ps: 马丹的，这个主题不支持 markdown 的表格语法，fuck 元素 描述 &lt;util:constant&gt; 引用某个类型的 public static 域，并将其暴露为 bean &lt;util:list&gt; 创建一个 java.util.List 类型的 bean，其中包含值或引用 &lt;util:map&gt; 创建一个 java.util.map 类型的 bean，其中包含值或引用 &lt;util:properties&gt; 创建一个 java.util.Properties 类型的 bean &lt;util:property-path&gt; 引用一个 bean 的属性（或内嵌属性），并将其暴露为 bean &lt;util:set&gt; 创建一个 java.util.Set 类型的 bean，其中包含值或引用 引入其他配置文件在实际开发中，随着应用程序规模的增加，系统中 &lt;bean&gt; 元素配置的数量也会大大增加，导致 applicationContext.xml 配置文件变得非常臃肿难以维护。 解决方案：让 applicationContext.xml 文件包含其他配置文件即可 使用 &lt;import&gt; 元素引入其他配置文件 1.在src文件下新建一个 bean.xml 文件，写好基础的约束，把 applicationContext.xml 文件中配置的 &lt;bean&gt; 元素复制进去 2.在 applicationContext.xml 文件中写入： 1&lt;import resource=\"bean.xml\" /&gt; 通过注解装配 Bean上面，我们已经了解了如何使用 XML 的方式去装配 Bean，但是更多的时候已经不再推荐使用 XML 的方式去装配 Bean，更多的时候回考虑使用注解（annotation） 的方式去装配 Bean。 优势： 可以减少 XML 的配置，当配置项多的时候，臃肿难以维护 功能更加强大，既能实现 XML 的功能，也提供了自动装配的功能，采用了自动装配后，程序猿所需要做的决断就少了，更加有利于对程序的开发，这就是“约定大于配置”的开发原则 在 Spring 中，它提供了两种方式来让 Spring IoC 容器发现 bean： 组件扫描：通过定义资源(xml文件)的方式，让 Spring IoC 容器扫描对应的包，从而把 bean 装配进来。 自动装配：通过注解定义，使得一些依赖关系可以通过注解完成。 使用@Compoent 装配 Bean我们把之前创建的 Student 类改一下： 1234567891011@Component(value = \"student1\")public class Student &#123; @Value(\"1\") int id; @Value(\"student_name_1\") String name; // getter and setter&#125; @Component注解： 表示 Spring IoC 会把这个类扫描成一个 bean 实例，而其中的 value 属性代表这个类在 Spring 中的 id，这就相当于在 XML 中定义的 Bean 的 id：&lt;bean id=&quot;student1&quot; class=&quot;pojo.Student&quot; /&gt;，也可以简写成 @Component(&quot;student1&quot;)，甚至直接写成 @Component ，对于不写的，Spring IoC 容器就默认以类名来命名作为 id，只不过首字母小写，配置到容器中。 @Value注解： 表示值的注入，跟在 XML 中写 value 属性是一样的。 这样我们就声明好了我们要创建的一个 Bean，就像在 XML 中写下了这样一句话： 1234&lt;bean name=\"student1\" class=\"pojo.Student\"&gt; &lt;property name=\"id\" value=\"1\" /&gt; &lt;property name=\"name\" value=\"student_name_1\"/&gt;&lt;/bean&gt; 但是现在我们声明了这个类，并不能进行任何的测试，因为 Spring IoC 并不知道这个 Bean 的存在，这个时候我们可以使用一个 StudentConfig 类去告诉 Spring IoC ： 12345import org.springframework.context.annotation.ComponentScan;@ComponentScanpublic class StudentConfig &#123;&#125; 这个类十分简单，没有任何逻辑，但是需要说明两点： StudentConfig 类 和 Student 类位于同一包名下 @ComponentScan注解： 代表进行扫描，默认是扫描当前包的路径，扫描所有带有 @Component 注解的 POJO。 这样一来，我们就可以通过 Spring 定义好的 Spring IoC 容器的实现类——AnnotationConfigApplicationContext 去生成 IoC 容器了： 123ApplicationContext context = new AnnotationConfigApplicationContext(StudentConfig.class);Student student = (Student) context.getBean(\"student1\", Student.class);student.printInformation(); 这里可以看到使用了 AnnotationConfigApplicationContext 类去初始化 Spring IoC 容器，它的配置项是 StudentConfig 类，这样 Spring IoC 就会根据注解的配置去解析对应的资源，来生成 IoC 容器了。 明显的弊端： 对于 @ComponentScan 注解，它只是扫描所在包的 Java 类，但是更多的时候我们希望的是可以扫描我们指定的类 上面的例子只是注入了一些简单的值，测试发现，通过 @Value 注解并不能注入对象 @Component 注解存在着两个配置项： basePackages：它是由 base 和 package 两个单词组成的，而 package 还是用了复数，意味着它可以配置一个 Java 包的数组，Spring 会根据它的配置扫描对应的包和子包，将配置好的 Bean 装配进来 basePackageClasses：它由 base、package 和 class 三个单词组成，采用复数，意味着它可以配置多个类， Spring 会根据配置的类所在的包，为包和子包进行扫描装配对应配置的 Bean 我们来试着重构之前写的 StudentConfig 类来验证上面两个配置项： 1234567891011121314import org.springframework.context.annotation.ComponentScan;@ComponentScan(basePackages = \"pojo\")public class StudentConfig &#123;&#125;// —————————————————— ` 宇宙超级无敌分割线`—————————————————— package pojo;import org.springframework.context.annotation.ComponentScan;@ComponentScan(basePackageClasses = pojo.Student.class)public class StudentConfig &#123;&#125; 对于 basePackages 和 basePackageClasses 的选择问题： basePackages 的可读性会更好一些，所以在项目中会优先选择使用它，但是在需要大量重构的工程中，尽量不要使用basePackages，因为很多时候重构修改包名需要反复地配置，而 IDE 不会给你任何的提示，而采用basePackageClasses会有错误提示。 自动装配——@Autowired上面提到的两个弊端之一就是没有办法注入对象，通过自动装配我们将解决这个问题。 所谓自动装配技术是一种由 Spring 自己发现对应的 Bean，自动完成装配工作的方式，它会应用到一个十分常用的注解 @Autowired 上，这个时候 Spring 会根据类型去寻找定义的 Bean 然后将其注入，听起来很神奇，让我们实际来看一看： 先在 Packageservice下创建一个 StudentService 接口： 12345package service;public interface StudentService &#123; public void printStudentInfo();&#125; 使用接口是 Spring 推荐的方式，这样可以更为灵活，可以将定义和实现分离 为上面的接口创建一个 StudentServiceImp 实现类： 123456789101112131415161718package service;import org.springframework.beans.factory.annotation.Autowired;import pojo.Student;@Component(\"studentService\")public class StudentServiceImp implements StudentService &#123; @Autowired private Student student = null; // getter and setter public void printStudentInfo() &#123; System.out.println(\"学生的 id 为：\" + student.getName()); System.out.println(\"学生的 name 为：\" + student.getName()); &#125;&#125; 该实现类实现了接口的 printStudentInfo() 方法，打印出成员对象 student 的相关信息，这里的 @Autowired注解，表示在 Spring IoC 定位所有的 Bean 后，这个字段需要按类型注入，这样 IoC 容器就会寻找资源，然后将其注入。 编写测试类： 12345678// 第一步：修改 StudentConfig 类，告诉 Spring IoC 在哪里去扫描它：package pojo;import org.springframework.context.annotation.ComponentScan;@ComponentScan(basePackages = &#123;\"pojo\", \"service\"&#125;)public class StudentConfig &#123;&#125; 123// 或者也可以在 XML 文件中声明去哪里做扫描&lt;context:component-scan base-package=\"pojo\" /&gt;&lt;context:component-scan base-package=\"service\" /&gt; 123456789101112131415161718192021// 第二步：编写测试类：package test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import pojo.StudentConfig;import service.StudentService;import service.StudentServiceImp;public class TestSpring &#123; public static void main(String[] args) &#123; // 通过注解的方式初始化 Spring IoC 容器 ApplicationContext context = new AnnotationConfigApplicationContext(StudentConfig.class); StudentService studentService = context.getBean(\"studentService\", StudentServiceImp.class); studentService.printStudentInfo(); &#125;&#125;学生的 id 为：student_id_1学生的 name 为：student_name_1 再次理解： @Autowired 注解表示在 Spring IoC 定位所有的 Bean 后，再根据类型寻找资源，然后将其注入。 过程： 定义 Bean ——&gt; 初始化 Bean（扫描） ——&gt; 根据属性需要从 Spring IoC 容器中搜寻满足要求的 Bean ——&gt; 满足要求则注入 问题： IoC 容器可能会寻找失败，此时会抛出异常（默认情况下，Spring IoC 容器会认为一定要找到对应的 Bean 来注入到这个字段，但有些时候并不是一定需要，比如日志） 解决： 通过配置项 required 来改变，比如 @Autowired(required = false) @Autowired 注解不仅仅能配置在属性之上，还允许方法配置，常见的 Bean 的 setter 方法也可以使用它来完成注入，总之一切需要 Spring IoC 去寻找 Bean 资源的地方都可以用到，例如： 1234567public class JuiceMaker &#123; // ...... @Autowired public void setSource(Source source) &#123; this.source = source; &#125;&#125; 在大部分的配置中都推荐使用这样的自动注入来完成，这是 Spring IoC 帮助我们自动装配完成的，这样使得配置大幅度减少，满足约定优于配置的原则，增强程序的健壮性。 自动装配的歧义性（@Primary和@Qualifier）在上面的例子中我们使用 @Autowired 注解来自动注入一个 Source 类型的 Bean 资源，但如果我们现在有两个 Srouce 类型的资源，Spring IoC 就会不知所措，不知道究竟该引入哪一个 Bean： 12345678910&lt;bean name=\"source1\" class=\"pojo.Source\"&gt; &lt;property name=\"fruit\" value=\"橙子\"/&gt; &lt;property name=\"sugar\" value=\"多糖\"/&gt; &lt;property name=\"size\" value=\"超大杯\"/&gt;&lt;/bean&gt;&lt;bean name=\"source2\" class=\"pojo.Source\"&gt; &lt;property name=\"fruit\" value=\"橙子\"/&gt; &lt;property name=\"sugar\" value=\"少糖\"/&gt; &lt;property name=\"size\" value=\"小杯\"/&gt;&lt;/bean&gt; 我们可以会想到 Spring IoC 最底层的容器接口——BeanFactory 的定义，它存在一个按照类型获取 Bean 的方法，显然通过 Source.class 作为参数无法判断使用哪个类实例进行返回，这就是自动装配的歧义性。 为了消除歧义性，Spring 提供了两个注解： @Primary注解： 代表首要的，当 Spring IoC 检测到有多个相同类型的 Bean 资源的时候，会优先注入使用该注解的类。 问题：该注解只是解决了首要的问题，但是并没有选择性的问题 @Qualifier注解： 上面所谈及的歧义性，一个重要的原因是 Spring 在寻找依赖注入的时候是按照类型注入引起的。除了按类型查找 Bean，Spring IoC 容器最底层的接口 BeanFactory 还提供了按名字查找的方法，如果按照名字来查找和注入不就能消除歧义性了吗？ 使用方法： 指定注入名称为 &quot;source1&quot; 的 Bean 资源: 12345678public class JuiceMaker &#123; ...... @Autowired @Qualifier(\"source1\") public void setSource(Source source) &#123; this.source = source; &#125;&#125; 使用@Bean 装配 Bean问题： 以上都是通过 @Component 注解来装配 Bean ，并且只能注解在类上，当你需要引用第三方包的（jar 文件），而且往往并没有这些包的源码，这时候将无法为这些包的类加入 @Component 注解，让它们变成开发环境中的 Bean 资源。 解决方案： 自己创建一个新的类来扩展包里的类，然后再新类上使用 @Component 注解，但这样很 low 使用 @Bean 注解，注解到方法之上，使其成为 Spring 中返回对象为 Spring 的 Bean 资源。 我们在 Package pojo 下新建一个用来测试 @Bean 注解的类： 1234567891011121314package pojo;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class BeanTester &#123; @Bean(name = \"testBean\") public String test() &#123; String str = \"测试@Bean注解\"; return str; &#125;&#125; @Configuration 注解相当于 XML 文件的根元素，必须要，有了才能解析其中的 @Bean 注解 然后我们在测试类中编写代码，从 Spring IoC 容器中获取到这个 Bean ： 1234// 在 pojo 包下扫描ApplicationContext context = new AnnotationConfigApplicationContext(\"pojo\");// 因为这里获取到的 Bean 就是 String 类型所以直接输出System.out.println(context.getBean(\"testBean\")); @Bean 的配置项中包含 4 个配置项： name： 是一个字符串数组，允许配置多个 BeanName autowire： 标志是否是一个引用的 Bean 对象，默认值是 Autowire.NO initMethod： 自定义初始化方法 destroyMethod： 自定义销毁方法 使用 @Bean 注解的好处就是能够动态获取一个 Bean 对象，能够根据环境不同得到不同的 Bean 对象。或者说将 Spring 和其他组件分离（其他组件不依赖 Spring，但是又想 Spring 管理生成的 Bean） Bean 的作用域在默认的情况下，Spring IoC 容器只会对一个 Bean 创建一个实例，但有时候，我们希望能够通过 Spring IoC 容器获取多个实例，我们可以通过 @Scope 注解或者 &lt;bean&gt; 元素中的 scope 属性来设置，例如： 1234// XML 中设置作用域&lt;bean id=\"\" class=\"\" scope=\"prototype\" /&gt;// 使用注解设置作用域@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) Spring 提供了 5 种作用域，它会根据情况来决定是否生成新的对象： 作用域类别 描述 singleton(单例) 在Spring IoC容器中仅存在一个Bean实例 （默认的scope） prototype(多例) 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时 ，相当于执行new XxxBean()：不会在容器启动时创建对象 request(请求) 用于web开发，将Bean放入request范围 ，request.setAttribute(“xxx”) ， 在同一个request 获得同一个Bean session(会话) 用于web开发，将Bean 放入Session范围，在同一个Session 获得同一个Bean globalSession(全局会话) 一般用于 Porlet 应用环境 , 分布式系统存在全局 session 概念（单点登录），如果不是 porlet 环境，globalSession 等同于 Session 在开发中主要使用 scope=&quot;singleton&quot;、scope=&quot;prototype&quot;，对于MVC中的Action使用prototype类型，其他使用singleton，Spring容器会管理 Action 对象的创建,此时把 Action 的作用域设置为 prototype. 扩展阅读：@Profile 注解 、 条件化装配 Bean Spring 表达式语言简要说明Spring 还提供了更灵活的注入方式，那就是 Spring 表达式，实际上 Spring EL 远比以上注入方式都要强大，它拥有很多功能： 使用 Bean 的 id 来引用 Bean 调用指定对象的方法和访问对象的属性 进行运算 提供正则表达式进行匹配 集合配置 我们来看一个简单的使用 Spring 表达式的例子： 1234567891011121314151617181920package pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(\"elBean\")public class ElBean &#123; // 通过 beanName 获取 bean，然后注入 @Value(\"#&#123;role&#125;\") private Role role; // 获取 bean 的属性 id @Value(\"#&#123;role.id&#125;\") private Long id; // 调用 bean 的 getNote 方法 @Value(\"#&#123;role.getNote().toString()&#125;\") private String note; /* getter and setter */&#125; 与属性文件中读取使用的 “$” 不同，在 Spring EL 中则使用 “#” 扩展阅读： Spring 表达式语言","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Spring","slug":"Code/Spring","permalink":"http://xiaoqinghua.site/categories/Code/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoqinghua.site/tags/Spring/"}]},{"title":"Spring之IoC总结","slug":"Spring之IoC总结","date":"2017-12-03T02:58:53.000Z","updated":"2018-09-07T05:19:46.631Z","comments":true,"path":"Spring之IoC总结.html","link":"","permalink":"http://xiaoqinghua.site/Spring之IoC总结.html","excerpt":"","text":"Spring IoC 阐述这就是一种控制反转的理念：控制反转是一种通过描述（在 Java 中可以是 XML 或者注解）并通过第三方（Spring）去产生或获取特定对象的方式。 好处： 降低对象之间的耦合 我们不需要理解一个类的具体实现，只需要知道它有什么用就好了（直接向 IoC 容器拿） 主动创建的模式中，责任归于开发者，而在被动的模式下，责任归于 IoC 容器，基于这样的被动形式，我们就说对象被控制反转了。（也可以说是反转了控制） Spring IoC 容器Spring 会提供 IoC 容器来管理和容纳我们所开发的各种各样的 Bean，并且我们可以从中获取各种发布在 Spring IoC 容器里的 Bean，并且通过描述可以得到它。 Spring IoC 容器的设计Spring IoC 容器的设计主要是基于以下两个接口： BeanFactory ApplicationContext 其中 ApplicationContext 是 BeanFactory 的子接口之一，换句话说：BeanFactory 是 Spring IoC 容器所定义的最底底接口，而 ApplicationContext 是其最高级接口之一，并对 BeanFactory 功能做了许多的扩展，所以在绝大部分的工作场景下，都会使用 ApplicationContext 作为 Spring IoC 容器。 BeanFactory从上图中我们可以几乎看到， BeanFactory 位于设计的最底层，它提供了 Spring IoC 最底层的设计，为此，我们先来看看该类中提供了哪些方法 1234567891011121314151617181920212223242526String FACTORY_BEAN_PREFIX = \"&amp;\";Object getBean(String name) throws BeansException;&lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException;Object getBean(String name, Object... args) throws BeansException;&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;boolean containsBean(String name);boolean isSingleton(String name) throws NoSuchBeanDefinitionException;boolean isPrototype(String name) throws NoSuchBeanDefinitionException;boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;@NullableClass&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;String[] getAliases(String name); 由于这个接口的重要性，所以有必要在这里作一下简短的说明： getBean 对应了多个方法来获取配置给 Spring IoC 容器的 Bean。 按照类型拿 bean： 1bean = (Bean) factory.getBean(Bean.class); 注意：要求在 Spring 中只配置了一个这种类型的实例，否则报错。（如果有多个那 Spring 就懵了，不知道该获取哪一个） 按照 bean 的名字拿 bean: 1bean = (Bean) factory.getBean(\"beanName\"); 注意：这种方法不太安全，IDE 不会检查其安全性（关联性） 按照名字和类型拿 bean：（推荐） 1bean = (Bean) factory.getBean(\"beanName\", Bean.class); isSingleton 用于判断是否单例，如果判断为真，其意思是该 Bean 在容器中是作为一个唯一单例存在的。而isPrototype则相反，如果判断为真，意思是当你从容器中获取 Bean，容器就为你生成一个新的实例。 注意：在默认情况下，【isSingleton】为 ture，而【isPrototype】为 false 关于 type 的匹配，这是一个按 Java 类型匹配的方式 getAliases方法是获取别名的方法 这就是 Spring IoC 最底层的设计，所有关于 Spring IoC 的容器将会遵守它所定义的方法。 ApplicationContext根据 ApplicationContext 的类继承关系图，可以看到 ApplicationContext 接口扩展了许许多多的接口，因此它的功能十分强大，所以在实际应用中常常会使用到的是 ApplicationContext 接口，因为 BeanFactory 的方法和功能较少，而 ApplicationContext 的方法和功能较多。 我们来认识一个 ApplicationContext 的实现类——ClassPathXmlApplicationContext。 12ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\");Source source = (Source) context.getBean(\"source\", Source.class); 这样就会使用 Application 的实现类 ClassPathXmlApplicationContext 去初始化 Spring IoC 容器，然后开发者就可以通过 IoC 容器来获取资源了啦！ ApplicationContext 常见实现类：1.ClassPathXmlApplicationContext： 读取classpath中的资源 1ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 2:FileSystemXmlApplicationContext: 读取指定路径的资源 1ApplicationContext ac = new FileSystemXmlApplicationContext(\"c:/applicationContext.xml\"); 3.XmlWebApplicationContext: 需要在Web的环境下才可以运行 1234XmlWebApplicationContext ac = new XmlWebApplicationContext(); // 这时并没有初始化容器ac.setServletContext(servletContext); // 需要指定ServletContext对象ac.setConfigLocation(\"/WEB-INF/applicationContext.xml\"); // 指定配置文件路径，开头的斜线表示Web应用的根目录ac.refresh(); // 初始化容器 BeanFactory 和 ApplicationContext 的区别： BeanFactory：是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。在应用中，一般不使用 BeanFactory，而推荐使用ApplicationContext（应用上下文），原因如下。 ApplicationContext： 继承了 BeanFactory，拥有了基本的 IoC 功能； 除此之外，ApplicationContext 还提供了以下功能： 支持国际化； 支持消息机制； 支持统一的资源加载； 支持AOP功能； Spring IoC 的容器的初始化和依赖注入虽然 Spring IoC 容器的生成十分的复杂，但是大体了解一下 Spring IoC 初始化的过程还是必要的。这对于理解 Spring 的一系列行为是很有帮助的。 注意：Bean 的定义和初始化在 Spring IoC 容器是两大步骤，它是先定义，然后初始化和依赖注入的。 Bean 的定义分为 3 步： Resource 定位 Spring IoC 容器先根据开发者的配置，进行资源的定位，在 Spring 的开发中，通过 XML 或者注解都是十分常见的方式，定位的内容是由开发者提供的。 BeanDefinition 的载入 这个时候只是将 Resource 定位到的信息，保存到 Bean 定义（BeanDefinition）中，此时并不会创建 Bean 的实例 BeanDefinition 的注册 这个过程就是将 BeanDefinition 的信息发布到 Spring IoC 容器中 注意：此时仍然没有对应的 Bean 的实例。 做完了以上 3 步，Bean 就在 Spring IoC 容器中被定义了，而没有被初始化，更没有完成依赖注入，也就是没有注入其配置的资源给 Bean，那么它还不能完全使用。 对于初始化和依赖注入，Spring Bean 还有一个配置选项——lazy-init，其含义就是是否初始化 Spring Bean。在没有任何配置的情况下，它的默认值为 default，实际值为 false，也就是 Spring IoC 默认会自动初始化 Bean。如果将其设置为 true，那么只有当我们使用 Spring IoC 容器的 getBean 方法获取它时，它才会进行 Bean 的初始化，完成依赖注入。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Spring","slug":"Code/Spring","permalink":"http://xiaoqinghua.site/categories/Code/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoqinghua.site/tags/Spring/"}]},{"title":"Spring总结","slug":"Spring总结","date":"2017-12-02T02:58:53.000Z","updated":"2018-09-07T10:27:12.252Z","comments":true,"path":"Spring总结.html","link":"","permalink":"http://xiaoqinghua.site/Spring总结.html","excerpt":"","text":"认识 Spring 框架Spring 框架是 Java 应用最广的框架，它的成功来源于理念，而不是技术本身，它的理念包括 IoC (Inversion of Control，控制反转) 和 AOP(Aspect Oriented Programming，面向切面编程)。 什么是 Spring： Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，来源于 Rod Johnson 在其著作《Expert one on one J2EE design and development》中阐述的部分理念和原型衍生而来。 Spring 提倡以“最少侵入”的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring 适用范围：任何 Java 应用 Spring 的根本使命：简化 Java 开发 尽管 J2EE 能够赶上 Spring 的步伐，但 Spring 并没有停止前进， Spring 继续在其他领域发展，而 J2EE 则刚刚开始涉及这些领域，或者还没有完全开始在这些领域的创新。移动开发、社交 API 集成、NoSQL 数据库、云计算以及大数据都是 Spring 正在涉足和创新的领域。Spring 的前景依然会很美好。 Spring 中常用术语 框架：是能完成一定功能的半成品。 框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。 非侵入式设计： 从框架的角度可以理解为：无需继承框架提供的任何类这样我们在更换框架时，之前写过的代码几乎可以继续使用。 轻量级和重量级： 轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 JavaBean： 即符合 JavaBean 规范的 Java 类 POJO：即 Plain Old Java Objects，简单老式 Java 对象 它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。 注意：bean 的各种名称——虽然 Spring 用 bean 或者 JavaBean 来表示应用组件，但并不意味着 Spring 组件必须遵循 JavaBean 规范，一个 Spring 组件可以是任意形式的 POJO。 容器： 在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 Spring 的优势 低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） 方便集成其他框架（如MyBatis、Hibernate） 降低 Java 开发难度 Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式） Spring 能帮我们做什么 Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。 Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。 Spring 能非常简单的帮我们管理数据库事务。 Spring 还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。 Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。 Spring 能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 Spring 的框架结构 Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。 Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。 AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。 Core Container(核心容器)：包含有Beans、Core、Context和SpEL模块。 Test模块支持使用JUnit和TestNG对Spring组件进行测试。 Spring IoC 和 DI 简介IoC：Inverse of Control（控制反转） 读作“反转控制”，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 正控：若要使用某个对象，需要自己去负责对象的创建 反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架 好莱坞法则：Don’t call me ,I’ll call you 一个例子控制反转显然是一个抽象的概念，我们举一个鲜明的例子来说明。 在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己“主动”创造的过程，也就是说一杯橙汁需要你自己创造。 然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。 请注意你并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。 写一个 pojo 123456public class Source &#123; private String fruit; // 类型 private String sugar; // 糖分描述 private String size; // 大小杯 /* setter and getter */&#125; 建一个 \bapplication.xml，\b通过 xml 文件\b配置\b的方式装配我们的 bean 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean name=\"source\" class=\"pojo.Source\"&gt; &lt;property name=\"fruit\" value=\"橙子\"/&gt; &lt;property name=\"sugar\" value=\"多糖\"/&gt; &lt;property name=\"size\" value=\"超大杯\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 运行 1234567891011121314151617181920212223import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Source;public class TestSpring &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext( new String[]&#123;\"applicationContext.xml\"&#125; ); Source source = (Source) context.getBean(\"source\"); System.out.println(source.getFruit()); System.out.println(source.getSugar()); System.out.println(source.getSize()); &#125;&#125;橙子多糖超大杯 总结： 传统的方式： 通过new 关键字主动创建一个对象 IOC方式： 对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。 IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。 DI：Dependency Injection（依赖注入）指 Spring 创建对象的过程中，将对象依赖属性（简单值，集合，对象）通过配置设值给该对象 继续上面的例子 写一个 JuiceMaker 类： 123456789101112public class JuiceMaker &#123; // 唯一关联了一个 Source 对象 private Source source = null; /* setter and getter */ public String makeJuice()&#123; String juice = \"xxx用户点了一杯\" + source.getFruit() + source.getSugar() + source.getSize(); return juice; &#125;&#125; 在 xml 文件中配置 JuiceMaker 对象： 注意：这里要使用 ref 来注入另一个对象 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean name=\"source\" class=\"pojo.Source\"&gt; &lt;property name=\"fruit\" value=\"橙子\"/&gt; &lt;property name=\"sugar\" value=\"多糖\"/&gt; &lt;property name=\"size\" value=\"超大杯\"/&gt; &lt;/bean&gt; &lt;bean name=\"juickMaker\" class=\"pojo.JuiceMaker\"&gt; &lt;property name=\"source\" ref=\"source\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 在测试代码中\b加入： 1234JuiceMaker juiceMaker = (JuiceMaker) context.getBean(\"juickMaker\");System.out.println(juiceMaker.makeJuice());xxx用户点了一杯橙子多糖超大杯 总结：IoC 和 DI 其实是同一个概念的不同角度描述，DI 相对 IoC 而言，明确描述了“被注入对象依赖 IoC 容器配置依赖对象” IoC 如何实现的最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎： 读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名 使用反射的API，基于类名实例化对应的对象实例 将对象实例，通过构造函数或者 setter，传递给 JuiceMaker 我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！ Spring AOP 简介如果说 IoC 是 Spring 的核心，那么面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。 AOP 即 Aspect Oriented Program 面向切面编程首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP AOP 的目的AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 AOP 当中的概念： 切入点（Pointcut） 在哪些类，哪些方法上切入（where） 通知（Advice） 在方法执行的什么时机（when:方法前/方法后/方法前后）做什么（what:增强的功能） 切面（Aspect） 切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强！ 织入（Weaving） 把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成） AOP \b示例 创建一个 ProdectService类 12345public class ProductService &#123; public void doSomeService()&#123; System.out.println(\"doSomeService\"); &#125;&#125; 在 application.xml 中装配该 bean 1&lt;bean name=\"productService\" class=\"service.ProductService\" /&gt; 新建一个 LoggerAspect 类 1234567891011import org.aspectj.lang.ProceedingJoinPoint;public class LoggerAspect &#123; public Object log(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(\"start log:\" + joinPoint.getSignature().getName()); Object object = joinPoint.proceed(); System.out.println(\"end log:\" + joinPoint.getSignature().getName()); return object; &#125;&#125; 在 application.xml 中申明业务对象和日志切面 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; &lt;bean name=\"productService\" class=\"service.ProductService\" /&gt; &lt;bean id=\"loggerAspect\" class=\"aspect.LoggerAspect\"/&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- where：在哪些地方（包.类.方法）做增加 --&gt; &lt;aop:pointcut id=\"loggerCutpoint\" expression=\"execution(* service.ProductService.*(..)) \"/&gt; &lt;!-- what:做什么增强 --&gt; &lt;aop:aspect id=\"logAspect\" ref=\"loggerAspect\"&gt; &lt;!-- when:在什么时机（方法前/后/前后） --&gt; &lt;aop:around pointcut-ref=\"loggerCutpoint\" method=\"log\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 123456789101112131415161718192021import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Source;public class TestSpring &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext( new String[]&#123;\"applicationContext.xml\"&#125; ); ProductService ps = (ProductService) context.getBean(\"productService\"); ps.doSomeService(); &#125;&#125;start log:doSomeServicedoSomeServiceend log:doSomeService","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Spring","slug":"Code/Spring","permalink":"http://xiaoqinghua.site/categories/Code/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoqinghua.site/tags/Spring/"}]},{"title":"Java I/O总结","slug":"Java-I-O总结","date":"2017-11-25T10:25:51.000Z","updated":"2018-09-06T12:28:06.503Z","comments":true,"path":"Java-I-O总结.html","link":"","permalink":"http://xiaoqinghua.site/Java-I-O总结.html","excerpt":"","text":"一、概览Java 的 I/O 大概可以分成以下几类： 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket non-blocking输入/输出：NIO 二、磁盘操作File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。 递归地列出一个目录下所有文件： 123456789101112public static void listAllFiles(File dir) &#123; if (dir == null || !dir.exists()) &#123; return; &#125; if (dir.isFile()) &#123; System.out.println(dir.getName()); return; &#125; for (File file : dir.listFiles()) &#123; listAllFiles(file); &#125;&#125; 三、字节操作实现文件复制 12345678910111213141516public static void copyFile(String src, String dist) throws IOException &#123; FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20 * 1024]; // read() 最多读取 buffer.length 个字节 // 返回的是实际读取的个数 // 返回 -1 的时候表示读到 eof，即文件尾 while (in.read(buffer, 0, buffer.length) != -1) &#123; out.write(buffer); &#125; in.close(); out.close();&#125; 装饰者模式Java I/O 使用了装饰者模式来实现。以 InputStream 为例， InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。 12FileInputStream fileInputStream = new FileInputStream(filePath);BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。 四、字符操作编码与解码编码就是把字符转换为字节，而解码是把字节重新组合成字符。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节 UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。 Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。 String 的编码方式String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。 1234String str1 = \"中文\";byte[] bytes = str1.getBytes(\"UTF-8\");String str2 = new String(bytes, \"UTF-8\");System.out.println(str2); 在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。 getBytes() 的默认编码方式与平台有关，一般为 UTF-8 1byte[] bytes = str1.getBytes(); Reader 与 Writer不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。 InputStreamReader 实现从字节流解码成字符流； OutputStreamWriter 实现字符流编码成为字节流。 实现逐行输出文本文件的内容 123456789101112131415public static void readFileContent(String filePath) throws IOException &#123; FileReader fileReader = new FileReader(filePath); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while ((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象 // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法 // 因此只要一个 close() 调用即可 bufferedReader.close();&#125; 五、对象操作序列化序列化就是将一个对象转换成字节序列，方便存储和传输。 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() 不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。 Serializable序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws IOException, ClassNotFoundException &#123; A a1 = new A(123, \"abc\"); String objectFile = \"file/a1\"; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile)); objectOutputStream.writeObject(a1); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile)); A a2 = (A) objectInputStream.readObject(); objectInputStream.close(); System.out.println(a2);&#125;private static class A implements Serializable &#123; private int x; private String y; A(int x, String y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"x = \" + x + \" \" + \"y = \" + y; &#125;&#125; transienttransient 关键字可以使一些属性不会被序列化。 ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。 1private transient Object[] elementData; 六、网络操作Java 中的网络支持： InetAddress：用于表示网络上的硬件资源，即 IP 地址； URL：统一资源定位符； Sockets：使用 TCP 协议实现网络通信； Datagram：使用 UDP 协议实现网络通信。 InetAddress没有公有的构造函数，只能通过静态方法来创建实例。 12InetAddress.getByName(String host);InetAddress.getByAddress(byte[] address); URL可以直接从 URL 中读取字节流数据。 1234567891011121314151617181920public static void main(String[] args) throws IOException &#123; URL url = new URL(\"http://www.google.com\"); /* 字节流 */ InputStream is = url.openStream(); /* 字符流 */ InputStreamReader isr = new InputStreamReader(is, \"utf-8\"); /* 提供缓存功能 */ BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; br.close();&#125; Sockets ServerSocket：服务器端类 Socket：客户端类 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。 Datagram DatagramSocket：通信类 DatagramPacket：数据包类 七、NIO Java NIO Tutorial Java NIO 浅析 IBM: NIO 入门 新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。 流与块I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。 面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 I/O 包和 NIO 已经很好地集成了，java.io. 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io. 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。 通道与缓冲区 通道 通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。 通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。 通道包括以下类型： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 缓冲区 发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。 缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。 缓冲区包括以下类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区状态变量 capacity：最大容量； position：当前已经读写的字节数； limit：还可以读写的字节数。 状态变量的改变过程举例： ① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。 ② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。 ③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。 ④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。 ⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。 文件 NIO 实例以下展示了使用 NIO 快速复制文件的实例： 12345678910111213141516171819202122232425262728293031323334353637public static void fastCopy(String src, String dist) throws IOException &#123; /* 获得源文件的输入字节流 */ FileInputStream fin = new FileInputStream(src); /* 获取输入字节流的文件通道 */ FileChannel fcin = fin.getChannel(); /* 获取目标文件的输出字节流 */ FileOutputStream fout = new FileOutputStream(dist); /* 获取输出字节流的文件通道 */ FileChannel fcout = fout.getChannel(); /* 为缓冲区分配 1024 个字节 */ ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while (true) &#123; /* 从输入通道中读取数据到缓冲区中 */ int r = fcin.read(buffer); /* read() 返回 -1 表示 EOF */ if (r == -1) &#123; break; &#125; /* 切换读写 */ buffer.flip(); /* 把缓冲区的内容写入输出文件中 */ fcout.write(buffer); /* 清空缓冲区 */ buffer.clear(); &#125;&#125; 选择器NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。 NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。 应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。FSo 创建选择器 1Selector selector = Selector.open(); 将通道注册到选择器上 123ServerSocketChannel ssChannel = ServerSocketChannel.open();ssChannel.configureBlocking(false);ssChannel.register(selector, SelectionKey.OP_ACCEPT); 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 它们在 SelectionKey 的定义如下： 1234public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4; 可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如： 1int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 监听事件 1int num = selector.select(); 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。 获取到达的事件 1234567891011Set&lt;SelectionKey&gt; keys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove();&#125; 事件循环 因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。 1234567891011121314while (true) &#123; int num = selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove(); &#125;&#125; Socket NIO 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class NIOServer &#123; public static void main(String[] args) throws IOException &#123; // 创建选择器 Selector selector = Selector.open(); // 创建一个通道 ServerSocketChannel ssChannel = ServerSocketChannel.open(); // 设置这个通道是非阻塞的 ssChannel.configureBlocking(false); // 将这个通道注册到选择器上，同时绑定了注册的事件 ssChannel.register(selector, SelectionKey.OP_ACCEPT); // 创建一个 socket ServerSocket serverSocket = ssChannel.socket(); // 绑定 ip 和 端口 InetSocketAddress address = new InetSocketAddress(\"127.0.0.1\", 8888); serverSocket.bind(address); // 循环处理 while (true) &#123; // 选择器开始选择 selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel(); // 服务器会为每个新连接创建一个 SocketChannel SocketChannel sChannel = ssChannel1.accept(); sChannel.configureBlocking(false); // 这个新连接主要用于从客户端读取数据 sChannel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; SocketChannel sChannel = (SocketChannel) key.channel(); System.out.println(readDataFromSocketChannel(sChannel)); sChannel.close(); &#125; keyIterator.remove(); &#125; &#125; &#125; private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); StringBuilder data = new StringBuilder(); while (true) &#123; buffer.clear(); int n = sChannel.read(buffer); if (n == -1) &#123; break; &#125; buffer.flip(); int limit = buffer.limit(); char[] dst = new char[limit]; for (int i = 0; i &lt; limit; i++) &#123; dst[i] = (char) buffer.get(i); &#125; data.append(dst); buffer.clear(); &#125; return data.toString(); &#125;&#125; 12345678910public class NIOClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"127.0.0.1\", 8888); OutputStream out = socket.getOutputStream(); String s = \"hello world\"; out.write(s.getBytes()); out.close(); &#125;&#125; 内存映射文件内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。 向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。 下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。 1MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024); 对比NIO 与普通 I/O 的区别主要有以下两点： NIO 是非阻塞的； NIO 面向块，I/O 面向流。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java集合框架总结","slug":"Java集合框架总结","date":"2017-10-03T06:49:27.000Z","updated":"2018-08-27T11:11:23.208Z","comments":true,"path":"Java集合框架总结.html","link":"","permalink":"http://xiaoqinghua.site/Java集合框架总结.html","excerpt":"","text":"概览容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 List ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 容器中的设计模式迭代器模式 Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"a\");list.add(\"b\");for (String item : list) &#123; System.out.println(item);&#125; 适配器模式java.util.Arrays#asList() 可以把数组类型转换为 List 类型。 12@SafeVarargspublic static &lt;T&gt; List&lt;T&gt; asList(T... a) 应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。 12Integer[] arr = &#123;1, 2, 3&#125;;List list = Arrays.asList(arr); 也可以使用以下方式调用 asList()： 1List list = Arrays.asList(1,2,3); 总结Collection: 是一个接口 List ：元素有序，可重复 ，并引入位置下标； LinkedList ：底层是双向循环链表。增删快，查询慢，线程不安全，效率高； ArrayList ：底层数据结构是数组 。查询快，增删慢，线程不安全，效率高； Vector ：底层数据结构是数组，查询快，增删慢，线程安全，效率低； Stack Set ：元素无序，不可重复 HashSet ：无序的，底层数据结构是哈希表，储存对象的时候依赖两个方法：hashcode()和equals()，重写hashcode() 和equals()即可； TreesSet：按照自然顺序进行排列，如果是汉字会按照a-z排序，底层数据结构是红黑树。 对集合中的元素排序两种方式： 1.自然排序（元素具有比较性） 让元素所属的类实现Comparable接口 2.比较器排序（集合具有比较性） 让集合接收一个Comparator的实现类对象 LinkedHashSet: 底层数据结构是哈希表和链表组成，链表保证有序，哈希表保证唯一 Quene ： 队列 Map ： Hashtable ：不可以添加为空，底层数据结构是哈希表，线程安全，效率低 HashMap ：可以添加为空，底层数据结构是哈希表，线程不安全，效率高 WeakHashMap ：以弱键实现的基于哈希表的 Map。 TreeMap：底层数据结构是红黑树，有序的，效率比HashMap 低 LinkedHashMap：底层数据结构是哈希表和链表组成，链表保证有序，哈希表保证唯一，仅比HashMap慢一点","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java集合框架","slug":"Code/Java集合框架","permalink":"http://xiaoqinghua.site/categories/Code/Java集合框架/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://xiaoqinghua.site/tags/Java集合框架/"}]},{"title":"Java异常总结","slug":"Java异常总结","date":"2017-09-23T14:20:13.000Z","updated":"2018-08-24T15:17:06.291Z","comments":true,"path":"Java异常总结.html","link":"","permalink":"http://xiaoqinghua.site/Java异常总结.html","excerpt":"","text":"异常概述异常异常就是在程序的运行过程中所发生的不正常的事件，它会中断正在运行的程序 异常处理Java 编程语言使用异常处理机制为程序提供了错误处理的能力，好处就是：如果代码中存在了异常，但是进行了捕获处理，那么程序就会继续运行下去，不会因为一个异常导致程序中断运行 🌰1：如果程序可能存在异常但是没有做异常处理，那么将导致程序不能正常的运行下去 12345678910111213public class ExceptionTest &#123; public static void main(String[] args) &#123; int a = 10; int b = 0; int c = a / b; System.out.println(c); System.out.println(\"不会输出的语句，因为不会执行到这里\"); &#125;&#125;输出结果是：Exception in thread \"main\" java.lang.ArithmeticException: / by zeroat cn.caijiajia.cn.caijiajia.exception.ExceptionTest.main(ExceptionTest.java:12) 🌰2：如果程序可能存在异常并做了异常处理，那么程序就会正常的运行下去 1234567891011121314151617181920public class ExceptionTest &#123; public static void main(String[] args) &#123; try &#123; int a = 10; int b = 0; int c = a / b; System.out.println(c); System.out.println(\"异常代码下面的代码将都不会执行\"); &#125; catch (ArithmeticException e) &#123; System.out.println(\"处理异常的代码\"); &#125; System.out.println(\"异常处理代码下面的程序将会继续执行而不会程序中断\"); &#125;&#125;输出结果是：Exception in thread \"main\" java.lang.ArithmeticException: / by zeroat cn.caijiajia.cn.caijiajia.exception.ExceptionTest.main(ExceptionTest.java:12)处理异常的代码异常处理代码下面的程序将会继续执行而不会程序中断 Java 中如何处理异常异常处理的 5 个关键字12345try：执行可能产生异常的代码catch：捕获异常并对异常情况做相应处理finally：无论是否发生异常，代码总能执行。（释放资源，关闭数据库连接）throws：声明可能抛出的各种异常（受检异常较多）用于方法后throw：手动的抛出异常（手动抛出我们自定义的异常较多）用于方法体中 异常处理后程序运行情况 情况一：没产生异常 123456789101112public void method() &#123; try &#123; // 代码段① [正常业务逻辑代码，此处不会产生异常] &#125; catch (Exception e) &#123; // 代码段② [对异常处理的代码段] &#125; // 代码段③ [正常业务逻辑代码]&#125;运行结果： 代码段① 代码段③ 情况二：产生异常并捕获异常 12345678910111213141516public void method() &#123; try &#123; // 异常代码段① [正常业务逻辑代码，此处会产生异常] // 代码段② [正常业务逻辑代码] &#125; catch (Exception e) &#123; // 代码段③ [对异常处理的代码段] &#125; // 代码段④ [正常业务逻辑代码]&#125;运行结果： 代码段① 代码段③ 代码段④注意：如果想要正常的 代码段② 执行，那么可以把代码段从 try catch 里面提出来，和 代码段④ 放在一起，当异常处理完之后，就可以同时去执行 代码段② 和 代码段④ 了。 情况三：产生异常并捕获异常，但是捕获异常类型不匹配产生异常类型 1234567891011121314public void method() &#123; try &#123; // 异常代码段① [正常业务逻辑代码，此处会产生角标越界异常] // 代码段② [正常业务逻辑代码] &#125; catch (IOException e) &#123; // 代码段③ [对异常处理的代码段] &#125; // 代码段④ [正常业务逻辑代码]&#125;运行结果： 代码段① 注意：如果捕获异常类型和产生的异常类型不匹配，那么就和没有处理异常情况一样了，try catch 后面的代码段将都不会执行，发生异常就会导致程序中断运行 异常体系异常类层次图 Error 和 ExceptionError 类和 Exception 类的父类都是 Throwable 类 Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。因此我们在学习的时候主要是学会Exception。 Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 Exception 异常分类及处理Exception 异常主要分为两大类：Checked Exception，Unchecked Exception；即受检异常和非受检异常（运行时异常） Checked Exception：受检异常，即 Java 程序必须显式处理的异常，如果程序没有处理 Checked 异常，该程序在编译时就会发生错误无法编译。例如图中所示的 IOException 处理受检异常通过有如下两种方式： 方式一：通过 trycatch 显式处理异常，否则编译不通过 12345678910public class ExceptionTest &#123; public static void main(String[] args) &#123; try &#123; // 通过 try catch 显示处理异常 FileInputStream fis = new FileInputStream(new File(\"\")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 方式二：通过 throws 抛出异常，让上层来处理异常，否则编译不通过 12345public class ExceptionTest &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream(new File(\"\")); &#125;&#125; Unchecked Exception：非受检异常，即 RuntimeException 运行时异常。这些异常程序可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。比如常见的 NullPointerException、IndexOutOfBoundsException 就是运行时异常。不过按照经验来说，这类异常要么尽量避免，要么出现了就要做异常处理，从而保证程序的健壮性。 处理运行时异常通过有如下两种方式： 方式一：常见的空指针处理 123456// 通过写伪代码来演示其处理流程if (对象 == null) &#123; // 处理对象为 null 的逻辑&#125; else &#123; // 处理对象不为 null 的逻辑&#125; 方式二：跟业务相关异常，抛出自定义异常 1234567// 通过手机号注册业务逻辑User user = dao.getByPhone(phone);if (user != null) &#123; // 说明此手机号码已经被注册，那么就抛出业务异常（即自定义异常） throw new MyRuntimeException(\"该用户已注册\");&#125;// 如果没有注册，继续走注册流程代码 总结： 受检异常（Checked Exception）处理起来很简单，因为程序如果不做显式处理，那么就会编译不通过，强制要求处理 运行时异常（Unchecked exception）则是看心情处理的，但是如果想要公司代码更加健壮，更少的出现问题，最好要做一下异常处理。但是如果做这个处理呢？对于这种运行时异常，大部分都是和业务相关的，比如手机号注册例子；这种情况下在 Java 的异常体系中并没有相关异常类做处理，因为 Java 不管再智能，也不可能知道我们的业务情况，当然就不会针对业务提供一些异常类供我们使用，因此为了解决这个问题，自定义异常就出现了，它对于我们处理业务中产生的运行时异常非常`非常重要，接下来就来看看自定义异常`。 自定义异常产生原因Java 现有的异常类不能满足更多的业务异常处理，因此我们要自定义合适的异常类来处理业务异常 如何自定义异常类第一步：声明一个类继承 Exception 或其子类 那么我们声明的这个类到底继承谁呢？Exception？RuntimeException？ 答案是：RuntimeException 原因是：看了上面的异常类层次图，应该也能发现，Exception 下面有两大类子类，受检异常和运行时异常，如果我们自定义的类继承了 Exception，则就会因为受检异常的存在而变成了受检异常类，这个时候我们自定义的异常类，如果在程序中使用，那么就必须显式处理异常，要么 try catch，要么抛出给上层；这样一来，使得我们的程序很混乱，而且并没有达到我们预期的结果。然后当我们自定义的类继承了 RuntimeException 之后，当我们程序中想要使用的时候，直接 new 一个即可，而不再需要显式去再多做处理了。 第二步：自定义异常类应至少包含四个构造方法 123456789101112131415public class MyException extends RuntimeException &#123; public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125; public MyException(Throwable throwable) &#123; super(throwable); &#125; public MyException(String msg, Throwable throwable) &#123; super(msg, throwable); &#125;&#125; catch住了异常一定要记住处理： 12345678910111213public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; throw new Myexception(\"我是一个异常\"); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; &#125; &#125;此时 `retrun` 就是处理，退出循环如果不处理，循环一直进行 第三步：在程序中使用我们的自定义异常 12345678910public void testException() &#123; User user = dao.getByPhone(phone); if (user != null) &#123; // 因为 MyException 是继承 RuntimeException，所以这里直接抛出异常而不用做其它处理 throw new MyException(\"该手机号已被注册\"); &#125; // ...&#125; 注：没错，这里又使用了这个手机号注册的例子，因为这个就是实实在在的在业务中的异常处理。业务是千变万化，但是它们可能产生的异常处理方式是不会变化的，按照这个思路去做异常处理即可。 tips： 如上自定义的异常类中的构造方法是最基本的几个。每家公司的自定义异常可能都会有区别; 比如定义一个 SuperException 类实现了 RuntimeException，然后在自定义 ClientException，ServerException 再去继承 SuperException；那么这就是一套自定义体系了，分为客户端异常和服务端异常，在需要做异常处理的地方使用对应的异常类并抛出异常错误信息即可了。 比如可能有的公司会在自定义异常类中在定义一些字段，errorCode，errorMessage 等，来代表某些业务错误码和·对应的错误信息·等。不管怎么样，我们只要了解自定义异常的原理后，面对哪个公司的自定义异常体系我们都能够轻松应对。 总结 一个是异常体系，要分清受检异常和运行时异常； 一个就是自定义异常，知道如何自定义异常和如何使用自定义异常。 参考资料Java 入门之异常处理Java 异常的面试问题及答案 -Part 1Java 异常的面试问题及答案 -Part 2Java 异常的面试问题及答案 -Part 3","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java反射","slug":"Java反射","date":"2017-09-10T09:06:08.000Z","updated":"2018-08-25T06:50:11.281Z","comments":true,"path":"Java反射.html","link":"","permalink":"http://xiaoqinghua.site/Java反射.html","excerpt":"","text":"反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 创建新的对象。 Advantages of Using Reflection: Extensibility Features :An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.Class Browsers and Visual Development Environments : A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.Debuggers and Test Tools : Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite. Drawbacks of Reflection:Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection. Performance Overhead : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications. Security Restrictions : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet. Exposure of Internals :Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform. Trail: The Reflection API Java 反射使用总结 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/Java反射.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java8 时间戳和LocalDateTime互转","slug":"Java8-时间戳和LocalDateTime互转","date":"2017-09-06T08:22:48.000Z","updated":"2019-10-16T10:09:19.878Z","comments":true,"path":"Java8-时间戳和LocalDateTime互转.html","link":"","permalink":"http://xiaoqinghua.site/Java8-时间戳和LocalDateTime互转.html","excerpt":"","text":"Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。 java实现获得时间戳(long)： 1LocalDateTime.now().toInstant(ZoneOffset.of(\"+8\")).toEpochMilli(); 时间戳(long)转换成LocalDateTime: 12Long timestamp = LocalDateTime.now().toInstant(ZoneOffset.of(\"+8\")).toEpochMilli();LocalDateTime time2 =LocalDateTime.ofEpochSecond(timestamp/1000,0,ZoneOffset.ofHours(8)); 测试： 12345678910111213/** * @author xiaoqinghua * @since 2018-09-05 14:30 */public class Test &#123; public static void main(String[] args) &#123; long nowTimestamp = LocalDateTime.now().toInstant(ZoneOffset.of(\"+8\")).toEpochMilli(); System.out.println(nowTimestamp); System.out.println(\"=================\"); LocalDateTime nowLocalDateTime = LocalDateTime.ofEpochSecond(nowTimestamp / 1000, 0, ZoneOffset.ofHours(8)); System.out.println(nowLocalDateTime); &#125;&#125; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/iterm2小技巧.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"JAVA 8","slug":"Code/JAVA-8","permalink":"http://xiaoqinghua.site/categories/Code/JAVA-8/"}],"tags":[{"name":"JAVA 8","slug":"JAVA-8","permalink":"http://xiaoqinghua.site/tags/JAVA-8/"}]},{"title":"Object类总结","slug":"Object总结","date":"2017-09-03T09:06:13.000Z","updated":"2018-08-24T07:42:55.771Z","comments":true,"path":"Object总结.html","link":"","permalink":"http://xiaoqinghua.site/Object总结.html","excerpt":"","text":"Object 上帝类Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。 Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。Object类没有定义属性，一共有13个方法： 123456789101112131415161718192021222324252627282930313233// 隐式构造方法public Object();// 调用本地C/C++实现的方法private static native void registerNatives();// 初始化调用static &#123; registerNatives();&#125;protected native Object clone() throws CloneNotSupportedExceptionpublic final native Class&lt;?&gt; getClass()public boolean equals(Object obj)public native int hashCode()public String toString()public final void wait() throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionprotected void finalize() throws Throwable &#123;&#125; 1、类构造器public Object();大部分情况下，Java中通过形如 new A(args..)形式创建一个属于该类型的对象。其中 A 即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。为体现此特性，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数。作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。 当然，并不是所有的类都是通过此种方式去构建，也自然的，并不是所有的类构造函数都是public。 2、private static native void registerNatives();registerNatives函数前面有native关键字修饰，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。方法的具体实现体在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。 既然如此，可能有人会问，registerNatives()修饰符为private，且并没有执行，作用何以达到？其实，在Java源码中，此方法的声明后有紧接着一段静态代码块： 12341 private static native void registerNatives();2 static &#123;3 registerNatives();4 &#125; 3、protected native Object clone() throws CloneNotSupportedException;clone()方法又是一个被声明为native的方法，因此，我们知道了clone()方法并不是Java的原生方法，具体的实现是有C/C++完成的。clone英文翻译为&quot;克隆&quot;，其目的是创建并返回此对象的一个副本。形象点理解，这有一辆科鲁兹，你看着不错，想要个一模一样的。你调用此方法即可像变魔术一样变出一辆一模一样的科鲁兹出来。配置一样，长相一样。但从此刻起，原来的那辆科鲁兹如果进行了新的装饰，与你克隆出来的这辆科鲁兹没有任何关系了。你克隆出来的对象变不变完全在于你对克隆出来的科鲁兹有没有进行过什么操作了。Java术语表述为：clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。 明白了clone的含义后，接下来看看如果调用clone()函数对象进行此克隆操作。 首先看一下下面的这个例子： 123456789public class ObjectTest &#123; public static void main(String[] args) &#123; Object o1 = new Object(); // The method clone() from the type Object is not visible Object clone = o1.clone(); &#125;&#125; 例子很简单，在main()方法中，new一个Object对象后，想直接调用此对象的clone方法克隆一个对象，但是出现错误提示：&quot;The method clone() from the type Object is not visible&quot; why? 根据提示，第一反应是ObjectTest类中定义的Object对象无法访问其clone()方法。回到Object类中clone()方法的定义，可以看到其被声明为protected，估计问题就在这上面了，protected修饰的属性或方法表示：在同一个包内或者不同包的子类可以访问。显然，Object类与ObjectTest类在不同的包中，但是ObjectTest继承自Object，是Object类的子类，于是，现在却出现子类中通过Object引用不能访问protected方法，原因在于对&quot;不同包中的子类可以访问&quot;没有正确理解。 &quot;不同包中的子类可以访问&quot;，是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。 在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。！（super关键字除外） 于是，上例改成如下形式，可以正常编译： 12345678910111213public class ObjectTest &#123; public static void main(String[] args) &#123; ObjectTest ot1 = new ObjectTest(); try &#123; ObjectTest ot2 = (ObjectTest) ot1.clone(); &#125; catch (CloneNotSupportedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 是的，因为此时的主调已经是子类的引用了。 上述代码在运行过程中会抛出&quot;java.lang.CloneNotSupportedException&quot;,表明clone()方法并未正确执行完毕，问题的原因在与Java中的语法规定： clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。 Cloneable接口仅是一个表示接口，接口本身不包含任何方法，用来指示Object.clone()可以合法的被子类引用所调用。 于是，上述代码改成如下形式，即可正确指定clone()方法以实现克隆。 12345678910111213141516 3 public class ObjectTest implements Cloneable &#123; 4 5 public static void main(String[] args) &#123; 6 7 ObjectTest ot1 = new ObjectTest(); 8 9 try &#123;10 ObjectTest ot2 = (ObjectTest) ot1.clone();11 System.out.println(\"ot2:\" + ot2);12 &#125; catch (CloneNotSupportedException e) &#123;13 // TODO Auto-generated catch block14 e.printStackTrace();15 &#125;16 &#125;17 18 &#125; 4、public final native Class&lt;?&gt; getClass();getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。 首先解释下&quot;类对象&quot;的概念：在Java中，类是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为&quot;类对象&quot;。 5、public boolean equals(Object obj);==与equals在 Java 中经常被使用，大家也都知道==与equals的区别： ==表示的是变量值完成相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址） equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。 实际上，上面说法是不严谨的，更多的只是常见于String类中。首先看一下Object类中关于equals()方法的定义： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 由此可见，Object原生的equals()方法内部调用的正是==，与==具有相同的含义。既然如此，为什么还要定义此equals()方法？ equlas()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？ 如上，在Object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到Object基类。 String 类的 equals(): 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 如下场景的实际业务需求，对于User bean，由实际的业务需求可知当属性uid相同时，表示的是同一个User，即两个User对象相等。则可以重写equals以重定义User对象相等的标尺。 1234567891011121314151617181920212223242526272829303132333435363738394041public class User &#123; private int uid; private String name; private int age; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; protected String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object obj) &#123; if (obj == null || !(obj instanceof User)) &#123; return false; &#125; if (((User) obj).getUid() == this.getUid()) &#123; return true; &#125; return false; &#125;&#125; 123456789101112131415public class ObjectTest implements Cloneable &#123; public static void main(String[] args) &#123; User u1 = new User(); u1.setUid(111); u1.setName(\"张三\"); User u2 = new User(); u2.setUid(111); u2.setName(\"张三丰\"); System.out.println(u1.equals(u2)); //返回true &#125;&#125; ObjectTest中打印出true，因为User类定义中重写了equals()方法，这很好理解，很可能张三是一个人小名，张三丰才是其大名，判断这两个人是不是同一个人，这时只用判断uid是否相同即可。 如上重写equals方法表面上看上去是可以了，实则不然。因为它破坏了Java中的约定：重写equals()方法必须重写hasCode()方法 补充 等价关系 自反性 1x.equals(x); // true 对称性 1x.equals(y) == y.equals(x); // true 传递性 12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; 一致性 12多次调用 equals() 方法结果不变x.equals(y) == x.equals(y); // true 与 null 的比较 12对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 falsex.equals(null); // false; equals() 与 == 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 6、public native int hashCode();hashCode()方法返回一个整形数值，表示该对象的哈希码值。 hashCode()具有如下约定： 在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致； 如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等； 反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。 1234567EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。 一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。 12345678@Overridepublic int hashCode() &#123; int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result;&#125; 7、public String toString();toString()方法返回该对象的字符串表示。先看一下Object中的具体方法体： 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode());&#125; toString()方法相信大家都经常用到，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。 getClass()返回对象的类对象，getClassName()以String形式返回类对象的名称（含包名）。Integer.toHexString(hashCode())则是以对象的哈希码为实参，以16进制无符号整数形式返回此哈希码的字符串表示形式。 因此：toString()是由对象的类型和其哈希码唯一确定，同一类型但不相等的两个对象分别调用toString()方法返回的结果可能相同。 8~12、wait(…) / notify() / notifyAll()一说到wait(...) / notify() | notifyAll()几个方法，首先想到的是线程。确实，这几个方法主要用于java多线程之间的协作。先具体看下这几个方法的主要含义： wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。 wait(long timeout)/wait(long timeout, int nanos)：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法，或超过指定的超时时间量。 notify()/notifyAll()：唤醒在此对象监视器上等待的单个线程/所有线程。 wait(...) / notify() | notifyAll()一般情况下都是配套使用。下面来看一个简单的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ThreadTest &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub MyRunnable r = new MyRunnable(); Thread t = new Thread(r); t.start(); synchronized (r) &#123; try &#123; System.out.println(\"main thread 等待t线程执行完\"); r.wait(); System.out.println(\"被notity唤醒，得以继续执行\"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"main thread 本想等待，但被意外打断了\"); &#125; System.out.println(\"线程t执行相加结果\" + r.getTotal()); &#125; &#125;&#125;class MyRunnable implements Runnable &#123; private int total; @Override public void run() &#123; // TODO Auto-generated method stub synchronized (this) &#123; System.out.println(\"Thread name is:\" + Thread.currentThread().getName()); for (int i = 0; i &lt; 10; i++) &#123; total += i; &#125; notify(); System.out.println(\"执行notif后同步代码块中依然可以继续执行直至完毕\"); &#125; System.out.println(\"执行notif后且同步代码块外的代码执行时机取决于线程调度\"); &#125; public int getTotal() &#123; return total; &#125;&#125; 运行结果： 123456main thread 等待t线程执行完Thread name is:Thread-0执行notif后同步代码块中依然可以继续执行直至完毕执行notif后且同步代码块外的代码执行时机取决于线程调度 //此行输出位置有具体的JVM线程调度决定，有可能最后执行被notity唤醒，得以继续执行线程t执行相加结果45 既然是作用于多线程中，为什么却是Object这个基类所具有的方法？原因在于理论上任何对象都可以视为线程同步中的监听器，且wait(...)/notify()|notifyAll()方法只能在同步代码块中才能使用。 从上述例子的输出结果中可以得出如下结论： wait(...)方法调用后当前线程将立即阻塞，且释放其所持有的同步代码块中的锁，直到被唤醒或超时或打断后且重新获取到锁后才能继续执行； notify()/notifyAll()方法调用后，其所在线程不会立即释放所持有的锁，直到其所在同步代码块中的代码执行完毕，此时释放锁，因此，如果其同步代码块后还有代码，其执行则依赖于JVM的线程调度。 在Java源码中，可以看到wait()具体定义如下： 123public final void wait() throws InterruptedException &#123; wait(0);&#125; 且wait(long timeout, int nanos)方法定义内部实质上也是通过调用wait(long timeout)完成。而wait(long timeout)是一个native方法。因此，wait(...)方法本质上都是native方式实现。 notify()/notifyAll()方法也都是native方法。 13、protected void finalize();finalize方法主要与Java垃圾回收机制有关。首先我们看一下finalized方法在Object中的具体定义： 1protected void finalize() throws Throwable &#123; &#125; 我们发现Object类中finalize方法被定义成一个空方法，为什么要如此定义呢？finalize方法的调用时机是怎么样的呢？ 首先，Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对对象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java关键字final和static","slug":"Java关键字final和static","date":"2017-09-02T07:31:51.000Z","updated":"2018-08-25T06:49:34.881Z","comments":true,"path":"Java关键字final和static.html","link":"","permalink":"http://xiaoqinghua.site/Java关键字final和static.html","excerpt":"","text":"关键字final1、数据： 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int x = 1;// x = 2; // cannot assign value to final variable 'x'final A y = new A();y.a = 1; 2、方法： 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3、类： 声明类不允许被继承。 static1、静态变量： 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 1234567891011public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2、静态方法： 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 12345678910public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3、静态语句块： 静态语句块在类初始化时运行一次。 1234567891011public class A &#123; static &#123; System.out.println(\"123\"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125;123 4、静态内部类： 非静态内部类依赖于外部类的实例，而静态内部类不需要。 1234567891011121314public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5、静态导包： 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 6、初始化顺序： 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = \"静态变量\";static &#123; System.out.println(\"静态语句块\");&#125;public String field = \"实例变量\";&#123; System.out.println(\"普通语句块\");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println(\"构造函数\");&#125; 存在继承的情况下，初始化顺序为： 1234561 父类（静态变量、静态语句块）2 子类（静态变量、静态语句块）3 父类（实例变量、普通语句块）4 父类（构造函数）5 子类（实例变量、普通语句块）6 子类（构造函数） 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/Java关键字final和static.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 抽象类和接口","slug":"Java抽象类接口","date":"2017-08-27T11:56:48.000Z","updated":"2018-08-24T14:20:25.347Z","comments":true,"path":"Java抽象类接口.html","link":"","permalink":"http://xiaoqinghua.site/Java抽象类接口.html","excerpt":"","text":"抽象类 当编写一个类时，常常会为该类定义一些方法，这些方法用以描述该类的行为方式，那么这些方法都有具体的方法体。但在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确地知道这些子类如何实现这些方法。使用抽象方法即可满足该要求：抽象方法是只有方法签名（方法名+形参列表），没有方法实现的方法 抽象方法和抽象类抽象方法和抽象类必须使用abstract修饰符来定义，有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法 抽象方法和抽象类的规则如下： 抽象类必须使用abstract修饰符来修饰，抽象方法也必须使用abstract修饰符来修饰，抽象方法不能有方法体 抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例 抽象类可以包含成员变量、方法（普通方法和抽象方法）、构造器、初始化块、内部类（接口、枚举）5种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用 含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含的抽象方法三种情况）只能被定义成抽象类 抽象类与空方法体的方法：public abstract void test(); public void test(){}; 抽象类不能用于创建实例，只能当作父类被其他子类继承 当使用abstract修饰类时，表明这个类只能被继承；当使用abstract修饰方法时，表明这个方法必须由子类提供实现（即重写）。而final修饰的类不能被继承，final修饰的方法不能被重写。因此final和abstract永远不能同时使用 abstract不能用于修饰成员变量，不能用于修饰局部变量，即没有抽象变量、没有抽象成员变量等说法；abstract也不能用于修饰构造器，没有抽象构造器，抽象类里定义的构造器只能是普通构造器 当使用static修饰一个方法时，表明这个方法属于该类本身，即通过类就可调用该方法，但如果该方法被定义成抽象方法，则将导致通过该类来调用该方法时出现错误（调用了一个没有方法体的方法肯定会引起错误）。因此static和abstract不能同时修饰某个方法，即没有所谓的类抽象方法。但static和abstract可以同时修饰内部类 abstract关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此abstract方法不能定义为private访问权限，即private和abstract不能同时修饰方法 抽象类的方法抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会大致保留抽象类的行为方式。 模板模式在面向对象的软件中很常用，其原理简单，实现也很简单。下面是使用模板模式的一些简单规则： 抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给其子类去实现 父类中可能包含需要调用其他系列方法的方法，这些被调用方法既可以由父类实现，也可以由其子类实现。父类里提供的方法只是定义了一个通用算法，其实现也许并不完全由自身实现，而必须依赖于其子类的辅助 Java8改进的接口抽象类是从多个类中抽象出来的模板，如果将这种抽象进行得更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（interface），接口里不能包含普通方法，接口里的所有方法都是抽象方法。Java8对接口进行了改进，允许在接口中定义默认方法，默认方法可以提供方法实现 接口的概念接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，这意味着接口里通常是定义一组公用方法。 Java8中接口的定义123456[修饰符] interface 接口名 extends 父接口1,父接口2...&#123; 零个到多个常量定义... 零个到多个抽象方法定义... 零个到多个内部类、接口、枚举定义... 零个到多个默认方法或类方法定义...&#125; 修饰符可以是public或者省略，如果省略了public访问控制符，则默认采用包权限访问控制符，即只有在相同包结构下才可以访问该接口 接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可；如果要遵守Java可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无须任何分隔符。接口名通常能够使用形容词。 一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。 由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法或默认方法）、内部类（包括内部接口、枚举）定义 接口里定义的是多个类共同的公共行为规范，因此接口里的所有成员，包括常量、方法、内部类和内部枚举都是public访问权限。定义接口成员时，可以省略访问控制修饰符，如果指定访问控制修饰符，则只能使用public访问控制修饰符。 对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加static和final两个修饰符。也就是说，在接口中定义成员变量时，不管是否使用public static final修饰符，接口里的成员变量总是使用这三个修饰符来修饰。而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值 接口里定义的内部类、内部接口、内部枚举默认都采用public static两个修饰符，不管定义时是否指定这两个修饰符，系统都会自动使用public static对它们进行修饰 接口里定义的方法只能是抽象方法、类方法或默认方法，因此如果不是定义默认方法，系统将自动为普通方法增加abstract修饰符；定义接口里的普通方法时不管是否使用public abstract修饰符，接口里的普通方法总是public abstract来修饰。接口里的普通方法不能有方法实现（方法体）；但类方法、默认（default）方法都必须有方法实现（方法体 Java8允许在接口中定义类方法，类方法必须使用static修饰，该方法不能使用default修饰，无论程序是否指定，类方法总是使用public修饰——如果开发者没有指定public，系统会自动为类方法添加public修饰符。类方法可以直接使用接口来调用。 接口的继承接口的继承和类继承不一样，接口完全支持多继承，即一个接口可以有多个直接父接口。和类继承相似，子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。一个接口继承多个父接口时，多个父接口排在extends关键字之后，多个父接口之间以英文逗号（,）隔开。 使用接口接口不能用于创建实例，但接口可以用于声明引用类型变量。当使用接口来声明引用类型变量时，这个引用类型变量必须引用到其实现类的对象。除此之外，接口的主要用途就是被实现类实现。 定义变量，也可用于进行强制类型转换 调用接口中定义的常量 被其他类实现一个类可以实现一个或多个接口，继承使用extends关键字，实现则使用implements关键字 123[修饰符] class 类名 extends 父类 implements 接口1，接口2&#123; 类体部分&#125; 一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。 一个类实现某个接口时，该类将会获得接口中定义的常量（成员变量）、方法等，因此可以把实现接口理解为一种特殊的继承，相当于实现类继承了一个彻底抽象的类（相当于除了默认方法外，所有方法都是抽象方法的类）。 实现接口方法时，必须使用public访问控制修饰符，因为接口里的方法都是public的，而子类（相当于实现类）重写父类方法时访问权限只能更大或者相等，所以实现类实现接口里的方法时只能使用public访问权限 接口和抽象类接口和抽象类很像，它们都具有如下特征: 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。 接口作为系统与外界交互的窗口，接口体现的是一种规范抽象类作为系统中多个子类的共同父类，它所体现的是一种模板式设计 接口和抽象类在用法上的差别： 接口里只能包含抽象方法和默认方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法 接口里不能定义静态方法；抽象类里可以定义静态方法 接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量 接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作 接口里不能包含初始化块，但抽象类则完全包含初始化块 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 参数传递","slug":"Java参数传递","date":"2017-08-27T10:48:08.000Z","updated":"2018-08-24T07:42:27.841Z","comments":true,"path":"Java参数传递.html","link":"","permalink":"http://xiaoqinghua.site/Java参数传递.html","excerpt":"","text":"概述1.什么是参数传递？ 123调用方法时向形参传递数据的过程叫做参数传递。在编程语言中有两种传递方式：值传递与引用传递。必须强调的是，这里提到的两种传递方式不是仅限于Java使用到的传递方式，而是出现在包括Java在内的多种编程语言中的传递方式。 2.变量类型 1在Java中，我们将指向基本类型数据的变量称为原始变量，将指向对象的变量称为引用变量。 值传递1.什么是值传递？ 1将变量的副本传入方法，方法内外操作隔离，在方法内对变量的操作不会反映到方法外的变量中。 2.原始变量 12345678910public void change(int b) &#123; b = 7;&#125;@Testpublic void testBasic() &#123; int a = 9; change(a); System.out.println(a);&#125; 实际输出：9 在参数传递时，按照值传递的规则，变量b接收一个a的副本，同样指向字面值“9”： 接下来，在方法内部，为b赋值7，这样b指向7，由于a与b是两个相互独立的变量，两者之间没有引用与被引用的关系，a依然指向9： 3.String 12345678910public void change(String str01) &#123; str01 = \"baidu\";&#125;@Testpublic void testString() &#123; String str = new String(\"www.baidu.com\"); change(str); System.out.println(str);&#125; 实际输出：www.baidu.com 在参数传递时，str将自身的一个副本传递给str01，这样str01也指向堆中存放“www.baidu.com”的对象： 在方法内部为str01赋值，这样str01就指向方法区字符串常量池中的”baidu”，str依然指向堆中的“www.baidu.com”，str与str01指向不同的对象，相互之间不影响： 这里需要注意一点：java将String设计成不可改变的对象，即一旦String对象包含的字面值发生改变，java就会新建一个对象，并将变量指向新的对象。 4.StringBuilder 12345678910public void change(StringBuilder builder01) &#123; builder01.append(\" World!\");&#125;@Testpublic void testStringBuilder() &#123; StringBuilder builder = new StringBuilder(\"Hello\"); change(builder); System.out.println(builder);&#125; 实际输出：Hello World! 在参数传递完成以后，builder01变量获得builder变量的一个副本，副本与原始变量指向堆中同一个对象： 在方法内部，变量builder没有指向新的对象，依然与builder指向同一对象，所以当builder访问堆中同一对象时，数据发生改变： 5.自定义类型 123456789101112131415161718public class MyInner &#123; public int a;&#125;public class Test&#123; public void change(MyInner in01) &#123; in01.a = 1; &#125; @Test public void testDemain() &#123; MyInner in = new MyInner(); in.a = 9; change(in); System.out.println(in.a); &#125;&#125; 实际输出：1 执行过程同StringBuilder执行过程相同，这里不再赘述。下面对上面的代码做一点改动，如下： 12345678910111213141516171819public class MyInner &#123; public int a;&#125;public class Test&#123; public void change(MyInner in01) &#123; in01=new MyInner();//使in01指向一个新的对象 in01.a = 1; &#125; @Test public void testDemain() &#123; MyInner in = new MyInner(); in.a = 9; change(in); System.out.println(in.a); &#125;&#125; 实际输出：9 参数传递完成时，in01与in指向同一个对象，in01对对象的操作等同于in对对象的操作，接着在方法内部执行”in01=new MyInner();”，这样in01 就指向了一个新的对象，in01所有的操作都与in无关了： 综合以上的运行结果与分析，可知java参数传递方式符合值传递。 引用传递什么是引用传递？ 12345将变量自身的内存地址传入方法中，方法中的变量指向方法外的变量，在方法中对变量的操作就是对方法外变量的操作 。不再一一分析其他变量类型，分析后可以发现，java在传递参数时采用的 不是引用传递，而是值传递。简单讲，值传递时方法内外是两个拥有同一指向的变量，引用传递时方法内外是同一个变量。 本文转自:http://www.tuicool.com/articles/niUfuqN","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java泛型","slug":"Java泛型","date":"2017-08-27T03:21:51.000Z","updated":"2018-08-27T05:24:24.627Z","comments":true,"path":"Java泛型.html","link":"","permalink":"http://xiaoqinghua.site/Java泛型.html","excerpt":"","text":"泛型基础泛型类我们首先定义一个简单的Box类： 1234567891011public class Box &#123; private String object; public void set(String object) &#123; this.object = object; &#125; public String get() &#123; return object; &#125;&#125; 这是最常见的做法，这样做的一个坏处是Box里面现在只能装入String类型的元素，今后如果我们需要装入Integer等其他类型的元素，还必须要另外重写一个Box，代码得不到复用，使用泛型可以很好的解决这个问题。 123456789101112public class Box&lt;T&gt; &#123; // T stands for \"Type\" private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 这样我们的Box类便可以得到复用，我们可以将T替换成任何我们想要的类型： 123Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();Box&lt;Double&gt; doubleBox = new Box&lt;Double&gt;();Box&lt;String&gt; stringBox = new Box&lt;String&gt;(); 泛型方法看完了泛型类，接下来我们来了解一下泛型方法。声明一个泛型方法很简单，只要在返回类型前面加上一个类似&lt;K, V&gt;的形式就行了： 12345678910111213141516171819public class Util &#123; public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123; return p1.getKey().equals(p2.getKey()) &amp;&amp; p1.getValue().equals(p2.getValue()); &#125;&#125;public class Pair&lt;K, V&gt; &#123; private K key; private V value; public Pair(K key, V value) &#123; this.key = key; this.value = value; &#125; public void setKey(K key) &#123; this.key = key; &#125; public void setValue(V value) &#123; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125;&#125; 或者在Java1.7/1.8利用type inference，让Java自动推导出相应的类型参数： 123Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, \"apple\");Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, \"pear\");boolean same = Util.compare(p1, p2); 边界符现在我们要实现这样一个功能，查找一个泛型数组中大于某个特定元素的个数，我们可以这样实现： 1234567public static &lt;T&gt; int countGreaterThan(T[] anArray, T elem) &#123; int count = 0; for (T e : anArray) if (e &gt; elem) // compiler error ++count; return count;&#125; 但是这样很明显是错误的，因为除了short, int, double, long, float, byte, char等原始类型，其他的类并不一定能使用操作符&gt;，所以编译器报错，那怎么解决这个问题呢？答案是使用边界符: 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 做一个类似于下面这样的声明，这样就等于告诉编译器类型参数T代表的都是实现了Comparable接口的类，这样等于告诉编译器它们都至少实现了compareTo方法 1234567public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123; int count = 0; for (T e : anArray) if (e.compareTo(elem) &gt; 0) ++count; return count;&#125; 通配符在了解通配符之前，我们首先必须要澄清一个概念，还是借用我们上面定义的Box类，假设我们添加一个这样的方法： 1public void boxTest (Box&lt;Number&gt; n) &#123; /*...*/ &#125; 那么现在Box&lt;Number&gt; n允许接受什么类型的参数？我们是否能够传入Box&lt;Integer&gt;或者Box&lt;Double&gt;呢？答案是否定的，虽然Integer和Double是Number的子类，但是在泛型中Box&lt;Integer&gt;或者Box&lt;Double&gt;与Box&lt;Number&gt;之间并没有任何的关系。这一点非常重要，接下来我们通过一个完整的例子来加深一下理解: 首先我们先定义几个简单的类，下面我们将用到它： 123class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Orange extends Fruit &#123;&#125; 下面这个例子中，我们创建了一个泛型类Reader，然后在f1()中当我们尝试Fruit f = fruitReader.readExact(apples);编译器会报错，因为List&lt;Fruit&gt;与List&lt;Apple&gt;之间并没有任何的关系。 1234567891011121314151617public class GenericReading &#123; static List&lt;Apple&gt; apples = Arrays.asList(new Apple()); static List&lt;Fruit&gt; fruit = Arrays.asList(new Fruit()); static class Reader&lt;T&gt; &#123; T readExact(List&lt;T&gt; list) &#123; return list.get(0); &#125; &#125; static void f1() &#123; Reader&lt;Fruit&gt; fruitReader = new Reader&lt;Fruit&gt;(); // Errors: List&lt;Fruit&gt; cannot be applied to List&lt;Apple&gt;. // Fruit f = fruitReader.readExact(apples); &#125; public static void main(String[] args) &#123; f1(); &#125;&#125; 但是按照我们通常的思维习惯，Apple和Fruit之间肯定是存在联系，然而编译器却无法识别，那怎么在泛型代码中解决这个问题呢？我们可以通过使用通配符来解决这个问题： 12345678910111213static class CovariantReader&lt;T&gt; &#123; T readCovariant(List&lt;? extends T&gt; list) &#123; return list.get(0); &#125;&#125;static void f2() &#123; CovariantReader&lt;Fruit&gt; fruitReader = new CovariantReader&lt;Fruit&gt;(); Fruit f = fruitReader.readCovariant(fruit); Fruit a = fruitReader.readCovariant(apples);&#125;public static void main(String[] args) &#123; f2();&#125; 这样就相当与告诉编译器，fruitReader的readCovariant方法接受的参数只要是满足Fruit的子类就行(包括Fruit自身)，这样子类和父类之间的关系也就关联上了。 PECS原则上面我们看到了类似&lt;? extends T&gt;的用法，利用它我们可以从list里面get元素，那么我们可不可以往list里面add元素呢？我们来尝试一下： 1234567891011121314public class GenericsAndCovariance &#123; public static void main(String[] args) &#123; // Wildcards allow covariance: List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); // Compile Error: can't add any type of object: // flist.add(new Apple()) // flist.add(new Orange()) // flist.add(new Fruit()) // flist.add(new Object()) flist.add(null); // Legal but uninteresting // We Know that it returns at least Fruit: Fruit f = flist.get(0); &#125;&#125; 答案是否定，Java编译器不允许我们这样做，为什么呢？对于这个问题我们不妨从编译器的角度去考虑。因为List&lt;? extends Fruit&gt; flist它自身可以有多种含义： 123List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Fruit&gt;();List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Orange&gt;(); 当我们尝试add一个Apple的时候，flist可能指向new ArrayList&lt;Orange&gt;(); 当我们尝试add一个Orange的时候，flist可能指向new ArrayList&lt;Apple&gt;(); 当我们尝试add一个Fruit的时候，这个Fruit可以是任何类型的Fruit，而flist可能只想某种特定类型的Fruit，编译器无法识别所以会报错。 所以对于实现了&lt;? extends T&gt;的集合类只能将它视为Producer向外提供(get)元素，而不能作为Consumer来对外获取(add)元素。 如果我们要add元素应该怎么做呢？可以使用&lt;? super T&gt;： 123456789101112131415161718192021public class GenericWriting &#123; static List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); static List&lt;Fruit&gt; fruit = new ArrayList&lt;Fruit&gt;(); static &lt;T&gt; void writeExact(List&lt;T&gt; list, T item) &#123; list.add(item); &#125; static void f1() &#123; writeExact(apples, new Apple()); writeExact(fruit, new Apple()); &#125; static &lt;T&gt; void writeWithWildcard(List&lt;? super T&gt; list, T item) &#123; list.add(item) &#125; static void f2() &#123; writeWithWildcard(apples, new Apple()); writeWithWildcard(fruit, new Apple()); &#125; public static void main(String[] args) &#123; f1(); f2(); &#125;&#125; 这样我们可以往容器里面添加元素了，但是使用super的坏处是以后不能get容器里面的元素了，原因很简单，我们继续从编译器的角度考虑这个问题，对于List&lt;? super Apple&gt; list，它可以有下面几种含义： 123List&lt;? super Apple&gt; list = new ArrayList&lt;Apple&gt;();List&lt;? super Apple&gt; list = new ArrayList&lt;Fruit&gt;();List&lt;? super Apple&gt; list = new ArrayList&lt;Object&gt;(); 当我们尝试通过list来get一个Apple的时候，可能会get得到一个Fruit，这个Fruit可以是Orange等其他类型的Fruit。 根据上面的例子，我们可以总结出一条规律，”Producer Extends, Consumer Super”`： “Producer Extends” : 如果你需要一个只读List，用它来produce T，那么使用? extends T。 “Consumer Super” : 如果你需要一个只写List，用它来consume T，那么使用? super T。 如果需要同时读取以及写入，那么我们就不能使用通配符了。 如果阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样： 123456public class Collections &#123; public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123; for (int i=0; i&lt;src.size(); i++) dest.set(i, src.get(i)); &#125;&#125;","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java数据类型缓存池","slug":"数据类型缓存池","date":"2017-08-27T02:28:23.000Z","updated":"2018-08-25T06:53:10.199Z","comments":true,"path":"数据类型缓存池.html","link":"","permalink":"http://xiaoqinghua.site/数据类型缓存池.html","excerpt":"","text":"new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; 编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓存池如下： 12345boolean values true and falseall byte valuesshort values between -128 and 127int values between -128 and 127char in the range \\u0000 to \\u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓存池中的对象。 StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/数据类型缓存池.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 内部类","slug":"Java内部类","date":"2017-08-26T07:01:58.000Z","updated":"2018-08-24T07:42:24.335Z","comments":true,"path":"Java内部类.html","link":"","permalink":"http://xiaoqinghua.site/Java内部类.html","excerpt":"","text":"少啰嗦，先上代码123456789101112131415161718192021222324252627public class OuterClass &#123; private String name ; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; class InnerClass&#123; public InnerClass()&#123; name = \"chenssy\"; age = 23; &#125; &#125;&#125; 在这里InnerClass就是内部类，虽然没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。 为什么要使用内部类 为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承(二义性)的解决方案变得更加完整。 其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）： 1234567891、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。3、创建内部类对象的时刻并不依赖于外围类对象的创建。4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。 内部类基础 在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 1234567891011121314151617181920212223242526public class OuterClass &#123; private String name ; private int age; /**省略getter和setter方法**/ public class InnerClass&#123; public InnerClass()&#123; name = \"xiaoqinghua\"; age = 25; &#125; public void display()&#123; System.out.println(\"name：\" + getName() +\" ;age：\" + getAge()); &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.display(); &#125;&#125;--------------Output：name：xiaoqinghua ;age：25 在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。 其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类： OuterClass.InnerClass innerClass = outerClass.new InnerClass();。 同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。 1234567891011121314151617181920public class OuterClass &#123; public void display()&#123; System.out.println(\"OuterClass...\"); &#125; public class InnerClass&#123; public OuterClass getOuterClass()&#123; return OuterClass.this; &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.getOuterClass().display(); &#125;&#125;-------------Output:OuterClass... 到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。 在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。 成员内部类成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。 在成员内部类中要注意两点: 成员内部类中不能存在任何static的变量和方法 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类 12345678910111213141516171819202122232425262728293031public class OuterClass &#123; private String str; public void outerDisplay()&#123; System.out.println(\"outerClass...\"); &#125; public class InnerClass&#123; public void innerDisplay()&#123; //使用外围内的属性 str = \"xiaoqinghua...\"; System.out.println(str); //使用外围内的方法 outerDisplay(); &#125; &#125; /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */ public InnerClass getInnerClass()&#123; return new InnerClass(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.getInnerClass(); inner.innerDisplay(); &#125;&#125;--------------------xiaoqinghua...outerClass... 局部内部类有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。 定义在方法里： 12345678910111213141516171819public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation(\"xiaoqinghua\"); &#125;&#125; 定义在作用域内: 1234567891011121314151617181920212223242526public class Parcel6 &#123; private void internalTracking(boolean b)&#123; if(b)&#123; class TrackingSlip&#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip()&#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip(\"xiaoqinghua\"); String string = ts.getSlip(); &#125; &#125; public void track()&#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel6 parcel6 = new Parcel6(); parcel6.track(); &#125;&#125; 匿名内部类在做Swing编程中，我们经常使用这种方式来绑定事件 123456button2.addActionListener( new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"点击了按钮\"); &#125; &#125;); 我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子： 123456789101112131415161718192021222324public class OuterClass &#123; public InnerClass getInnerClass(final int num,String str2)&#123; return new InnerClass()&#123; int number = num + 3; public int getNumber()&#123; return number; &#125; &#125;; /* 注意：分号不能省 */ &#125; public static void main(String[] args) &#123; OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, \"xiaoqinghua\"); System.out.println(inner.getNumber()); &#125;&#125;interface InnerClass &#123; int getNumber();&#125;----------------Output:5 这里我们就需要看清几个地方 123456781、 匿名内部类是没有访问修饰符的。2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。 静态内部类static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖于外围类的。 它不能使用任何外围类的非static成员变量和方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class OuterClass &#123; private String sex; public static String name = \"chenssy\"; /** *静态内部类 */ static class InnerClass1&#123; /* 在静态内部类中可以存在静态成员 */ public static String _name1 = \"chenssy_static\"; public void display()&#123; /* * 静态内部类只能访问外围类的静态成员变量和方法 * 不能访问外围类的非静态成员变量和方法 */ System.out.println(\"OutClass name :\" + name); &#125; &#125; /** * 非静态内部类 */ class InnerClass2&#123; /* 非静态内部类中不能存在静态成员 */ public String _name2 = \"chenssy_inner\"; /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */ public void display()&#123; System.out.println(\"OuterClass name：\" + name); &#125; &#125; /** * @desc 外围类方法 * @author chenssy * @data 2013-10-25 * @return void */ public void display()&#123; /* 外围类访问静态内部类：内部类. */ System.out.println(InnerClass1._name1); /* 静态内部类 可以直接创建实例不需要依赖于外围类 */ new InnerClass1().display(); /* 非静态内部的创建需要依赖于外围类 */ OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2(); /* 方位非静态内部类的成员需要使用非静态内部类的实例 */ System.out.println(inner2._name2); inner2.display(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); outer.display(); &#125;&#125;----------------Output:chenssy_staticOutClass name :chenssychenssy_innerOuterClass name：chenssy 以上内容转载至：http://www.cnblogs.com/chenssy/ chenssy 大佬的博客 加一下料：重写和重载 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"String的那些事","slug":"再记String","date":"2017-08-25T02:28:23.000Z","updated":"2018-08-25T06:52:17.457Z","comments":true,"path":"再记String.html","link":"","permalink":"http://xiaoqinghua.site/再记String.html","excerpt":"","text":"String 的用法String类在 java.lang 包中，java 使用String类创建一个字符串变量，字符串变量属于对象。java 把String类声明的final类，不能有子类。String类对象创建后不能修改，由 0 或多个字符组成，包含在一对双引号之间，下面简单的熟悉一下其常用的 API： 1234567891011121314151617char charAt (int index) 返回index所指定的字符 String concat(String str) 将两字符串连接 boolean endsWith(String str) 测试字符串是否以str结尾 boolean equals(Object obj) 比较两对象 char[] getBytes 将字符串转换成字符数组返回 char[] getBytes(String str) 将指定的字符串转成制服数组返回 boolean startsWith(String str) 测试字符串是否以str开始 int length() 返回字符串的长度 String replace(char old ,char new) 将old用new替代 char[] toCharArray 将字符串转换成字符数组 String toLowerCase() 将字符串内的字符改写成小写 String toUpperCase() 将字符串内的字符改写成大写 String valueOf(Boolean b) 将布尔方法b的内容用字符串表示 String valueOf(char ch) 将字符ch的内容用字符串表示 String valueOf(int index) 将数字index的内容用字符串表示 String valueOf(long l) 将长整数字l的内容用字符串表示 String substring(int1,int2) 取出字符串内第int1位置到int2的字符串 1.构造方法 123456//直接初始化String str = \"abc\";//使用带参构造方法初始化char[] char = &#123;'a','b','c'&#125;;String str1 = new String(\"abc\");String str2 = new String(str);String str3 = new String(char); 2.求字符串长度和某一位置字符 123String str = new String(\"abcdef\");int strlength = str.length();//strlength = 7char ch = str.charAt(4);//ch = e 3.提取子串 用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数:1)public String substring(int beginIndex)//该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。 2)public String substring(int beginIndex, int endIndex)//该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。 123String str1 = new String(\"abcdef\");String str2 = str1.substring(2);//str2 = \"cdef\"String str3 = str1.substring(2,5);//str3 = \"cde\" 4.字符串比较 1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。 2)public int compareToIgnoreCase(String anotherString)//与compareTo方法相似，但忽略大小写。 3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。 4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。 123456String str1 = new String(\"abc\");String str2 = new String(\"ABC\");int a = str1.compareTo(str2);//a&gt;0int b = str1.compareToIgnoreCase(str2);//b=0boolean c = str1.equals(str2);//c=falseboolean d = str1.equalsIgnoreCase(str2);//d=true 5.字符串链接 public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于”+” 12String str = \"aa\".concat(\"bb\").concat(\"cc\");//相当于String str = \"aa\"+\"bb\"+\"cc\"; 6.字符串中单个字符查找 1)public int indexOf(int ch/String str)//用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。 2)public int indexOf(int ch/String str, int fromIndex)//改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。 3)public int lastIndexOf(int ch/String str)//该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。 4)public int lastIndexOf(int ch/String str, int fromIndex)//该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。 123456String str = \"I really miss you !\";int a = str.indexOf('a');//a = 4int b = str.indexOf(\"really\");//b = 2int c = str.indexOf(\"gg\",2);//c = -1int d = str.lastIndexOf('s');//d = 6int e = str.lastIndexOf('s',7);//e = 7 7.大小写转换 1)public String toLowerCase()//返回将当前字符串中所有字符转换成小写后的新串 2)public String toUpperCase()//返回将当前字符串中所有字符转换成大写后的新串 123String str = new String(\"abCD\");String str1 = str.toLowerCase();//str1 = \"abcd\"String str2 = str.toUpperCase();//str2 = \"ABCD\" 8.字符串中字符的替换 1)public String replace(char oldChar, char newChar)//用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。 2)public String replaceFirst(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。 3)public String replaceAll(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。 12345String str = \"asdzxcasd\";String str1 = str.replace('a','g');//str1 = \"gsdzxcgsd\"String str2 = str.replace(\"asd\",\"fgh\");//str2 = \"fghzxcfgh\"String str3 = str.replaceFirst(\"asd\",\"fgh\");//str3 = \"fghzxcasd\"String str4 = str.replaceAll(\"asd\",\"fgh\");//str4 = \"fghzxcfgh\" 9.其他方法 1)String trim()//截去字符串两端的空格，但对于中间的空格不处理。 1234String str = \" a bc \";String str1 = str.trim();int a = str.length();//a = 6int b = str1.length();//b = 4 2)boolean statWith(String prefix)或boolean endWith(String suffix)//用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。 123String str = \"abcdef\";boolean a = str.statWith(\"ab\");//a = trueboolean b = str.endWith(\"ef\");//b = true 3)contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。 123String str = \"abcdef\";str.contains(\"ab\");//truestr.contains(\"gh\");//false 4)String[] split(String str)//将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。 12String str = \"abc def ghi\";String[] str1 = str.split(\" \");//str1[0] = \"abc\";str1[1] = \"def\";str1[2] = \"ghi\"; 10.类型转换 字符串转基本类型:java.lang包中有Byte、Short、Integer、Float、Double类的调用方法： 123456789public static byte parseByte(String s)public static short parseShort(String s)public static short parseInt(String s)public static long parseLong(String s)public static float parseFloat(String s)public static double parseDouble(String s)int n = Integer.parseInt(\"12\");float f = Float.parseFloat(\"12.34\");double d = Double.parseDouble(\"1.124\"); 基本类型转字符串:String类中提供了String valueOf()放法，用作基本类型转换为字符串类型 1234567891011static String valueOf(char data[])static String valueOf(char data[], int offset, int count)static String valueOf(boolean b)static String valueOf(char c)static String valueOf(int i)static String valueOf(long l)static String valueOf(float f)static String valueOf(double d)//将char '8' 转换为int 8String str = String.valueOf('8');int num = Integer.parseInt(str); 进制转换:使用Long类中的方法得到整数之间的各种进制转换的方法： 1234Long.toBinaryString(long l)//二进制Long.toOctalString(long l)//八进制Long.toHexString(long l)//十六进制Long.toString(long l, int p)//p作为任意进制 String 的特性1、String是不可变类 这句话其实大家都很熟悉了，那么具体什么是不可变类呢？一般认为：当对象一旦创建完成后，在正常情况下，对象的状态不会因外界的改变而改变（对象的状态是指对象的属性，包括属性的类型及属性值） 首先看一个基本的例子： 12341 String s = \"abc\";2 System.out.println(\"s:\" + s); // 输出s:abc3 s = \"def\";4 System.out.println(\"s:\" + s); // 输出s:def 此时，初看上去，输出的结果变了，发现s的值发生了变化，那么这与上面的说法——String类是不可变类是否矛盾呢？答案是否定的，因为s只是指向堆内存中的引用，存储的是对象在堆中的地址，而非对象本身，s本身存储在栈内存中。 实际上，此时堆内存中依然存在着&quot;abc&quot;和&quot;def&quot;对象。对于&quot;abc&quot;对象本身而言，对象的状态是没有发生任何变化的。 那么为什么String类具有不可变性呢，显然，既然不可变说明String类中肯定没有提供对外可setters方法。接下来来具体看一下String类的定义。 下面是String类中主要属性的定义（Java 1.7源码）： 1234567891 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123;2 3 /** The value is used for character storage. */4 private final char value[];5 6 /** Cache the hash code for the string */7 private int hash; // Default to 08 9 &#125; 不可变的好处： 123456789101112131415161. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用 Program Creek : Why String is immutable in Java? 2、String, StringBuffer and StringBuilder 12345678910可变性String 不可变StringBuffer 和 StringBuilder 可变线程安全String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StackOverflow : String, StringBuffer, and StringBuilder \b举几个🌰🌰1: 1234567String a = \"Hello World!\"; String b = \"Hello World!\"; String c = new String(\"Hello World!\"); String d = \"Hello\"+\" \"+\"World!\";System.out.println(a == b);//trueSystem.out.println(a == c);//falseSystem.out.println(a == d);//true 我们应该明白： 首先String不属于8种基本数据类型，String是一个对象。 因为对象的默认值是null，所以 String 的默认值也是null；但它又是一种特殊的对象，有其它对象没有的一些特性。 在这里，我们先不谈堆，也不谈栈，只先简单引入常量池这个简单的概念。 常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。 Java会确保一个字符串常量只有一个拷贝。 因为例子中的a和b都是字符串常量，它们在编译期就被确定了，所以a==b为true；而&quot;Hello&quot;和&quot; &quot;以及&quot;World!&quot;也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以d也同样在编译期就被解析为一个字符串常量，所以d也是常量池中&quot;Hello World!&quot;的一个引用。所以我们得出a==b==d 用new String()创建的字符串不是常量,不能在编译期就确定，所以new String()创建的字符串不放入常量池中，它们有自己的地址空间 🌰2: 123456String a = \"HelloWorld\"; String b = new String(\"HelloWorld\"); String c = \"Hello\"+ new String(\"World\"); System.out.println( a == b );//falseSystem.out.println( a == c );//falseSystem.out.println( b == c );//false a还是常量池中”HelloWorld”的引用，b因为无法在编译期确定，所以是运行时创建的新对象”HelloWorld”的引用，c因为有后半部分new String(“World”)所以也无法在编译期确定，所以也是一个新创建对象”HelloWorld”的引用，明白了这些也就知道为何得出此结果了。 12String.intern()：再补充介绍一点：存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用，看例3就清楚了。 🌰3: 12345678910String a = \"Hello\"; String b = new String(\"Hello\"); String c = new String(\"Hello\"); System.out.println( a == b );//falseSystem.out.println( “**********” ); b.intern(); c = c.intern(); //把常量池中\"Hello\"的引用赋给c System.out.println( a == b);//false虽然执行了b.intern()但没有赋值给bSystem.out.println( a == b.intern() );//true System.out.println( a == c ); //true 🌰4: 关于equals()和==:equals() 是比较两个对象的值是否相等，这个对于 String 简单来说就是比较两字符串的 Unicode 序列是否相当，如果相等返回 true;而 == 是比较两字符串的地址是否相同，也就是是否是同一个字符串的引用。 🌰5: String是不可变的:这一说又要说很多，大家只要知道String的实例一旦生成就不会再改变了，比如说： 1String str = ”aa”+”bb”+” “+”cc”; 就是有4个字符串常量，首先”aa”和”bb”生成了”aabb”存在内存中，后”aabb”又和” “ 生成 ”aabb “存在内存中，最后又和生成了”aabb cc”，并把这个字符串的地址赋给了str,就是因为String的“不可变”产生了很多临时变量，这也就是为什么建议用StringBuffer的原因了。 来一个反射改变String的🌰12345678910111213141516171819 1 public static void stringReflection() throws Exception &#123; 2 3 String s = \"Hello World\"; 4 5 System.out.println(\"s = \" + s); //Hello World 6 7 //获取String类中的value字段 8 Field valueField = String.class.getDeclaredField(\"value\"); 9 10 //改变value属性的访问权限11 valueField.setAccessible(true);12 13 char[] value = (char[]) valueField.get(s);14 15 //改变value所引用的数组中的第5个字符16 value[5] = '_';17 18 System.out.println(\"s = \" + s); //Hello_World19 &#125; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/再记String.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 类型转换","slug":"Java类型转换","date":"2017-08-20T12:28:23.000Z","updated":"2018-08-24T07:42:07.654Z","comments":true,"path":"Java类型转换.html","link":"","permalink":"http://xiaoqinghua.site/Java类型转换.html","excerpt":"","text":"类型转换Java 语言是一种强类型的语言。强类型的语言有以下几个要求： 变量或常量必须有类型:要求声明变量或常量时必须声明类型，而且只能在声明以后才能使用。 赋值时类型必须一致:值的类型必须和变量或常量的类型完全一致。 运算时类型必须一致:参与运算的数据类型必须一致才能运算。 但是在实际的使用中，经常需要在不同类型的值之间进行操作，这就需要一种新的语法来适应这种需要，这个语法就是数据类型转换。 在数值处理这部分，计算机和现实的逻辑不太一样，对于现实来说，1和 1.0 没有什么区别，但是对于计算机来说，1 是整数类型，而 1.0 是小数类型，其在内存中的存储方式以及占用的空间都不一样，所以类型转换在计算机内部是必须的。 Java 语言中的数据类型转换有两种： 自动类型转换:编译器自动完成类型转换，不需要在程序中编写代码。 强制类型转换:强制编译器进行类型转换，必须在程序中编写代码。 由于基本数据类型中 boolean 类型不是数字型，所以基本数据类型的转换是出了 boolean 类型以外的其它 7 种类型之间的转换。下面来具体介绍两种类型转换的规则、适用场合以及使用时需要注意的问题。 自动类型转换自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM 自动完成。 转换规则：从存储范围小的类型到存储范围大的类型。具体规则为：byte→short(char)→int→long→float→double 也就是说 byte 类型的变量可以自动转换为 short 类型，示例代码： 12byte b = 10;short sh = b;这里在赋值时，JVM 首先将 b 的值转换为 short 类型，然后再赋值给 sh。 在类型转换时可以跳跃。示例代码： 12byte b1 = 100;int n = b1; 注意问题:在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。 强制类型转换强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。 转换规则:从存储范围大的类型到存储范围小的类型。 具体规则为：double→float→long→int→short(char)→byte 语法格式为：(转换到的类型)需要转换的值 示例代码： 12double d = 3.10;int n = (int)d; 这里将 double 类型的变量 d 强制转换成 int 类型，然后赋值给变量 n。需要说明的是小数强制转换为整数，采用的是去 1 法，也就是无条件的舍弃小数点的所有数字，则以上转换出的结果是 3。整数强制转换为整数时取数字的低位，例如 int 类型的变量转换为 byte 类型时，则只去 int 类型的低 8 位(也就是最后一个字节)的值。示例代码： 1234int n = 123;byte b = (byte)n;int m = 1234;byte b1 = (byte)m; 则 b 的值还是 123，而 b1 的值为-46。b1 的计算方法如下：m 的值转换为二进制是10011010010，取该数字低8位的值作为b1的值，则b1的二进制值是11010010，按照机器数的规定，最高位是符号位，1代表负数，在计算机中负数存储的是补码，则该负数的原码是 10101110，该值就是十进制的-46。注意问题:强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 数据类型","slug":"Java基本数据类型","date":"2017-08-19T03:58:52.000Z","updated":"2018-08-25T06:50:28.811Z","comments":true,"path":"Java基本数据类型.html","link":"","permalink":"http://xiaoqinghua.site/Java基本数据类型.html","excerpt":"","text":"基本类型，或者叫做内置类型，是JAVA中不同于类的特殊类型。它们是我们编程中使用最频繁的类型。java是一种强类型语言，第一次申明变量必须说明数据类型（Java 9 之后的 var类型推断，了解一下），第一次变量赋值称为变量的初始化。 1. Java的简单类型及其封装器类Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下： 123456789101112131415byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。char：16位，存储Unicode码，用单引号赋值。short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。boolean：只有true和false两个取值。 对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如： 12345678910111213141516171819基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE 注意：float、double 两种类型的最小值与 Float.MIN_VALUE、 Double.MIN_VALUE 的值并不相同，实际上 Float.MIN_VALUE 和 Double.MIN_VALUE 分别指的是 float 和 double 类型所能表示的最小正数。也就是说存在这样一种情况，0 到 ±Float.MIN_VALUE 之间的值 float 类型无法表示，0 到 ±Double.MIN_VALUE 之间的值 double 类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。 Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314。 Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。 基本类型的优势：数据存储相对简单，运算效率比较高包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想 2.Java中的常量十六进制整型常量：以十六进制表示时，需以0x或0X开头，如0xff,0X9A。 八进制整型常量：八进制必须以0开头，如0123，034。 长整型：长整型必须以L作结尾，如9L,342L。 浮点数常量：由于小数常量的默认类型是double型，所以float类型的后面一定要加f(F)。同样带小数的变量默认为double类型。 如：float f; 12//必须声明ff = 1.3f; 字符常量：字符型常量需用两个单引号括起来（注意字符串常量是用两个双引号括起来）。Java中的字符占两个字节(因为字符是char，一个\b char 占两个字节，16位)。一些常用的转义字符： 12345678910111213\\r表示接受键盘输入，相当于按下了回车键；\\n表示换行；\\t表示制表符，相当于Table键；\\b表示退格键，相当于Back Space键；\\&apos;表示单引号；\\&apos;&apos;表示双引号；\\\\表示一个斜杠\\。 3. 数据类型之间的转换1、简单类型数据间的转换,有两种方式:自动转换和强制转换,通常发生在表达式中或方法的参数传递时。 自动转换: 具体地讲,当一个较”小”数据与一个较”大”的数据一起运算时,系统将自动将”小”数据转换成”大”数据,再进行运算。而在方法调用时,实际参数较”小”,而被调用的方法的形式参数数据又较”大”时(若有匹配的,当然会直接调用匹配的方法),系统也将自动将”小”数据转换成”大”数据,再进行方法的调用,自然,对于多个同名的重载方法,会转换成最”接近”的”大”数据并进行调用。这些类型由”小”到”大”分别为 (byte，short，char)--int--long--float—double。这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小。 12345678910111213①下面的语句可以在Java中直接通过：byte b;int i=b; long l=b; float f=b; double d=b;②如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值，例如char c=&apos;c&apos;; int i=c;System.out.println(&quot;output:&quot;+i);输出：output:99;③对于byte,short,char三种类型而言，他们是平级的，因此不能相互自动转换，可以使用下述的强制类型转换。short i=99 ; char c=(char)i; System.out.println(&quot;output:&quot;+c);输出：output:c; 强制转换: 将”大”数据转换为”小”数据时，你可以使用强制类型转换。即你必须采用下面这种语句格式： int n=(int)3.14159/2;可以想象，这种转换肯定可能会导致溢出或精度的下降。 2、表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。 1234567①所有的byte,short,char型的值将被提升为int型；②如果有一个操作数是long型，计算结果是long型；③如果有一个操作数是float型，计算结果是float型；④如果有一个操作数是double型，计算结果是double型； 例， byte b; b=3; b=(byte)(b*3);//必须声明byte。ps: 运算才会提升类型，b=3不会把 byte b 变成 int b,而b=b*3会提升； 3、包装类过渡类型转换 一般情况下，我们首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。例如： 123456789101112131415①当希望把float型转换为double型时：float f1 = 100.00f;Float F1 = new Float(f1);double d1 = F1.doubleValue(); //F1.doubleValue()为Float类的返回double值型的方法②当希望把double型转换为int型时：double d1 = 100.00;Double D1 = new Double(d1);int i1 = D1.intValue(); 简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value) 而在各个包装类中，总有形为××Value()的方法，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。 4、字符串与其它类型间的转换 其它类型向字符串的转换 12345①调用类的串转换方法: X.toString();②自动转换: X + &quot;&quot;;③使用 String 的方法: String.volueOf(X); 字符串作为值,向其它类型的转换 123456789101112131415161718192021①先转换成相应的封装器实例,再调用对应的方法转换成其它类型例如，字符中&quot;32.1&quot;转换`double`型的值的格式为:`new Float(&quot;32.1&quot;).doubleValue()`。也可以用:`Double.valueOf(&quot;32.1&quot;).doubleValue()`②静态 parseXXX 方法String s = &quot;1&quot;;byte b = Byte.parseByte( s );short t = Short.parseShort( s );int i = Integer.parseInt( s );long l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s );③Character 的 getNumericValue(char ch)方法 5、Date类与其它数据类型的相互转换 整型和Date类之间并不存在直接的对应关系，只是你可以使用int型为分别表示年、月、日、时、分、秒，这样就在两者之间建立了一个对应关系，在作这种转换时，你可以使用Date类构造函数的三种形式： 12345①Date(int year, int month, int date)：以int型表示年、月、日②Date(int year, int month, int date, int hrs, int min)：以int型表示年、月、日、时、分③Date(int year, int month, int date, int hrs, int min, int sec)：以int型表示年、月、日、时、分、秒 在长整型和Date类之间有一个很有趣的对应关系，就是将一个时间表示为距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。对于这种对应关系，Date类也有其相应的构造函数：Date(long date)。 获取Date类中的年、月、日、时、分、秒以及星期你可以使用Date类的getYear()、getMonth()、getDate()、getHours()、getMinutes()、getSeconds()、getDay()方法，你也可以将其理解为将Date类转换成int。 而Date类的getTime()方法可以得到我们前面所说的一个时间对应的长整型数，与包装类一样，Date类也有一个toString()方法可以将其转换为String类。 有时我们希望得到Date的特定格式，例如20020324，我们可以使用以下方法: 1234567891011121314151617181920212223242526272829import java.text.SimpleDateFormat;import java.util.*;java.util.Date date = new java.util.Date(); //如果希望得到YYYYMMDD的格式SimpleDateFormat sy1 = new SimpleDateFormat(&quot;yyyyMMDD&quot;);String dateFormat = sy1.format(date);//如果希望分开得到年，月，日SimpleDateFormat sy = new SimpleDateFormat(&quot;yyyy&quot;);SimpleDateFormat sm = new SimpleDateFormat(&quot;MM&quot;);SimpleDateFormat sd = new SimpleDateFormat(&quot;dd&quot;);String syear = sy.format(date);String smon = sm.format(date);String sday = sd.format(date); 总结：只有boolean不参与数据类型的转换 123456789101112131.自动类型的转换：a.常数在表数范围内是能够自动类型转换的b.数据范围小的能够自动向数据类型大的转换（注意特例）int 到 float，long 到 float，long 到 double 同样可以自动转换的，只不过会丢失精度，因为存储结构不同c.引用类型能够自动转换为父类d.基本类型和它们包装类型是能够互相转换的2.强制类型转换：用圆括号括起来目标类型，置于变量前 4.Java引用类型Java有 5 种引用类型（对象类型）：类 接口 数组 枚举 标注 引用类型：底层结构和基本类型差别较大 JVM的内存空间： 1234567891011121314151617（1）Heap 堆空间：分配对象 `new Student（）`（2）Stack 栈空间：临时变量 `Student stu`（3）Code 代码区 ：类的定义，静态资源 `Student.class`eg：Student stu = new Student（）； //new 在内存的堆空间创建对象stu.study(); //把对象的地址赋给stu引用变量上例实现步骤：a.JVM 加载 `Student.class` 到Code区b.`new Student()`在堆空间分配空间并创建一个Student实例c.将此实例的地址赋值给引用`stu`栈空间 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/Java基本数据类型.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Redis基础及高级特性与性能调优","slug":"Redis基础及高级特性与性能调优","date":"2017-07-23T14:35:52.000Z","updated":"2018-08-24T07:45:04.148Z","comments":true,"path":"Redis基础及高级特性与性能调优.html","link":"","permalink":"http://xiaoqinghua.site/Redis基础及高级特性与性能调优.html","excerpt":"","text":"本文将从 Redis 的基本特性入手，通过讲述 Redis 的数据结构和主要命令对 Redis 的基本性能进行直观的介绍。之后概览 Redis 提供的高级能力，并在部署、维护、性能调优等多个方面进行更深入的介绍和指导。 本文适合使用 Redis 的普通开发人员，以及对 Redis 进行选型、架构设计和性能调优的架构设计人员。 目录 概述 Redis 的数据结构和相关常用命令 数据持久化 内存管理和数据淘汰机制 Pipelining 事务与 Scripting Redis 性能调优 主从复制与集群分片 Redis Java 客户端的选择 概述Redis 是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。Redis 支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图(Bitmap)、HyperLogLogs等。Redis 具备 LRU(Least Recently Use)淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过 Redis Sentinel 实现的高可用方案，同时还支持通过 Redis Cluster 实现的数据自动分片能力。 Redis 的主要功能都是基于\b单线程模型\b实现，也就是说 Redis 使用一个线程来服务所有的客户端请求，同时 Redis 采用了\b非阻塞式IO，并精细地优化各种命令\b的算法时间复杂度，这些信息意味着： Redis 是线程安全的 (因为只有一个线程)，其所有的操作都是原子的，不会因为\b并发产生数据异常 Redis 的速度非常快（因为使用的是非阻塞式IO，且大部分命令的算法时间复杂度都是O(1)） 使用高\b耗时的 \bRedis 命令是很危险的，会占用唯一的线程的大量处理时间，导致所有请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用） Redis 的数据结构和相关常用命令KeyRedis 采用Key-Value型的基本数据结构，任何二进制序列都可以作为 Redis 的 Key 使用（例如普通的字符串或一张\b JPEG 图片）关于 Key 的一些注意事项\b: 不要使用过长的 Key。\b例如使用一个1024字节的 key \b就不是一个好主意，不仅会消耗更多的内存，还会导致查询的效率降低 Key 短到缺失了可读性也是不好的，例如&quot;u1000flw&quot;比起&quot;user:1000:followers&quot;来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦 最好使用统一规范来设计 Key ，比如&quot;object-type:id:attr&quot;，以\b这一规范设计出的 Key 可能是&quot;user:1000&quot;或者&quot;comment:1234:reply-to&quot; Redis 允许的最大 Key 长度是 512MB (对 Value 的长度限制也是 512MB) StringString 是 Redis 的基础数据类型，Redis 没有 Int、Float、Boolean等数据类型的概念，所有的基本类型在 Redis 中都以 \bString 体现 与\b String 相关的常用命令： \bSET： 为一个 key 设置 \bvalue，可以配合EX/PX参数指定 key 的有效期，\b通过NX/XX参数针对 key 是否存在的情况进行分区操作，时间复杂度O(1) GET： 获取某个 key 对用的 value，时间复杂度为O(1) GETSET： 为一个 key 设置 value，并返回该 key 的原 value，时间复杂度O(1) MSET： 为多个 key 设置 value，时间复杂度为O(N) MSETNX： 同 MSET，\b\b如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度O(N) MGET： 获取\b\b\b多个 key 对应的 value ，时间复杂度O(N) 上文提到过，Redis 的基本数据类型只有 String，但 Redis可以把 String 作为整形或者浮点型数字来使用，主要体现在INCR、DECR类的命令上： INCR：将 key 对应的 value 值自增1，并返回自增后的值。只对可以转换为整形的 String 数据起作用。时间复杂度O(1) INCRBY： \b将 key 对应的 value 值自增指定的整形数值，并返回自增之后的值。只对可以转换为整形的 String 数据起作用。时间复杂度为O(1) DECR/DECRBY：同INCR/INCRBY，自增改为自减 INCR/DECR系列命令要求操作的 value 类型为 String，并可以转换为64位带符号的整形数字，否则会返回错误。也就是说，进行INCR/DECR系列命令的 value，\b必须在[-2^63~2^63-1]范围内 前文提到过，Redis 采用单线程模型，天然是线程安全的，这使得INCR/DECR命令可以非常便利的实现高并发场景\b下的精确控制。 例1：库存控制在高并发场景下实现\b库存余量的精准校验，确保不出现超卖的情况\b设置库存总量： 1SET inv:remain &quot;100&quot; 库存扣减 + 余量校验 1DECR inv:remain 当DECR\b命令返回值大于等于0时，说明库存余量通过校验，如果返回小于0的值，则说明库存已经耗尽。 假设同时有300个并发请求进行库存扣减，Redis 能够确保这300个请求分别得到99 ~ -200的返回值，每个请求得到的返回值都是唯一的，绝对不会出现两个请求得到一样的返回的情况。 例2：自增序列生成实现类似于RDBMS的Sequence功能，生成一系列唯一序列号 设置序列起始值： 1SET sequence &quot;10000&quot; 获取一个序列值： 1INCR sequence 直接将返回值作为序列使用即可。 获取一批（如100个）序列值： 1INCRBY sequence 100 假设返回值为N，那么[N - 99 ~ N]的数值都是可以用的序列值。 当多个客户端同时向 Redis 申请自增序列时，Redis 能够确保每个客户端得到的序列值或序列范围都是全局唯一的。绝对不会出现不同客户端得到了重复的序列值的情况。 ListRedis 的 list 是链表的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在 List 的连段执行插入元素和弹出元素的操作。虽然 List 也支持在特定index上插入和读取元素的功能，但其时间复杂度较高(O(N))，应小心使用。 与 List 相关的常用命令： LPUSH： 向指定的 List 的左侧（即头部）插入1个或多个元素，返回插入后的 List 长度。时间复杂度O(N), N 为插入元素的数量 RPUSH：同 LPUSH，向 List 的右侧（即尾部）插入一个或多个元素 LPOP：从指定的 List 的左侧（即头部）移除一个元素并返回，时间复杂度O(1) RPOP：同 LPOP ，从指定的 List 的右侧（即尾部）移除一个元素并返回 LPUSHX/RPUSHX：与 LPUSH/RPUSH 类似，区别在于，LPUSHX/RPUSHX 操作的 key 如果不存在，则不会进行任何操作 LLEN：返回指定的 List 长度，时间复杂度O(1) LRANGE：返回指定 List 中指定范围的元素 （双端包含，即 LRANGE key 0 10 会返回10个元素），时间复杂度O(N)。应尽可能控制以此获取的元素数量，一次获取过大范围的 List 元素会导致延迟，同时对长度不可预知的 List ，避免使用 LRANGE key 0 -1这样的完整便利操作 应谨慎使用的 List 相关命令： LINDEX：返回指定 List 指定 index 上的元素，如果 index 越界，返回 nil。index 数值是回环的，即 -1 代表 List 最后一个位置，-2 代表 List 倒数第二个位置。时间复杂度O(N) LSET：将指定 List 指定 index 上的元素设置为 value，如果 index 越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1) LINSERT：向指定 List 中指定元素之前/之后插入一个新元素，并返回操作后的 List 长度。如果指定的元素不存在，返回 -1。如果指定 key 不存在，不会进行任何操作，时间复杂度O(N) 由于 Redis 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。 换句话说，Redis 的 List 实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用 Redis 的 List 数据结构。 为了更好支持队列的特性，Redis 还提供了一系列阻塞式的操作命令，如BLPOP/BRPOP等，能够实现类似于BlockingQueue的能力，即在 List 为空时，阻塞该连接，直到 List 中有对象可以出队时再返回。 HashHash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。Hash的优点包括： 可以实现二元查找，如”查找ID为1000的用户的年龄” 比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗 当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令 与Hash相关的常用命令： HSET：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1) HGET：返回指定Hash中field字段的值，时间复杂度O(1) HMSET/HMGET：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量 HSETNX：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1) HEXISTS：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1) HDEL：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量 HINCRBY：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1) 应谨慎使用的Hash相关命令： HGETALL：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N) HKEYS/HVALS：返回指定Hash中所有的field/value，时间复杂度O(N) 上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关，对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历； SetRedis Set是无序的，不可重复的String集合。 与Set相关的常用命令： SADD：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数 SREM：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数 SRANDMEMBER：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数 SPOP：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数 SCARD：返回指定Set中的member个数，时间复杂度O(1) SISMEMBER：判断指定的value是否存在于指定Set中，时间复杂度O(1) SMOVE：将指定member从一个Set移至另一个Set 慎用的Set相关命令： SMEMBERS：返回指定Hash中所有的member，时间复杂度O(N) SUNION/SUNIONSTORE：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 SINTER/SINTERSTORE：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 SDIFF/SDIFFSTORE：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。可以考虑通过SSCAN命令遍历获取相关Set的全部member，如果需要做并集/交集/差集计算，可以在客户端进行，或在不服务实时查询请求的Slave上进行。 Sorted SetRedis Sorted Set是有序的、不可重复的String集合。Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。如果多个member拥有相同的score，则以字典序进行升序排序。 Sorted Set非常适合用于实现排名。 Sorted Set的主要命令： ZADD：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量 ZREM：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量 ZCOUNT：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N)) ZCARD：返回指定Sorted Set中的member数量，时间复杂度O(1) ZSCORE：返回指定Sorted Set中指定member的score，时间复杂度O(1) ZRANK/ZREVRANK：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N)) ZINCRBY：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N)) 慎用的Sorted Set相关命令： ZRANGE/ZREVRANGE：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数 ZRANGEBYSCORE/ZREVRANGEBYSCORE：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M) ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M) 上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。可以通过ZSCAN命令来进行游标式的遍历，或通过LIMIT参数来限制返回member的数量（适用于ZRANGEBYSCORE和ZREVRANGEBYSCORE命令），以实现游标式的遍历。 Bitmap和HyperLogLogRedis的这两种数据结构相较之前的并不常用，在本文中只做简要介绍，如想要详细了解这两种数据结构与其相关的命令； Bitmap在Redis中不是一种实际的数据类型，而是一种将String作为Bitmap使用的方法。可以理解为将String转换为bit数组。使用Bitmap来存储true/false类型的简单数据极为节省空间。 HyperLogLogs是一种主要用于数量统计的数据结构，它和Set类似，维护一个不可重复的String集合，但是HyperLogLogs并不维护具体的member内容，只维护member的个数。也就是说，HyperLogLogs只能用于计算一个集合中不重复的元素数量，所以它比Set要节省很多内存空间。 其他常用命令 EXISTS：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1) DEL：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量 EXPIRE/PEXPIRE：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1) TTL/PTTL：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1) RENAME/RENAMENX：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1) TYPE：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1) CONFIG GET：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1) CONFIG SET：为Redis某个配置项设置新值，时间复杂度O(1) CONFIG REWRITE：让Redis重新加载redis.conf中的配置 数据持久化Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。 必须使用数据持久化吗？Redis的数据持久化机制是可以关闭的。如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。但通常来说，仍然建议至少开启RDB方式的数据持久化，因为： RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成 Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快 现在硬盘那么大，真的不缺那一点地方 RDB采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。可以在配置文件中配置Redis进行快照保存的时机： 1save [secends] [changes] 意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如： 1save 60 100 会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。可以配置多条save指令，让Redis执行多级的快照保存策略。Redis默认开启RDB快照，默认的RDB策略如下： 123save 900 1save 300 10save 60 10000 也可以通过BGSAVE命令手工触发RDB快照保存。 RDB的优点： 对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。 每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。 使用RDB文件进行数据恢复比使用AOF要快很多。 RDB的缺点： 快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。 如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。 AOF采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。 AOF默认是关闭的，如要开启，进行如下配置： 1appendonly yes AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定： appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快 appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢 appendfsync everysec：折中的做法，交由后台线程每秒fsync一次 随着AOF不断地记录写操作日志，必定会出现一些无用的日志，例如某个时间点执行了命令SET key1 “abc”，在之后某个时间点又执行了SET key1 “bcd”，那么第一条命令很显然是没有用的。大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。AOF rewrite可以通过BGREWRITEAOF命令触发，也可以配置Redis定期自动进行： 12auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。 AOF的优点： 最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。 AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。 AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。 AOF的缺点： AOF文件通常比RDB文件更大 性能消耗比RDB高 数据恢复速度比RDB慢 内存管理与数据淘汰机制最大内存设置默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。 在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。 通过如下配置控制Redis使用的最大内存： 1maxmemory 100mb 在内存占用达到maxmemory后，再向Redis写入数据时，Redis会： 根据配置的数据淘汰策略尝试淘汰数据，释放空间 如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行 在为Redis设置maxmemory时，需要注意： 如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间，如果maxmemory过于接近主机的可用内存，导致数据同步时内存不足。所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。 数据淘汰机制Redis提供了5种数据淘汰策略： volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰 volatile-random：随机淘汰数据，只淘汰设定了有效期的key allkeys-random：随机淘汰数据，所有的key都可以被淘汰 volatile-ttl：淘汰剩余有效期最短的key 最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。 一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。 配置方法： 1maxmemory-policy volatile-lru #默认是noeviction，即不进行数据淘汰 PipelinlingPipelinlingRedis提供许多批量操作的命令，如MSET/MGET/HMSET/HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的，但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。 然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如： 123SET a &quot;abc&quot;INCR bHSET c name &quot;hi&quot; 此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。使用pipelining时，只需要从客户端一次向Redis发送多条命令（以\\r\\n）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如： 1234$ (printf &quot;PING\\r\\nPING\\r\\nPING\\r\\n&quot;; sleep 1) | nc localhost 6379+PONG+PONG+PONG 大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。 Pipelining的局限性Pipelining只能用于执行连续且无相关性的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。 通过Scripting功能，可以规避这一局限性 事务与ScriptingPipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。 比如获取当前累计的PV数并将其清0 1234&gt; GET vCount12384&gt; SET vCount 0OK 如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。 Redis的事务可以确保复数命令执行时的原子性。也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。 通过MULTI和EXEC命令来把这两个命令加入一个事务中： 123456789&gt; MULTIOK&gt; GET vCountQUEUED&gt; SET vCount 0QUEUED&gt; EXEC1) 123842) OK Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。 可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。 需要注意的是，Redis事务不支持回滚：如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误，2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。 通过事务实现CASRedis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。 假设要实现将某个商品的状态改为已售： 12if(exec(HGET stock:1001 state) == &quot;in stock&quot;) exec(HSET stock:1001 state &quot;sold&quot;); 这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。 使用WATCH命令和事务可以解决这一问题： 123456exec(WATCH stock:1001);if(exec(HGET stock:1001 state) == &quot;in stock&quot;) &#123; exec(MULTI); exec(HSET stock:1001 state &quot;sold&quot;); exec(EXEC);&#125; WATCH的机制是：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。 Scripting通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读/写交互放在服务端进行，避免过多的数据交互，提升性能。 Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。 Redis性能调优尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。 针对Redis的性能优化，主要从下面几个层面入手： 最初的也是最重要的，确保没有让Redis执行耗时长的命令 使用pipelining将连续执行的命令组合执行 操作系统的Transparent huge pages功能必须关闭： 1echo never &gt; /sys/kernel/mm/transparent_hugepage/enable 如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。 检查数据持久化策略 考虑引入读写分离机制 长耗时命令Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在文本和官方文档中均对每个命令的时间复杂度有说明。 通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。 避免在使用这些O(N)命令时发生问题主要有几个办法： 不要把List当做列表使用，仅当做队列来使用 通过机制严格控制Hash、Set、Sorted Set的大小 可能的话，将排序、并集、交集等操作放在客户端执行 绝对禁止使用KEYS命令 避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历 Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。 Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个： 12slowlog-log-slower-than xxxms #执行时间慢于xxx毫秒的命令计入Slow Logslowlog-max-len xxx #Slow Log的长度，即最大纪录多少条Slow Log 使用SLOWLOG GET [number]命令，可以输出最近进入Slow Log的number条命令。使用SLOWLOG RESET命令，可以重置Slow Log 网络引发的延迟 尽可能使用长连接或连接池，避免频繁创建销毁连接 客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节 数据持久化引发的延迟Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略： AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响 AOF + fsync every second是比较好的折中方案，每秒fsync一次 AOF + fsync never会提供AOF持久化方案下的最优性能 使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置 每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟 1Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。 1可以通过INFO命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒） Swap引发的延迟当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。 /proc//smaps文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。 数据淘汰引发的延迟当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。 引入读写分离机制Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。 主从复制与集群分片主从复制Redis支持一主多从的主从复制架构。一个Master实例负责处理所有的写请求，Master将写操作同步至所有Slave。借助Redis的主从复制，可以实现读写分离和高可用： 实时性要求不是特别高的读请求，可以在Slave上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的Redis命令，可以专门规划出1个或几个Slave用于服务这些统计任务 借助Redis Sentinel可以实现高可用，当Master crash后，Redis Sentinel能够自动将一个Slave晋升为Master，继续提供服务 启用主从复制非常简单，只需要配置多个Redis实例，在作为Slave的Redis实例中配置： 1slaveof 192.168.1.1 6379 #指定Master的IP和端口 当Slave启动后，会从Master进行一次冷启动数据同步，由Master触发BGSAVE生成RDB文件推送给Slave进行导入，导入完成后Master再将增量数据通过Redis Protocol同步给Slave。之后主从之间的数据便一直以Redis Protocol进行同步 使用Sentinel做自动failoverRedis的主从复制功能本身只是做数据同步，并不提供监控和自动failover能力，要通过主从复制功能来实现Redis的高可用，还需要引入一个组件：Redis Sentinel Redis Sentinel是Redis官方开发的监控组件，可以监控Redis实例的状态，通过Master节点自动发现Slave节点，并在监测到Master节点失效时选举出一个新的Master，并向所有Redis实例推送新的主从配置。 Redis Sentinel需要至少部署3个实例才能形成选举关系。 关键配置： 1234sentinel monitor mymaster 127.0.0.1 6379 2 #Master实例的IP、端口，以及选举需要的赞成票数sentinel down-after-milliseconds mymaster 60000 #多长时间没有响应视为Master失效sentinel failover-timeout mymaster 180000 #两次failover尝试间的间隔时长sentinel parallel-syncs mymaster 1 #如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用 另外需要注意的是，Redis Sentinel实现的自动failover不是在同一个IP和端口上完成的，也就是说自动failover产生的新Master提供服务的IP和端口与之前的Master是不一样的，所以要实现HA，还要求客户端必须支持Sentinel，能够与Sentinel交互获得新Master的信息才行。 集群分片为何要做集群分片： Redis中存储的数据量大，一台主机的物理内存已经无法容纳 Redis的写请求并发量大，一个Redis实例以无法承载 当上述两个问题出现时，就必须要对Redis进行分片了。Redis的分片方案有很多种，例如很多Redis的客户端都自行实现了分片功能，也有向Twemproxy这样的以代理方式实现的Redis分片方案。然而首选的方案还应该是Redis官方在3.0版本中推出的Redis Cluster分片方案。 本文不会对Redis Cluster的具体安装和部署细节进行介绍，重点介绍Redis Cluster带来的好处与弊端。 Redis Cluster的能力 能够自动将数据分散在多个节点上 当访问的key不在当前分片上时，能够自动将请求转发至正确的分片 当集群中部分节点失效时仍能提供服务 其中第三点是基于主从复制来实现的，Redis Cluster的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致，唯一的区别是省去了Redis Sentinel这一额外的组件，由Redis Cluster负责进行一个分片内部的节点监控和自动failover。 Redis Cluster分片原理Redis Cluster中共有16384个hash slot，Redis会计算每个key的CRC16，将结果与16384取模，来决定该key存储在哪一个hash slot中，同时需要指定Redis Cluster中每个数据分片负责的Slot数。Slot的分配在任何时间点都可以进行重新分配。 客户端在对key进行读写操作时，可以连接Cluster中的任意一个分片，如果操作的key不在此分片负责的Slot范围内，Redis Cluster会自动将请求重定向到正确的分片上。 hash tags在基础的分片原则上，Redis还支持hash tags功能，以hash tags要求的格式明明的key，将会确保进入同一个Slot中。例如：{uiv}user:1000和{uiv}user:1001拥有同样的hash tag {uiv}，会保存在同一个Slot中。 使用Redis Cluster时，pipelining、事务和LUA Script功能涉及的key必须在同一个数据分片上，否则将会返回错误。如要在Redis Cluster中使用上述功能，就必须通过hash tags来确保一个pipeline或一个事务中操作的所有key都位于同一个Slot中。 1有一些客户端（如Redisson）实现了集群化的pipelining操作，可以自动将一个pipeline里的命令按key所在的分片进行分组，分别发到不同的分片上执行。但是Redis不支持跨分片的事务，事务和LUA Script还是必须遵循所有key在一个分片上的规则要求。 主从复制 vs 集群分片在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？ 从各个方面看，Redis Cluster都是优于主从复制的方案 Redis Cluster能够解决单节点上数据量过大的问题 Redis Cluster能够解决单节点访问压力过大的问题 Redis Cluster包含了主从复制的能力 那是不是代表Redis Cluster永远是优于主从复制的选择呢？ 并不是。 软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用Redis Cluster的弊端包括： 维护难度增加。在使用Redis Cluster时，需要维护的Redis实例数倍增，需要监控的主机数量也相应增加，数据备份/持久化的复杂度也会增加。同时在进行分片的增减操作时，还需要进行reshard操作，远比主从模式下增加一个Slave的复杂度要高。 客户端资源消耗增加。当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。 性能优化难度增加。你可能需要在多个分片上查看Slow Log和Swap日志才能定位性能问题。 事务和LUA Script的使用成本增加。在Redis Cluster中使用事务和LUA Script特性有严格的限制条件，事务和Script中操作的key必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的key进行额外的规划和规范要求。如果应用的场景中大量涉及事务和Script的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。 所以说，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在确实有必要引入数据分片时再使用Redis Cluster。下面是一些建议： 需要在Redis中存储的数据有多大？未来2年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用LRU算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出Redis需要使用的物理内存。 用于部署Redis的主机物理内存有多大？有多少可以分配给Redis使用？对比(1)中的内存需求评估，是否足够用？ Redis面临的并发写压力会有多大？在不使用pipelining时，Redis的写性能可以超过10万次/秒在使用Redis时，是否会使用到pipelining和事务功能？使用的场景多不多？ 综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对Redis的容量需求，且Redis面临的并发写压力距离Benchmark值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。同时，如果应用中大量使用pipelining和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。 Redis Java客户端的选择Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson和lettuce。 在这里对Jedis和Redisson进行对比介绍 Jedis： 轻量，简洁，便于集成和改造 支持连接池 支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster 不支持读写分离，需要自己实现 文档差（真的很差，几乎没有……） Redisson： 基于Netty实现，采用非阻塞IO，性能高 支持异步请求 支持连接池 支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster 不支持事务，官方建议以LUA Scripting代替事务 支持在Redis Cluster架构下使用pipelining 支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用 内建Tomcat Session Manager，为Tomcat 6/7/8提供了会话共享功能 可以与Spring Session集成，实现基于Redis的会话共享 文档较丰富，有中文文档 对于Jedis和Redisson的选择，同样应遵循前述的原理，尽管Jedis比起Redisson有各种各样的不足，但也应该在需要使用Redisson的高级特性时再选用Redisson，避免造成不必要的程序复杂度提升。 Jedis：github：https://github.com/xetorthio/jedis文档：https://github.com/xetorthio/jedis/wiki Redisson：github：https://github.com/redisson/redisson文档：https://github.com/redisson/redisson/wiki","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Redis","slug":"Code/Redis","permalink":"http://xiaoqinghua.site/categories/Code/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://xiaoqinghua.site/tags/Redis/"}]},{"title":"iterm2 小技巧","slug":"iterm2小技巧","date":"2017-03-12T06:47:35.000Z","updated":"2018-08-25T06:49:14.401Z","comments":true,"path":"iterm2小技巧.html","link":"","permalink":"http://xiaoqinghua.site/iterm2小技巧.html","excerpt":"","text":"iterm2 小技巧标签1234- 新建标签：command + t- 关闭标签：command + w- 切换标签：command + 数字 或者command + 方向键- 切换全屏：command + enter 分屏1234- 垂直分屏 command + d- 水平分屏 command + shift + d- 查看历史命令 command + ;- 查看剪粘板历史 command + shift + h 其他1234567891011- 清除当前行 ctrl + u- 到行首 ctrl + a- 到行尾 ctrl + e- 搜索历史命令 ctrl + r- 删除当前光标的字符 ctrl + d- 删除光标之前的字符 ctrl + h- 删除光标之前的单词 ctrl + w- 删除到文本末尾 ctrl + k- 交换光标处字符 ctrl + t- 清屏 command + r- command + f 所选中的内容会被自动复制 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/iterm2小技巧.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Iterm2","slug":"Code/Iterm2","permalink":"http://xiaoqinghua.site/categories/Code/Iterm2/"}],"tags":[{"name":"Iterm2","slug":"Iterm2","permalink":"http://xiaoqinghua.site/tags/Iterm2/"}]},{"title":"白夜行","slug":"白夜行","date":"2016-11-14T12:06:59.000Z","updated":"2018-08-25T06:54:21.977Z","comments":true,"path":"白夜行.html","link":"","permalink":"http://xiaoqinghua.site/白夜行.html","excerpt":"","text":"白夜行世界上有两样东西不能直视，一是太阳，二是人心。 我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。 曾经拥有的东西被夺走，并不代表就会回到原来没有那种东西的时候。 一天中，太阳会升起，同时还会落下。人生也一样，有白天和黑夜，只是不会像太阳那样，有定时的日出和日落。有些人一辈子都活在太阳的照耀下，有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在自己身上的光芒消失。 一个把平等置于自由智商的社会两者都得不到。一个把自由置于平等之上的社会，很大程度上可以两者兼得。 只有在一个方面，联邦储备体系始终如一。这边是，他把所有问题都归咎于超出自己控制能力的外部影响，而把所有合意的结果都归功于自己。由此他继续维持着那个谬传，说私人经济是不稳定的；而他的所作所为却不断证明了这一事实即政府才是导致今天经济不稳定的主要根源。 公众和经济学家观念的改变，均源自对实际情况的误解。当时只有少数人知道，而我们现在都知道，大萧条并非是私有制企业失败所导致而是因为政府并未成功履行它被赋予的责任。这些责任用《合众国宪法》第一天第八款的话来说，便是“铸造货币，调节其价值，并厘定外币价值”。不幸的是，在第九章我们将看到，政府在管理货币方面的失败不仅是历史上的一桩怪事，而且任是今日之事实。 没有什么比时间更有说服力了，因为时间无需通知我们就可以改变一切。 最初我们来到这个世界上是因为不得不来的。最终我们离开这个世界，是因为我们不得不走。 以笑的方式哭，在死亡的伴随下活着。 作为一个词语，“活着”在我们中国的语言里充满了力量，它的力量不是来自于喊叫，也不是来自于进攻，而是忍受，去忍受生命赋予我们的责任，去忍受现实给我们的幸福和苦难，无聊和平庸。 做人不能忘记四条，话不要说错，床不要睡错，门槛不要踏错，口袋不要摸错。 人是为活着本身而活着，不是为了活着之外的任何事物所活着。 作者：xiaoqinghua 有幸经典巨著摘抄系列联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/白夜行.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"影响力","slug":"影响力","date":"2016-10-27T13:35:02.000Z","updated":"2018-08-25T06:54:29.387Z","comments":true,"path":"影响力.html","link":"","permalink":"http://xiaoqinghua.site/影响力.html","excerpt":"","text":"影响力越喜欢一个人，受这个人的影响越大。 一样原本没有什么吸引力的东西，突然间变得很有诱惑力，就因为很快你就得不到它了。 在接受了别人的好处之后，人们很亲依就会答应一个在没有负债心里时一定会拒绝的请求。即便是一个不请自来的好处，一旦被接收，也会制造出一种负债感。 当我们对自己缺乏信心时，当形式变得不很明朗时，当不确定占了上风时，我们最有可能以别人的行为作为自己行动的参照。与我们类似的人的行为对我们最有影响力。 一旦我们做了一个决定，或选择了一种立场，就会有发自内心以及来自外部的压力来迫使我们与此保持一致。在这种压力下，我们总是希望以实际行动来证明我们以前的决定是正确的。 cazhulafu brother上帝与魔鬼在那里搏斗，战斗便在人们心中。 在现实主义者身上，并不是奇迹产生信仰，而是信仰产生奇迹。 在大多数情况下，人们，甚至恶人，要比我们想象中的他们幼稚的多，天真的多。其实我们也一样。 对自己说谎和听自己说谎的人会落到这样的地步：无论在自己身上还是周围，即使有真理，他也无法辨别，结果将是既不自重，也不尊重别人。一个人如果对谁都不尊重，也就没有了爱；在没有爱的情况下想要消遣取乐，无非放纵情欲，耽于原始的感官享受，在罪恶的泥潭中完全堕落成畜类，而一切都始于不断的对人和对己说谎。对自己说谎的人最容易怄气。 电子游戏让人上瘾的全部原因只有一个。创造一个属于我们自己的世界。我想不出有什么东西比做一个神更能让人上瘾的了。 人们都说没有什么能逃脱冷库的热力学第二定律，宇宙的最后归宿是一片热死寂。但这不是故事的全部，宇宙在沉寂的同事，也在热闹起来，从旧物中带来新生、增加复杂性的新层次。宇宙充满了无尽的创造力。熵和进化，两者就像两支时间之矢，一头拖着我们退入无穷的黑暗，一头在拉扯我们走向永恒的光明。 网络把隐私从道德领域转移到了市场领域——隐私成了一种商品。 作者：xiaoqinghua 有幸经典巨著摘抄系列联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/影响力.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"少有人走的路","slug":"少有人走的路","date":"2016-09-27T13:39:24.000Z","updated":"2018-08-25T06:54:34.305Z","comments":true,"path":"少有人走的路.html","link":"","permalink":"http://xiaoqinghua.site/少有人走的路.html","excerpt":"","text":"少有人走的路一辈子真的很短，远没有我们想象的那么长，永远真的没有多远，所有不妨对爱你的好一点，也对自己好一点，今天是你的枕畔人，明天就可能是你的陌生人，如果这一辈子来不及好好爱，就更不要指望下辈子还能遇见。 想让别人真正爱你，只有让自己成为值得爱的人。 承受痛苦是走向成熟的必经之路，任何人都不能回避。 大部分的恐惧与懒惰有关，这句话我深以为然。我么常常会害怕改变，其实都是因为自己太懒了，懒得去适应新环境，懒得去学习新知识，涉足新的领域，但如果总是这样的话，如何能让自己成熟起来呢？ 多数人认为勇气就是不害怕。现在让我来告诉你，不害怕不是勇气，它只是脑损伤。勇气是尽管你感觉害怕，但仍能迎难而上；尽管你感觉痛苦，但仍能直接面对。 所谓自律，是以积极而主动地态度，去解决人生痛苦的重要原则，主要包括四个方面：推迟满足感、承担责任、尊重事实、保持平衡。 未来简史更重要的\b，当以大数据、人工智能为代表的科学技术发展的日益成熟，人类将面临着从进化到智人以来最大的一次改变，绝大部分人将沦为“无价值的群体”，只有少部分人能进化成特质发生改变的”神人”。 未来，人类将面临\b着三大问题：生物本身就是算法，生命是不断处理数据的过程；意识与智能的分离；拥有大数据积累的外部环境将比我们自己更了解自己。如何看待这三大问题，以及如何采取应对措施，将直接影响着人类未来的发展。 天才在左，疯子在右时间是不流逝的，流逝的是我们。 哲学家与疯子的区别，一个知识在想，另一个真的去做了。 孤独感时常体现在一种矛盾上，就是你经常处于一种挣扎状态：既希望别人关心、管住自己，又不知道该怎么去接触和回应别人。于是干脆直接抗拒，科室骨子里又是那么的渴望被了解和关注，而且矛盾到嘴里说出来的和心里想的完全相反。 只有当你认真的去做一件事情的时候，才会发现自己的灵魂和灵魂深处。 如果有一天你看到我疯了，其实是你疯了。 作者：xiaoqinghua 有幸经典巨著摘抄系列联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/少有人走的路.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"Mysql存储IP地址细节","slug":"Mysql存储IP地址细节","date":"2016-08-20T03:58:41.000Z","updated":"2018-08-25T06:51:07.266Z","comments":true,"path":"Mysql存储IP地址细节.html","link":"","permalink":"http://xiaoqinghua.site/Mysql存储IP地址细节.html","excerpt":"","text":"Mysql存储IP地址细节ipv4:数据库可以设计成: 1`ipv4` INT UNSIGNED; 插入 ipv4 地址1INSERT INTO `table` (`ipv4`) VALUES (INET_ATON(&quot;127.0.0.1&quot;)); 查询 ipv41SELECT INET_NTOA(`ipv4`) FROM `table`; 注意实测一定要设计成 UNSIGNED ，MySQL 的 INT 存储范围是 -2147493648到2147493647(SIGNED) ，0到4294967295(UNSIGNED)”而 ipv4 中 255.255.255.255被INET_ATON 成 int 之后是 4294967295 刚好是最大值。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/Mysql存储IP地址细节.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"MySql","slug":"Code/MySql","permalink":"http://xiaoqinghua.site/categories/Code/MySql/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"http://xiaoqinghua.site/tags/MySql/"}]},{"title":"乌合之众","slug":"乌合之众","date":"2016-08-08T12:23:54.000Z","updated":"2018-08-25T06:54:47.822Z","comments":true,"path":"乌合之众.html","link":"","permalink":"http://xiaoqinghua.site/乌合之众.html","excerpt":"","text":"乌合之众人一到群体中，智商就严重降低，为了获得认同感，个体原意抛弃是非，用智商去换取那份让人倍感安全的归属感。 群体不善推理，却又急于行动。 我们始终有一种错觉，以为我们的感情源自我们的内心。 我们以为自己是理性的我们以为自己的一举一动都是有其道理的。但事实上，我们绝大多数的日常行为，都是一些我们自己根本无法了解的隐蔽动机结果。 个人一旦成为群体中的一员，他所作所为就不会再承担责任，这是每个人都会暴露出自己不受约束的一面。群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。 所谓信仰，它让一个人变得完全受自己的梦想奴役。 月亮与六便士上帝的磨盘转的很慢，却磨得很细。 在爱情的事上，如果你考虑起自尊心来，那只能有一个原因：实际上你还是最爱你自己。 我们每个人生在世界上都是孤独的。每个人都困在一座铁塔里，只能靠一些符号同别人传达自己的思想。而这些符号并没有共同的价值，因此他们的意义是模糊的、不确定的。我嗯非常可怜地想把自己心中的财富传送给别人，但他们却没有接受这财富的能力。因此我们只能孤独地行走，尽管身体相互依傍却并不在一起，既不了解别人也不能被别人所了解。 海伯利安看了这本书，你就不会再看《三体》了。 我去旅行是因为我决定要去，并不是因为风景。 趁年轻，好好利用这个机会，尽力去尝遍所有的痛苦，这种事可不是一辈子什么时候都可以遇到的。 人不是从娘胎里出来就一成不变的，相反，生活会逼他一次又一次的脱胎换骨。 真正的爱情需要什么？需要两个人在一起是轻松快乐的，没有压力的。 诚实的生活方式其实是按照自己身体的意愿行事，饿的时候吃饭，爱的时候不必撒谎。 苏菲的世界生命本来就是悲伤而严肃的。我们来到这个美丽的世界里，彼此相逢，彼此问候，并结伴同游一段短暂的时间。然后我们就是去了对方，然后就莫名其妙的消失了，就像我们莫名其妙地来到世界一般。 你太习惯这个世界了，所以你对任何事情都不感到惊奇。 真正的知识来自内心，而不是得自别人的传授。同时唯有出自内心的知识，才能使人拥有真正的智慧。 理智和经验都缺失时，就会出现一个真空，这个真空可以有信仰填补。 作者：xiaoqinghua 有幸经典巨著摘抄系列联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/乌合之众.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"娱乐至死","slug":"娱乐至死","date":"2016-07-03T05:26:41.000Z","updated":"2018-08-25T06:54:37.906Z","comments":true,"path":"娱乐至死.html","link":"","permalink":"http://xiaoqinghua.site/娱乐至死.html","excerpt":"","text":"娱乐至死有两种方法可以让文化精神枯萎，一种是奥威尔式——文化成为一种监狱，另一种是赫胥黎式——文化成为一场滑稽戏。 我们将死于我们所热爱的东西。 \b真理不能，也从来没有，毫无修饰地存在。它必须穿着\b某种合适的外衣出现，否则就可能得不到承认，这也正说明了“真理”是一种文化偏见。 过去，人们为了解决生活中的问题儿搜索信息，现在是为了让无用的\b信息派上用场而制造问题。 一个人学到的\b最重要的东西是学习的方法。 1984他们不到觉悟的时候，就不会造反。他们不造反，就不会有觉悟。 如果你感到保持人性是值得的，即使这不能有任何结果，你也已经打败了他们。 上等人的目标是保持他们的地位。中等人的目标是要通上等人交换地位。下等人的特点始终是，他们劳苦之余无暇旁顾，偶尔才顾到日常生活以外的事，因此如果他们有目标的话，无非就是取消一切差别，建立一个人人平等的社会。 我们很明白没有人会为了废除权利而夺取权利。权力不是手段，权力是目的。建立专政不是为了保卫革命，反过来进行革命是为了建立专政。 zoo越喜欢上什么，一旦突然失去它，我的心就越为悲泣。这样反反复复地，我还任要忍耐这种苦楚不得不继续度过剩余的生命。这是多么残酷的事情啊。与其如此，不如干脆把我当做什么都不爱，没有人心徒有人形的样子。 爱的越深刻，死的意义就越沉重，失落感也会越深刻。 我脸上越是挤出明亮的笑容，我的内心就越是变的荒芜。 我对别人的存在感到恐惧，我觉得自己对别人谄媚的行径也会因为这个。被别人讨厌，被别人看不起，被别人嘲笑，对我来说都是难以忍受的痛苦，于是为了逃避这些行为，我再自己的内心养了那样一只丑陋的动物。如果没有别人在这个世界上，只有我自己一个人，那将是多么轻松啊。 ps:这本书太沉重了吧😨，配个阳光明媚的 landspace 吧。 作者：xiaoqinghua 有幸经典巨著摘抄系列联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/娱乐至死.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"百年孤独","slug":"百年孤独","date":"2016-06-27T09:26:41.000Z","updated":"2018-08-25T06:54:17.656Z","comments":true,"path":"百年孤独.html","link":"","permalink":"http://xiaoqinghua.site/百年孤独.html","excerpt":"","text":"百年孤独无论走到哪里，都应该记住，过往的一切都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧\b而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实，唯有孤独永恒。 生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。 我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折中涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。 买下一张永久车票，登上一辆永无终点的列车。 所有人都显得很激进，用自己的方式想尽办法派遣寂寞，事实上仍是延续自己的孤独。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。 作者：xiaoqinghua 有幸经典巨著摘抄系列联系地址：https://github.com/smartzer http://xiaoqinghua.site/css/images/zz_qrcode.jpeg本文地址：http://xiaoqinghua.site/百年孤独.html版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"你为什么走这一遭？","slug":"关于我","date":"1992-08-28T16:00:00.000Z","updated":"2019-10-23T08:59:23.304Z","comments":true,"path":"关于我.html","link":"","permalink":"http://xiaoqinghua.site/关于我.html","excerpt":"","text":"ZZ：我们可以开始了吧！？小清华：嗯，可以。 ZZ：请问你今年几岁？为什么想写这些东西？小清华：我想说17，但实际已经xx岁了。奔三。就是想写点什么，没有原因。 ZZ：你有点傲娇？小清华：还好吧。 ZZ：我从你的&#39;还好吧&#39;三个字中听出了不屑。小清华：是吗？那就还有那么一点点傲娇吧。快没了。 ZZ：是什么让你的傲娇一点点没了？小清华：我可以不回答吗？ ZZ：这就是你那最后一点点傲娇？小清华：人要保持敬畏之心。 ZZ：你从什么时候开始明白这个道理？小清华：感觉自己真正成长的时候。每一刻清晨踏入地铁站的一瞬间，每一次深夜下班感受霓虹的一刹那吧。 ZZ：骨子里还有点小情趣？小清华：是啊，不过依然很难改变生活。 ZZ：你想要改变生活？！！？？小清华：这有什么问题吗？ ZZ：哦，没有问题。但是改变不了什么的。相信我。你只有去适应他。小清华：哦，你好像在教我生活的道理。 ZZ：你要是今天不预约我采访你，我会在这里和你BB？小清华：为什么我有时一旦想专注做某些事情的时候，却很难专注下来？ ZZ：我今天累了。就这样吧，下次记得提前预约。小清华：要有敬畏之心。世间万物都是这个道理。要善良。 ZZ：。。。。。小清华：那。。。就这样吧","categories":[],"tags":[]}]}