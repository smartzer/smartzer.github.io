{"meta":{"title":"有幸的个人小站","subtitle":"code is poetry","description":"这是作者为五十年后的自己留下的，感恩生活。","author":"xiaoqinghua 有幸","url":"http://xiaoqinghua.site"},"pages":[],"posts":[{"title":"成都","slug":"成都","date":"2018-07-21T08:38:55.000Z","updated":"2018-08-24T08:20:25.395Z","comments":true,"path":"成都.html","link":"","permalink":"http://xiaoqinghua.site/成都.html","excerpt":"","text":"成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 成 都 123456789\"city\":&#123; \"name\":\"chengdu\", \"abbreviation01\":\"cdc\", \"abbreviation02\":\"splendid officer city\", \"abbreviation03\":\"hibiscus city\", \"slogan_en\":\"living and enjoy in your home forever\", \"slogan_ch\":\"一座来了就不想离开的城市\" \"xiaoqinghua\":\"I love you , I love my city\"&#125;","categories":[],"tags":[{"name":"City","slug":"City","permalink":"http://xiaoqinghua.site/tags/City/"}]},{"title":"Follow 算法过程验算","slug":"follow算法过程验算","date":"2018-07-10T07:08:15.000Z","updated":"2018-08-24T07:44:01.536Z","comments":true,"path":"follow算法过程验算.html","link":"","permalink":"http://xiaoqinghua.site/follow算法过程验算.html","excerpt":"","text":"举个栗子🌰 1follow(cs1,cs2) --&gt; follow(\"Z:z&gt;4|2=m=b-1+2+3$abcde\", \"Z:z&gt;1|2=m=b=1+2-1$fg\") 12345678910111213141516把cs1,cs2展开cs1:op1.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op1.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op1.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op1.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op1.5:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;charBank=&apos;abcde&apos;cs2:op2.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2.3:&#123; opcode: &apos;=&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2.5:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;charBank=&apos;fg&apos; 在follow函数中有一个applyZip的函数,其实这是一个迭代器,zip有拉链的意思,在迭代的过程中不断的两两运算,就像拉链一样一颗颗缝合起来: 1234567891011121314151617181920exports.applyZip = function (in1, idx1, in2, idx2, func) &#123; var iter1 = exports.opIterator(in1, idx1); var iter2 = exports.opIterator(in2, idx2); var assem = exports.smartOpAssembler(); var op1 = exports.newOp(); var op2 = exports.newOp(); var opOut = exports.newOp(); while (op1.opcode || iter1.hasNext() || op2.opcode || iter2.hasNext()) &#123; if ((!op1.opcode) &amp;&amp; iter1.hasNext()) iter1.next(op1); if ((!op2.opcode) &amp;&amp; iter2.hasNext()) iter2.next(op2); func(op1, op2, opOut); if (opOut.opcode) &#123; //print(opOut.toSource()); assem.append(opOut); opOut.opcode = ''; &#125; &#125; assem.endDocument(); return assem.toString();&#125;; 1234567891011开始迭代(循环)前,需要做一些准备工作:1、新建两个空的op1,op2对象，用于接收展开的cs1,cs2中所有的op对象的值Op op1 = new Op();op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;Op op2 = new Op();op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、新建一个opOut对象,用于接收每一次迭代完后我们得到的运算结果opOp opOut = new Op();opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125; 1234567891011121314第1次迭代:1、初始:按照顺序会使用cs1中的op1.1和cs2中的op2.1和一个刚刚new出来的新的op对象op1.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;ops : &quot;|2=m&quot;说明:both keep,follow之后op1,op2都没opcode,所以重新赋值next() 对应第1次迭代的具体代码:12345678910111213141516171819// both keepsopOut.opcode = '=';opOut.attribs = exports.followAttributes(op1.attribs, op2.attribs, pool);if (op1.chars &lt;= op2.chars) &#123; opOut.chars = op1.chars; opOut.lines = op1.lines; op2.chars -= op1.chars; op2.lines -= op1.lines; op1.opcode = ''; if (!op2.chars) &#123; op2.opcode = ''; &#125;&#125; else &#123; opOut.chars = op2.chars; opOut.lines = op2.lines; op1.chars -= op2.chars; op1.lines -= op2.lines; op2.opcode = '';&#125; 123456789101112第2次迭代:1、初始:op1.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b&quot;说明:both keep,follow之后op1,op2都没opcode,所以重新赋值next() 对应第2次迭代的具体代码:12345678910111213141516171819// both keepsopOut.opcode = '=';opOut.attribs = exports.followAttributes(op1.attribs, op2.attribs, pool);if (op1.chars &lt;= op2.chars) &#123; opOut.chars = op1.chars; opOut.lines = op1.lines; op2.chars -= op1.chars; op2.lines -= op1.lines; op1.opcode = ''; if (!op2.chars) &#123; op2.opcode = ''; &#125;&#125; else &#123; opOut.chars = op2.chars; opOut.lines = op2.lines; op1.chars -= op2.chars; op1.lines -= op2.lines; op2.opcode = '';&#125; 123456789101112第3次迭代:1、初始:op1.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2.3:&#123; opcode: &apos;=&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b&quot;说明:op1-,op2=,follow之后op1,op2都没opcode,所以重新赋值next() 对应第3次迭代的具体代码: 12345678910111213141516if (!op2.opcode) &#123; op1.opcode = '';&#125; else &#123; if (op1.chars &lt;= op2.chars) &#123; op2.chars -= op1.chars; op2.lines -= op1.lines; op1.opcode = ''; if (!op2.chars) &#123; op2.opcode = ''; &#125; &#125; else &#123; op1.chars -= op2.chars; op1.lines -= op2.lines; op2.opcode = ''; &#125;&#125; 123456789101112第4次迭代:1、初始:op1.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b=2&quot;说明:both+,follow之后op1没opcode,所以重新赋值next() 对应第4次迭代的具体代码:123456789101112131415161718192021222324252627282930313233343536373839404142var whichToDo;if (op2.opcode != '+') &#123; whichToDo = 1;&#125; else if (op1.opcode != '+') &#123; whichToDo = 2;&#125; else &#123; // both + var firstChar1 = chars1.peek(1); var firstChar2 = chars2.peek(1); var insertFirst1 = hasInsertFirst(op1.attribs); var insertFirst2 = hasInsertFirst(op2.attribs); if (insertFirst1 &amp;&amp; !insertFirst2) &#123; whichToDo = 1; &#125; else if (insertFirst2 &amp;&amp; !insertFirst1) &#123; whichToDo = 2; &#125; // insert string that doesn't start with a newline first so as not to break up lines else if (firstChar1 == '\\n' &amp;&amp; firstChar2 != '\\n') &#123; whichToDo = 2; &#125; else if (firstChar1 != '\\n' &amp;&amp; firstChar2 == '\\n') &#123; whichToDo = 1; &#125; // break symmetry: else if (reverseInsertOrder) &#123; whichToDo = 2; &#125; else &#123; whichToDo = 1; &#125;&#125;if (whichToDo == 1) &#123; chars1.skip(op1.chars); opOut.opcode = '='; opOut.lines = op1.lines; opOut.chars = op1.chars; opOut.attribs = ''; op1.opcode = '';&#125; else &#123; // whichToDo == 2 chars2.skip(op2.chars); exports.copyOp(op2, opOut); op2.opcode = '';&#125; 123456789101112第5次迭代:1、初始:op1.5:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;(第4次循环follow算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b=2=3&quot;说明:both+,follow之后op1没opcode,所以重新赋值next(),但此时已没有next(),故还是使用op1原有值 对应第5次迭代的具体代码:123456789101112131415161718192021222324252627282930313233343536373839404142var whichToDo;if (op2.opcode != '+') &#123; whichToDo = 1;&#125; else if (op1.opcode != '+') &#123; whichToDo = 2;&#125; else &#123; // both + var firstChar1 = chars1.peek(1); var firstChar2 = chars2.peek(1); var insertFirst1 = hasInsertFirst(op1.attribs); var insertFirst2 = hasInsertFirst(op2.attribs); if (insertFirst1 &amp;&amp; !insertFirst2) &#123; whichToDo = 1; &#125; else if (insertFirst2 &amp;&amp; !insertFirst1) &#123; whichToDo = 2; &#125; // insert string that doesn't start with a newline first so as not to break up lines else if (firstChar1 == '\\n' &amp;&amp; firstChar2 != '\\n') &#123; whichToDo = 2; &#125; else if (firstChar1 != '\\n' &amp;&amp; firstChar2 == '\\n') &#123; whichToDo = 1; &#125; // break symmetry: else if (reverseInsertOrder) &#123; whichToDo = 2; &#125; else &#123; whichToDo = 1; &#125;&#125;if (whichToDo == 1) &#123; chars1.skip(op1.chars); opOut.opcode = '='; opOut.lines = op1.lines; opOut.chars = op1.chars; opOut.attribs = ''; op1.opcode = '';&#125; else &#123; // whichToDo == 2 chars2.skip(op2.chars); exports.copyOp(op2, opOut); op2.opcode = '';&#125; 123456789101112第6次迭代:1、初始:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;(第5次循环follow算法后的op1)op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;(第4次循环follow算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b=2=3+2&quot;说明:op2+,follow之后op1，op2没opcode,所以重新赋值next(),但此时已没有next(),故还是使用op1，op2原有值 对应第6次迭代的具体代码:123456789101112131415161718192021222324252627282930313233343536373839404142var whichToDo;if (op2.opcode != '+') &#123; whichToDo = 1;&#125; else if (op1.opcode != '+') &#123; whichToDo = 2;&#125; else &#123; // both + var firstChar1 = chars1.peek(1); var firstChar2 = chars2.peek(1); var insertFirst1 = hasInsertFirst(op1.attribs); var insertFirst2 = hasInsertFirst(op2.attribs); if (insertFirst1 &amp;&amp; !insertFirst2) &#123; whichToDo = 1; &#125; else if (insertFirst2 &amp;&amp; !insertFirst1) &#123; whichToDo = 2; &#125; // insert string that doesn't start with a newline first so as not to break up lines else if (firstChar1 == '\\n' &amp;&amp; firstChar2 != '\\n') &#123; whichToDo = 2; &#125; else if (firstChar1 != '\\n' &amp;&amp; firstChar2 == '\\n') &#123; whichToDo = 1; &#125; // break symmetry: else if (reverseInsertOrder) &#123; whichToDo = 2; &#125; else &#123; whichToDo = 1; &#125;&#125;if (whichToDo == 1) &#123; chars1.skip(op1.chars); opOut.opcode = '='; opOut.lines = op1.lines; opOut.chars = op1.chars; opOut.attribs = ''; op1.opcode = '';&#125; else &#123; // whichToDo == 2 chars2.skip(op2.chars); exports.copyOp(op2, opOut); op2.opcode = '';&#125; 123456789101112第7次迭代:1、初始:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;(第6次循环follow算法后的op1)op2.5:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、follow算法后:op1:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;ops : &quot;|2=m=b=2=3+2-1&quot;说明:判断，op1,op2都没有opcode,也没有next()了,停止 对应第7次迭代的具体代码:12345678910111213141516171819exports.copyOp(op2, opOut);if (!op1.opcode) &#123; op2.opcode = '';&#125; else if (op2.chars &lt;= op1.chars) &#123; // delete part or all of a keep op1.chars -= op2.chars; op1.lines -= op2.lines; op2.opcode = ''; if (!op1.chars) &#123; op1.opcode = ''; &#125;&#125; else &#123; // delete all of a keep, and keep going opOut.lines = op1.lines; opOut.chars = op1.chars; op2.lines -= op1.lines; op2.chars -= op1.chars; op1.opcode = '';&#125; 算法结果12345678910111213141516171819202122232425261 Changeset = require(\"./src/static/js/Changeset\");2 var csA = \"Z:z&gt;4|2=m=b-1+2+3$abcde\";3 var csB = \"Z:z&gt;1|2=m=b=1+2-1$fg\";45 var doc = \"Hello World\\n\\n Hello World Hello Wor\";67 var appliedA = Changeset.applyToText(csA,doc);8 var appliedB = Changeset.applyToText(csB,doc);910 console.log('apply csA:', appliedA, ',apply csB: ', appliedB);1112 var csA1 = Changeset.follow(csB,csA,true,null);13 var csB1 = Changeset.follow(csA,csB,false,null);1415 console.log('csA1:', csA1, 'csB1: ', csB1);1617 // X * csA * csB1 = Y18 // X * csB * csA1 = Y1920 var leftY = Changeset.applyToText(csB1, appliedA);21 var rightY = Changeset.applyToText(csA1, appliedB);2223 console.log('final left:', leftY, ',final right: ', rightY);24 if (leftY === rightY) &#123;25 console.log('bingo');26 &#125; 12345678910111213141516171819202122apply csA: Hello World Hello World Hello Wabcderapply csB: Hello World Hello World Hello WofgcsA1: Z:10&gt;4|2=m=b-1+5$abcdecsB1: Z:13&gt;1|2=m=g-1+2$fgfinal left: Hello World Hello World Hello Wabcdefgfinal right: Hello World Hello World Hello Wabcdefgbingo 123456789&gt; var cs1 = \"Z:z&gt;4|2=m=b-1+2+3$abcde\";&gt; var cs2 = \"Z:z&gt;1|2=m=b=1+2-1$fg\";&gt; Changeset.follow(cs1,cs2,false,null);'Z:13&gt;1|2=m=g-1+2$fg'最终的CS:'Z:13&gt;1|2=m=g-1+2$fg' 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"Follow 算法图解","slug":"follow算法图解","date":"2018-07-09T07:09:28.000Z","updated":"2018-08-24T07:44:03.490Z","comments":true,"path":"follow算法图解.html","link":"","permalink":"http://xiaoqinghua.site/follow算法图解.html","excerpt":"","text":"01 02 03 04 05 06 07 08 09 10 11 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"FollowAttributes 算法解析","slug":"followAttributes算法解析","date":"2018-06-19T07:09:01.000Z","updated":"2018-08-24T07:43:46.320Z","comments":true,"path":"followAttributes算法解析.html","link":"","permalink":"http://xiaoqinghua.site/followAttributes算法解析.html","excerpt":"","text":"何时用 followAttributes在follow算法中，op两两进行运算，包含15种情况，何时进行属性的合并即followAttributes，在代码中我们可以发现，仅在op1，op2的opcode同时为‘=’时进行\bfollowAttributes。 为何用 followAttributes followAttributes函数注释\b 123456// The merge of two sets of attribute changes to the same text// takes the lexically-earlier value if there are two values// for the same key. Otherwise, all key/value changes from// both attribute sets are taken. This operation is the \"follow\",// so a set of changes is produced that can be applied to att1// to produce the merged set. 1234以上注释大概意思：两个属性改变集的合并作用于同一段文，如果同一个key有两个不同的值则采取字典排序在前的值。否则，所有的键值都将改变因为两个属性集都被采取。此操作为‘follow’，因此产生了一组可以应用于‘att1’属性的变更，去生成合并集。 \b通过follow算法我们了解到，仅在op1，op2的opcode同时为‘=’时，\b此时的op1，op2两两运算才是操作的同一段文本字符(\b如\bop1为+，op2为-)操作的不是同一处文本。 followAttributes 过程 准备AttributePool 1234567var p = new AttributePool();p.putAttrib(['x', '']);p.putAttrib(['x', 'abc']);p.putAttrib(['x', 'def']);p.putAttrib(['y', '']);p.putAttrib(['y', 'abc']);p.putAttrib(['y', 'def']); 构造运算 12assertEqualStrings('*3', Changeset.followAttributes('*0*4', '*2*3', p));assertEqualStrings('*0', Changeset.followAttributes('*2*3', '*0*4', p)); AttributePool中\b依次存入了6个属性: 1234567891011121314151617181920212223242526&#123; \"0\": [ \"x\", \"\" ], \"1\": [ \"x\", \"abc\" ], \"2\": [ \"x\", \"def\" ], \"3\": [ \"y\", \"\" ], \"4\": [ \"y\", \"abc\" ], \"5\": [ \"y\", \"def\" ]&#125; op1使用的属性为\b&quot;0&quot;: [&quot;x&quot;,&quot;&quot;]、&quot;4&quot;: [&quot;y&quot;,&quot;abc&quot;]，op2使用的属性为\b&quot;2&quot;: [&quot;x&quot;,&quot;def&quot;]、&quot;3&quot;: [&quot;y&quot;,&quot;&quot;] 代码详解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static String followAttributes(String att1, String att2, AttributePool pool) &#123; // 在上述的示例中 att1，att2 均不为空，故可忽略下面两行代码 // 但是在 att2 为空，pool 为空的情况下，followAttributes 返回空，为何？ // 因为在上层函数 follow 中即 follow(op1,op2)，op1 是已经应用的操作，\b当 op2 使用的属性为空时， // 我们最终所需要的操作 opOut 相当于保持 op1 的操作 /* 对应上层函数follow中这段代码，同样的 attribs 返回空字符串 if (whichToDo == 1) &#123; opOut.opcode = Op.OPCODE_KEEP; opOut.lines = op1.lines; opOut.chars = op1.chars; opOut.attribs = EMPTY_STRING; &#125; */ if (isEmpty(att2) || pool == null) &#123; return EMPTY_STRING; &#125; // 同理可证 /* 对应层函数follow中这段代码，同样的 attribs 使用的是 op2 的 'attribs' &#125; else if (!op1.hasOpcode()) &#123; Op.copyOp(op2, opOut); op2.clearOpcode(); &#125; */ if (isEmpty(att1)) &#123; return att2; &#125; // 新建一个空的集合即我们想要的最后结果属性集 // 下面做的操作就是把 att2 的属性加到 atts 中，其实 atts 就是 att2 List&lt;Attribute&gt; atts = Lists.newArrayList(); // 在上述实例中，经过不断的正则匹配迭代，atts=[ [\"x\",\"def\"],[\"y\",\"\"] ] Matcher matcher = PATTERN_ATTRIBUTE.matcher(att2); while (matcher.find()) &#123; atts.add(pool.getAttrib(parseNum(matcher.group(1)))); &#125; // 这里使用嵌套循环，相当于两两对比 att1 和 att2 相同 key 对应的属性值的字典排序\b值的大小 // 只是我们最终得到的都是att2的值，在一次次比较中删除或不删除 att2 中的值 matcher = PATTERN_ATTRIBUTE.matcher(att1); while (matcher.find()) &#123; Attribute pair1 = pool.getAttrib(parseNum(matcher.group(1))); for (int i = 0; i &lt; atts.size(); i++) &#123; Attribute pair2 = atts.get(i); if (pair1.getKey().equals(pair2.getKey())) &#123; // winner of merge is pair1, delete this attribute // 第一次比较 '' &lt; 'def',则删除 atts 中的 '[\"x\",\"def\"]' ,atts=[ [\"y\",\"\"] ] // 第二次比较 'abc' &gt; '',没有操作 ,最终 atts=[ [\"y\",\"\"] ] // TODO 此处为何根据值的字典排序比较？ if (pair1.getValue().compareTo(pair2.getValue()) &lt;= 0) &#123; // 移除 atts.remove(i); &#125; &#125; &#125; &#125; // we've only removed attributes, so they're already sorted StringAssembler buf = new StringAssembler(); for (int i = 0; i &lt; atts.size(); i++) &#123; buf.append(\"*\"); // atts=[ [\"y\",\"\"] ] 中 [\"y\",\"\"]在 pool 中 index=3 buf.append(numToString(pool.putAttrib(atts.get(i)))); &#125; return buf.toString();&#125;; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"etherpad 技术分析","slug":"etherpad技术分析","date":"2018-06-19T07:07:54.000Z","updated":"2018-08-24T07:43:43.135Z","comments":true,"path":"etherpad技术分析.html","link":"","permalink":"http://xiaoqinghua.site/etherpad技术分析.html","excerpt":"","text":"Etherpad \b技术分析领域模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Pad &#123; head atext apool&#125;class PadRevision &#123; author revision changeset timestamp&#125;class Changeset &#123; oldLength newLength ops charBank&#125;class Op &#123; opcode lines chars attribs&#125;class AText &#123; text attribs&#125;class AttributePool &#123; nextNum numToAttrib attribToNum&#125;class Attribute &#123; key value&#125;Pad o---&gt; PadRevisionPad o---&gt; ATextPad o---&gt; AttributePoolPadRevision o--&gt; ChangesetChangeset o--&gt; OpAttributePool o..&gt; Attribute Padpad 在 etherpad 中对应一篇文档，是多人协作的基本单位。 对 pad 的每一次编辑操作，都会生成一个 revision, 类似于版本控制系统(尤其类似于 svn)中的一次提交，revision 从零开始往上递增，head 指向当前最新的 revision。对所有的 revision 依次计算，可以得出 pad 的正文，但是对于有大量编辑操作的 pad, 打开 pad 时大量的计算势必影响加载速度，所以 pad 中包含 atext 字段表示当前\b的内容，以空间换时间。atext 包含两部分： text 和 attribs, text 就是该文档的正文，attribs 是描述正文的内容都有哪些属性。 \bapool 是属性 “池”，\b记录了属性编号对应的属性。 ATextAtext 示例数据： 1234&#123; \"text\": \"Welcome to Etherpad!\\n\\nThis pad text is synchronized as you type, so that everyone viewing this page sees the same text. This allows you to collaborate seamlessly on documents!\\n\\nGet involved with Etherpad at http://etherpad.org\\n\\nsdf\\n\\ns\\nsdf\\nsefssss\\n\\nsss\\nsdf\\nsss\\n\\nsefffsdfsssef\\nesssdfsd\\ns\\nsdfsdfsd\\n\\ncvb\\nsdfsdf\\n\\naaaaaaaaaaaaaaaaa第三方斯蒂芬\\n\\nsdf\\n\\nsdsssdf\\n\\nabc\\n\\nabccccfbcfcvbcfgrddfgddddd\\n\\nsdfesfsges\\n\\nsdfdsses\\n\\nsseg\\n\\n\\nsdfesgessdf\\n\\n\\n\\nsdfessefgdfg\\n\", \"attribs\": \"|2+m+1o*4+7|2+2g*3+1d*0|5+9*1+3*0|1+1*0+7|1+1*1|1+1*0+3*1|2+5*0+3*1|2+2*0+5*2+8*1|2+a*2+1*1|3+b*2+3*1|3+9*1+n*2|3+6*0|5+f*0+3*2+b*0|1+d*2|1+1*0+a*2|2+2*2+5*0+3*2|2+2*0+4*2|1+1*0|2+2*0+7*2|4+8*2+7*0+5|1+1\"&#125; AttributePoolAttributePoolJson 是 AttributePool 保存到数据库中的形式，加载到内存时会做一次转换。 AttributePool 多了一个 Attribute -&gt; num 的反向索引，用于快速的通过 Attribute 找到对应的编号。 etherpad 的设计中， AttributePool 的属于某个 pad 的 “命名空间” 的， 也就是说，每个 pad 都会有自己的 AttributePool。 AttributePoolJson 示例数据： 12345678910111213141516171819202122232425&#123; \"numToAttrib\": &#123; \"0\": [ \"author\", \"a.lbCJXik3gn5kFmZn\" ], \"1\": [ \"author\", \"a.QOApinD3T5GQ57t6\" ], \"2\": [ \"author\", \"a.EAPXEvFdNybN83aD\" ], \"3\": [ \"strikethrough\", \"true\" ], \"4\": [ \"bold\", \"true\" ] &#125;, \"nextNum\": 5&#125; PadRevision每个 revision 都记录了 author 和 timestamp, 因此可以回到任意的历史编辑状态。 revision 的主要内容是 changeset. Changeset一个 changeset 代表对文档的变更。 changeset 的结构: 图片来源: http://slix.rocks/%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E4%B8%AD-easysync2-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/ Opetherpad 共有四种操作： 1234*N: 应用某个属性=N: 保留 N 个字符+N: 增加 N 个字符-N: 删除 N 个字符 在线 demo。 etherpad 的 OT 实现实时协同编辑的核心算法是 OT，而 Etherpad 中 OT 的实现是一个名为 follow 的函数。 详见 follow 算法。 client server 协议长连接etherpad 使用开源 SocketIO 库，这个库在\b浏览器支持 websocket 时，\b会使用 websocket, 在老旧的浏览器中会 fallback 到 long polling 上。 SocketIO 也有不少批评的声音，例如: https://github.com/rethinkdb/horizon/issues/413 。 考虑到目前主流的浏览器都已经支持 websocket 了，可以考虑\b用原生 websocket, 如果必须支持老旧浏览器，则可以考虑 sockjs(onlyoffice 好像用的这个)。 服务端逻辑多人编辑是一定会出现冲突的，通过两个办法解决冲突: \b服务端通过\b排队的方式，把\b并发修改的的操作\b串行化； 如果某次修改的 baseRev 不是当前 pad 的 head, 则通过 OT 算法\b\b对于已经 commit 的修改依次计算，这个过程有点类似于 git 的 rebase。 1234567891011121314151617181920212223242526272829autonumberskinparam ParticipantPadding 90title 服务端处理流程\\n\\nClient -&gt; Server: baseRev + CSServer -&gt; Server: enqueue baseRev + CS|||loopServer -&gt; Server: follownote leftwhile (baseRev &lt; head) &#123; CS = follow(R(baseRev), CS); baseRev++;&#125;end noteend|||Server -&gt; Server: save revisionServer -&gt; Client: accept commit|||Server -&gt; &quot;Other clients&quot;: CS(head + 1) 客户端逻辑 将新的输入合并到本地变更 ace2_inner.js 12var editor = new Ace2Inner()editor.init(); ace.js 1234567891011121314151617181、editor.init = function(containerId, initialCode, doneFunc)&#123;&#125;2、doActionsPendingInit()3、aceFunctionsPendingInit.getFormattedCode4、ace2_inner.jsfunction getFormattedCode()&#123; inCallStackIfNecessary(\"getFormattedCode\", incorporateUserChanges);&#125;5、function observeSuspiciousNodes()6、function incorporateUserChanges(isTimeUp)fastIncorp()inCallStackIfNecessary(\"handleKeyEvent\", function()&#123;&#125; 向服务器提交变更集 12345671、collab_client.js2、function getCollabClient(ace2editor, serverVars, initialUserInfo, options, _pad)&#123;&#125;3、editor.setUserChangeNotificationCallback(wrapRecordingErrors(\"handleUserChanges\", handleUserChanges));4、handleUserChanges() 回复确认已提交的变更集(ack) 监听其他客户的变更集 连接到服务器并请求初始文档 pad.html 1&lt;script type=\"text/javascript\"&gt; pad.init(); &lt;/script&gt; pad.js 123456781、init: function()2、function handshake()3、socket.once('connect', function () &#123; sendClientReady(false); &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475skinparam ParticipantPadding 90title 客户端处理流程\\n\\n||||||Server &lt;- Client: first connect &lt;&lt; unique ID &gt;&gt;note rightasync.waterfall()end notenote right of A #aqua收到服务器确认的变更状态end notenote right of X #aqua把变更发到服务器时的状态end notenote right of Y #aqua用户已输入的状态end notenote right of E #aqua用户正在输入end note|||Client &lt;- Server: HEADTEXT|||note over Client , Aidentity mappingend note|||A &lt;-[#0000FF]- X: A=X*A|||X &lt;-[#0000FF]- Y:note rightY=Y*Eend note|||Y &lt;-[#ED3EEE] E: types|||Y -[#0000FF]-&gt; Server: submit &lt;&lt; cs+uid &gt;&gt;|||note over A , Yevery 500msend note|||A &lt;-- Server: acknowledgement |||&quot;Other clients&quot; &lt;-- Client : monitor other client|||&quot;Other clients&quot; --&gt; Server: other cs|||Client -&gt; Client: composenote leftmakeChangesetTracker()end note|||Server -&gt; Server: server logic||| 后续产品化工作\b 长连接多机分布 数据库扩展 账户系统 运维自动化系统 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"EtherPad","slug":"Code/EtherPad","permalink":"http://xiaoqinghua.site/categories/Code/EtherPad/"}],"tags":[{"name":"EtherPad","slug":"EtherPad","permalink":"http://xiaoqinghua.site/tags/EtherPad/"}]},{"title":"ComposeAttributes 算法解析","slug":"composeAttributes算法解析","date":"2018-06-18T07:10:02.000Z","updated":"2018-08-24T07:43:25.475Z","comments":true,"path":"composeAttributes算法解析.html","link":"","permalink":"http://xiaoqinghua.site/composeAttributes算法解析.html","excerpt":"","text":"何时用 composeAttributes在compose算法中，op两两进行运算，何时进行属性的合并即composeAttributes，在代码中我们可以发现，仅在op1，op2的opcode同时为‘=’时，或者op2的opcode为‘=’，op1的opcode为‘+’时进行\bcomposeAttributes。 为何用 composeAttributes composeAttributes函数注释\b 12345678910111213// att1 and att2 are strings like \"*3*f*1c\", asMutation is a boolean.// Sometimes attribute (key,value) pairs are treated as attribute presence// information, while other times they are treated as operations that// mutate a set of attributes, and this affects whether an empty value// is a deletion or a change.// Examples, of the form (att1Items, att2Items, resultIsMutation) -&gt; result// ([], [(bold, )], true) -&gt; [(bold, )]// ([], [(bold, )], false) -&gt; []// ([], [(bold, true)], true) -&gt; [(bold, true)]// ([], [(bold, true)], false) -&gt; [(bold, true)]// ([(bold, true)], [(bold, )], true) -&gt; [(bold, )]// ([(bold, true)], [(bold, )], false) -&gt; []// pool can be null if att2 has no attributes. 123以上注释大概意思：att1和att2是类似于“*3*f*1c”的字符串，resultIsMutation是一个布尔值。有时属性(键、值)对被视为属性存在信息，而有时它们被视为改变一组属性的操作，这将影响空值是删除还是更改。 \b通过compose算法我们了解到，仅在op1，op2的opcode同时为‘=’时，\b此时的op1，op2两两运算才是操作的同一段文本字符(\b如\bop1为+，op2为-)操作的不是同一处文本。 composeAttributes 过程 准备AttributePool 1234567var p = new AttributePool();p.putAttrib(['x', '']);p.putAttrib(['x', 'abc']);p.putAttrib(['x', 'def']);p.putAttrib(['y', '']);p.putAttrib(['y', 'abc']);p.putAttrib(['y', 'def']); 构造运算 12assertEqualStrings('*0*3', Changeset.composeAttributes('*0*4', '*2*3', true, p));assertEqualStrings('*0*4', Changeset.composeAttributes('*2*3', '*0*4', true, p)); AttributePool中\b依次存入了6个属性: 1234567891011121314151617181920212223242526&#123; \"0\": [ \"x\", \"\" ], \"1\": [ \"x\", \"abc\" ], \"2\": [ \"x\", \"def\" ], \"3\": [ \"y\", \"\" ], \"4\": [ \"y\", \"abc\" ], \"5\": [ \"y\", \"def\" ]&#125; op1使用的属性为\b&quot;0&quot;: [&quot;x&quot;,&quot;&quot;]、&quot;4&quot;: [&quot;y&quot;,&quot;abc&quot;]，op2使用的属性为\b&quot;2&quot;: [&quot;x&quot;,&quot;def&quot;]、&quot;3&quot;: [&quot;y&quot;,&quot;&quot;] 代码详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static String composeAttributes(String att1, String att2, boolean resultIsMutation, AttributePool pool) &#123; // 这两步其实和 followAttributes 相似，在外层函数，都有对应情况的代码 if (isEmpty(att1) &amp;&amp; resultIsMutation) &#123; // In the case of a mutation (i.e. composing two exportss), // an att2 composed with an empy att1 is just att2. If att1 // is part of an attribution string, then att2 may remove // attributes that are already gone, so don't do this optimization. return att2; &#125; if (isEmpty(att2)) &#123; return att1; &#125; // 新建一个空的集合即我们想要的最后结果属性集 // 下面做的操作就是把 att1 的属性加到 atts 中，其实 atts 就是 att1 List&lt;Attribute&gt; atts = new LinkedList&lt;&gt;(); // 经过不断的正则匹配迭代 atts==att1 Matcher matcher = PATTERN_ATTRIBUTE.matcher(att1); while (matcher.find()) &#123; String attId = matcher.group(1); atts.add(pool.getAttrib(parseNum(attId))); &#125; // 这里使用嵌套循环，相当于两两对比 att1 和 att2 相同 key 对应是否有值或者是否突变 // 只是我们最终得到的都是att2的值，在一次次比较中删除 att2 中的值，或者 设置成以前 att1 的值 matcher = PATTERN_ATTRIBUTE.matcher(att2); while (matcher.find()) &#123; String attId = matcher.group(1); Attribute pair = pool.getAttrib(parseNum(attId)); boolean found = false; for (int i = 0; i &lt; atts.size(); i++) &#123; Attribute oldPair = atts.get(i); if (oldPair.getKey().equals(pair.getKey())) &#123; if (pair.hasValue() || resultIsMutation) &#123; // 注意这里是 set, 即替换成 att2 的值 // 遇到相同的 key, 如果 att2 有值或者是突变，就把 att1 中的值替换成 att2 的值 atts.set(i, oldPair.withValue(pair.getValue())); &#125; else &#123; // 遇到相同的 key, 如果 att2 没有值，则删除 att1 中的值(即 atts 的值) atts.remove(i); &#125; found = true; break; &#125; &#125; // 如果没有找到相同的 key 则直接用 att2 if ((!found) &amp;&amp; (pair.hasValue() || resultIsMutation)) &#123; atts.add(pair); &#125; &#125; // atts 这里进行了自然排序，所以在 followAttributes 的时候按照自然排序取值 // 在 js 源码中，atts.sort(); // atts.sort();没有 compareFunction 参数，所以排序时直接将数组的元素转换成字符串，按照字符串的 Unicode 排序 atts.sort(Comparator.comparing(Attribute::toString)); StringAssembler buf = new StringAssembler(); for (int i = 0; i &lt; atts.size(); i++) &#123; buf.append(\"*\"); buf.append(numToString(pool.putAttrib(atts.get(i)))); &#125; //print(att1+\" / \"+att2+\" / \"+buf.toString()); return buf.toString();&#125; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"Compose 算法过程验算","slug":"compose算法过程验算","date":"2018-06-18T07:09:51.000Z","updated":"2018-08-24T07:43:39.098Z","comments":true,"path":"compose算法过程验算.html","link":"","permalink":"http://xiaoqinghua.site/compose算法过程验算.html","excerpt":"","text":"举个栗子🌰 1compose(cs1,cs2) --&gt; compose(\"Z:z&gt;4|2=m=b-1+2+3$abcde\", \"Z:13&gt;1|2=m=g-1+2$fg\") 123456789101112131415把cs1,cs2展开cs1:op1.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op1.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op1.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op1.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op1.5:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;charBank=&apos;abcde&apos;cs2:op2.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2.2:&#123; opcode: &apos;=&apos;, chars: 16, lines: 0, attribs: &apos;&apos; &#125;op2.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;charBank=&apos;fg&apos; 同follow函数一样，在compose函数中也有一个applyZip的函数,其实这是一个迭代器,同时还有一个_slicerZipperFunc的分片迭代器，是专门为compose准备的函数。zip有拉链的意思,在迭代的过程中不断的两两运算,就像拉链一样一颗颗缝合起来: applyZip函数 1234567891011121314151617181920exports.applyZip = function (in1, idx1, in2, idx2, func) &#123; var iter1 = exports.opIterator(in1, idx1); var iter2 = exports.opIterator(in2, idx2); var assem = exports.smartOpAssembler(); var op1 = exports.newOp(); var op2 = exports.newOp(); var opOut = exports.newOp(); while (op1.opcode || iter1.hasNext() || op2.opcode || iter2.hasNext()) &#123; if ((!op1.opcode) &amp;&amp; iter1.hasNext()) iter1.next(op1); if ((!op2.opcode) &amp;&amp; iter2.hasNext()) iter2.next(op2); func(op1, op2, opOut); if (opOut.opcode) &#123; //print(opOut.toSource()); assem.append(opOut); opOut.opcode = ''; &#125; &#125; assem.endDocument(); return assem.toString();&#125;; _slicerZipperFunc函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * Function used as parameter for applyZip to apply a Changeset to an attribute */ private static Op _slicerZipperFunc(Op attOp, Op csOp, AttributePool pool) &#123; // attOp is the op from the sequence that is being operated on, either an // attribution string or the earlier of two exportss being composed. // pool can be null if definitely not needed. //print(csOp.toSource()+\" \"+attOp.toSource()+\" \"+opOut.toSource()); // 在 compose 中 ，attOp 是正在被操作的即 op1 Op opOut = new Op(); if (attOp.isMinus()) &#123; // 如果 op1 是 - ，则我们需要的 opOut 使用 op1 Op.copyOp(attOp, opOut); // 清空 op1 操作 attOp.clearOpcode(); &#125; else if (!attOp.hasOpcode()) &#123; // 如果 op1 没有操作，则使用 op2 Op.copyOp(csOp, opOut); // 清空 op2 操作 csOp.clearOpcode(); &#125; else &#123; switch (csOp.opcode) &#123; case Op.OPCODE_MINUS: &#123; // 如果 op2 操作的字符小于等于 op1 操作的字符 if (csOp.chars &lt;= attOp.chars) &#123; // delete or delete part if (attOp.isKeep()) &#123; // 如果 op2 是 -,op1 是 = // 合并后的是-，可以理解为，先=后- opOut.opcode = Op.OPCODE_MINUS; // 取小的部分 opOut.chars = csOp.chars; opOut.lines = csOp.lines; opOut.attribs = EMPTY_STRING; &#125; // 如果 op2 是 -,op1 是 + // 得到是空的 opOut ，相当于不做任何操作，直至没有下一次运算 attOp.chars -= csOp.chars; attOp.lines -= csOp.lines; csOp.clearOpcode(); if (attOp.chars == 0) &#123; attOp.clearOpcode(); &#125; &#125; else &#123; // 如果 op2 操作的字符大于 op1 操作的字符 // delete and keep going if (attOp.isKeep()) &#123; // 如果 op2 是 -,op1 是 = // 合并后的是-，可以理解为，先=后- opOut.opcode = Op.OPCODE_MINUS; // 取小的部分 opOut.chars = attOp.chars; opOut.lines = attOp.lines; opOut.attribs = EMPTY_STRING; &#125; // 取相减的部分 csOp.chars -= attOp.chars; csOp.lines -= attOp.lines; attOp.clearOpcode(); &#125; break; &#125; case Op.OPCODE_PLUS: &#123; // insert // 如果 op2 是 +，则合并后还是 + Op.copyOp(csOp, opOut); csOp.clearOpcode(); break; &#125; case Op.OPCODE_KEEP: &#123; // 如果 op2 是 = // 如果 op2 操作的字符小于等于 op1 操作的字符 if (csOp.chars &lt;= attOp.chars) &#123; // keep or keep part 保持或者保持一部分(保持 op1 的操作和全部的操作字符串和换行 或者 保持 op1 的操作和一部分的操作字符串和换行) // 可以理解为：op1增加或者保持了n个字符，op2保持了m个字符(m&lt;=n) opOut.opcode = attOp.opcode; opOut.chars = csOp.chars; opOut.lines = csOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); csOp.clearOpcode(); // 剩余部分 attOp.chars -= csOp.chars; attOp.lines -= csOp.lines; if (attOp.chars == 0) &#123; attOp.clearOpcode(); &#125; &#125; else &#123; // 如果 op2 操作的字符大于 op1 操作的字符 // keep and keep going 保持并且继续 opOut.opcode = attOp.opcode; opOut.chars = attOp.chars; opOut.lines = attOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); attOp.clearOpcode(); // 剩余部分 csOp.chars -= attOp.chars; csOp.lines -= attOp.lines; &#125; break; &#125; case EMPTY_STRING: &#123; // 如果 op2 是 空操作，则合并后还是 op1 的操作 Op.copyOp(attOp, opOut); attOp.clearOpcode(); break; &#125; &#125; &#125; return opOut; &#125; 1234567891011开始迭代(循环)前,需要做一些准备工作:1、新建两个空的op1,op2对象，用于接收展开的cs1,cs2中所有的op对象的值Op op1 = new Op();op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;Op op2 = new Op();op2:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、新建一个opOut对象,用于接收每一次迭代完后我们得到的运算结果opOp opOut = new Op();opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125; 1234567891011121314第1次迭代:1、初始:按照顺序会使用cs1中的op1.1和cs2中的op2.1和一个刚刚new出来的新的op对象op1.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;op2.1:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 22, lines: 2, attribs: &apos;&apos; &#125;assem : &quot;|2=m&quot;说明:both keep,compose之后op1,op2都没opcode,所以重新赋值next() 对应第1次迭代的具体代码:1234567891011121314151617181920case Op.OPCODE_KEEP: &#123; // 如果 op2 是 = // 如果 op2 操作的字符小于等于 op1 操作的字符 if (csOp.chars &lt;= attOp.chars) &#123; // keep or keep part 保持或者保持一部分(保持 op1 的操作和全部的操作字符串和换行 或者 保持 op1 的操作和一部分的操作字符串和换行) // 可以理解为：op1增加或者保持了n个字符，op2保持了m个字符(m&lt;=n) opOut.opcode = attOp.opcode; opOut.chars = csOp.chars; opOut.lines = csOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); csOp.clearOpcode(); // 剩余部分 attOp.chars -= csOp.chars; attOp.lines -= csOp.lines; if (attOp.chars == 0) &#123; attOp.clearOpcode(); &#125; &#125; 123456789101112第2次迭代:1、初始:op1.2:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2.2:&#123; opcode: &apos;=&apos;, chars: 16, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 5, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;=&apos;, chars: 11, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;说明:both keep,compose之后op2还有opcode,所以重新赋值next() 对应第2次迭代的具体代码:12345678910111213else &#123; // 如果 op2 操作的字符大于 op1 操作的字符 // keep and keep going 保持并且继续 opOut.opcode = attOp.opcode; opOut.chars = attOp.chars; opOut.lines = attOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); attOp.clearOpcode(); // 剩余部分 csOp.chars -= attOp.chars; csOp.lines -= attOp.lines;&#125; 123456789101112第3次迭代:1、初始:op1.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 5, lines: 0, attribs: &apos;&apos; &#125;(第2次循环compose算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 5, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;，minusAssem : &quot;-1&quot;说明:op1-,op2=,compose之后op2还有opcode,所以重新赋值next() 对应第3次迭代的具体代码: 1234// 如果 op1 是 - ，则我们需要的 opOut 使用 op1Op.copyOp(attOp, opOut);// 清空 op1 操作attOp.clearOpcode(); 123456789101112第4次迭代:1、初始:op1.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 5, lines: 0, attribs: &apos;&apos; &#125;(第3次循环compose算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;, minusAssem : &quot;-1&quot;, plusAssem : &quot;+2&quot;说明:op1+,op2=,compose之后op1没opcode,所以重新赋值next() 对应第4次迭代的具体代码:12345678910111213&#125; else &#123; // 如果 op2 操作的字符大于 op1 操作的字符 // keep and keep going 保持并且继续 opOut.opcode = attOp.opcode; opOut.chars = attOp.chars; opOut.lines = attOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); attOp.clearOpcode(); // 剩余部分 csOp.chars -= attOp.chars; csOp.lines -= attOp.lines;&#125; 123456789101112第5次迭代:1、初始:op1.5:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;=&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;(第4次循环compose算法后的op2)opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;+&apos;, chars: 3, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;, minusAssem : &quot;-1&quot;, plusAssem : &quot;+2+3&quot;说明:op1+,op2=,compose之后op1,op2都没opcode,所以重新赋值next(),但此时op1已没有next(),故op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125; 对应第5次迭代的具体代码:12345678910111213141516if (csOp.chars &lt;= attOp.chars) &#123; // keep or keep part 保持或者保持一部分(保持 op1 的操作和全部的操作字符串和换行 或者 保持 op1 的操作和一部分的操作字符串和换行) // 可以理解为：op1增加或者保持了n个字符，op2保持了m个字符(m&lt;=n) opOut.opcode = attOp.opcode; opOut.chars = csOp.chars; opOut.lines = csOp.lines; // 合并属性 opOut.attribs = composeAttributes(attOp.attribs, csOp.attribs, attOp.isKeep(), pool); csOp.clearOpcode(); // 剩余部分 attOp.chars -= csOp.chars; attOp.lines -= csOp.lines; if (attOp.chars == 0) &#123; attOp.clearOpcode(); &#125;&#125; 123456789101112第6次迭代:1、初始:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;(next()没有下一个时，是返回一个新的op)op2.3:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;-&apos;, chars: 1, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;, minusAssem : &quot;-1-1&quot;, plusAssem : &quot;+2+3&quot;说明:op2-,compose之后op1，op2没opcode,所以重新赋值next() 对应第6次迭代的具体代码:1234// 如果 op1 没有操作，则使用 op2Op.copyOp(csOp, opOut);// 清空 op2 操作csOp.clearOpcode(); 123456789101112第7次迭代:1、初始:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;(next()没有下一个时，是返回一个新的op)op2.4:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;2、compose算法后:op1:&#123; opcode: &apos;&apos;, chars: 0, lines: 0, attribs: &apos;&apos; &#125;op2:&#123; opcode: &apos;&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;opOut:&#123; opcode: &apos;+&apos;, chars: 2, lines: 0, attribs: &apos;&apos; &#125;assem : &quot;|2=m=b&quot;, minusAssem : &quot;-1-1&quot;, plusAssem : &quot;+2+3+2&quot;说明:op2+，compose之后op1,op1,op2都没有opcode,也没有next()了,停止 对应第7次迭代的具体代码:1234// 如果 op1 没有操作，则使用 op2Op.copyOp(csOp, opOut);// 清空 op2 操作csOp.clearOpcode(); 算法结果12345678910111213141516171819202122231 Changeset = require(\"./src/static/js/Changeset\");2 var csA = \"Z:z&gt;4|2=m=b-1+2+3$abcde\";3 var csB = \"Z:13&gt;1|2=m=g-1+2$fg\";45 var doc1 = \"Hello World\\n\\n Hello World Hello Wor\";6 var doc2 = \"Hello World\\n\\n Hello World Hello Wabcder\";78 var appliedA = Changeset.applyToText(csA,doc1);9 console.log('apply csA:', appliedA);10 console.log('');11 console.log('appliedA==doc2:', appliedA==doc2);1213 console.log('');14 var appliedB = Changeset.applyToText(csB,doc2);1516 console.log('apply csB:', appliedB);17 console.log('');1819 var cs = Changeset.compose(csA,csB,false,null);20 var applied = Changeset.applyToText(cs,doc1);2122 console.log('final doc:', applied);23 1234567891011121314apply csA: Hello World Hello World Hello WabcderappliedA==doc2: trueapply csB: Hello World Hello World Hello Wabcdefgfinal doc: Hello World Hello World Hello Wabcdefg 123456789&gt; var cs1 = \"Z:z&gt;4|2=m=b-1+2+3$abcde\";&gt; var cs2 = \"Z:13&gt;1|2=m=g-1+2$fg\";&gt; Changeset.compose(cs1,cs2,false,null);'Z:z&gt;5|2=m=b-2+7$abcdefg'最终的CS:'Z:z&gt;5|2=m=b-2+7$abcdefg' 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"Hackpad 技术分析","slug":"hackpad技术分析","date":"2018-05-20T05:58:53.000Z","updated":"2018-08-24T07:44:37.190Z","comments":true,"path":"hackpad技术分析.html","link":"","permalink":"http://xiaoqinghua.site/hackpad技术分析.html","excerpt":"","text":"hackpad 技术分析前言 1、hackpad 是基于 etherpad 二次开发，增加了很多产品化的功能，如\b账户系统，文档权限等。\b腾讯文档也是基于 hackpad 开发，\b腾讯文档的表格则是基于开源项目 hansontable 作为前端载体，在协作算法上对 easysync 进行了略微的修改。 2、hackpad 同样是基于 client + server模式开发，通讯协议大体相同，做了小幅修改，OT算法\b都是使用easysync，\b客户端服务端流程可以参考 etherpad 技术分析。 3、hackpad 项目是由 scala + java + js 的组合，hackpad使用了Jetty在scala上搭建的Websocket Server (在infrastructure目录下的main.scala中完成) 实现通讯，同时也使用了etherpad使用的开源 SocketIO 库，来完成基于双向通信的实时协同。 4、以下技术调研\b是在etherpad的调研基础下对hackpad表格，图片，协议等方面的梳理。 1、行 &amp; 表格换行操作hackpad光标每一次换行，客户端都会发送 CLIENT_MESSAGE ，其中负载&quot;type&quot;:&quot;caret&quot;，changeBy\b代表作者，如图： 上述协议相当于定位的作用，结合左侧的用户实时行定位\b功能如下图： 综上：标题 &quot;caret&quot;:0, 正文的第一行 &quot;caret&quot;:1 ,正文的第n行 &quot;caret&quot;:n 例: 在标题行插入一个 a，客户端会同时发送两条协议数据 1、CLIENT_MESSAGE \b负载 caret 位置信息 1234567891011&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"CLIENT_MESSAGE\", \"payload\": &#123; \"type\": \"caret\", \"caret\": 0, \"changedBy\": \"p.1\" &#125; &#125;&#125; 2、USER_CHANGES，数据结构较于 etherpad 没有变化 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 59, \"changeset\": \"Z:1&gt;1*0+1$a\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"author\", \"p.1\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 插入表格 在正文第一行插入一个表格(table)，客户端会同时发送三条协议数据 1、CLIENT_MESSAGE \b负载 caret 位置信息 插入之前，光标位置 1234567891011&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"CLIENT_MESSAGE\", \"payload\": &#123; \"type\": \"caret\", \"caret\": 1, \"changedBy\": \"p.1\" &#125; &#125;&#125; 插入之后，光标位置 1234567891011&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"CLIENT_MESSAGE\", \"payload\": &#123; \"type\": \"caret\", \"caret\": 3, \"changedBy\": \"p.1\" &#125; &#125;&#125; 2、USER_CHANGES 123456789101112131415161718192021&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 61, \"changeset\": \"Z:3&gt;3|1=2*0|1+1*0*1+1*0|1+1$\\n*\\n\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"author\", \"p.1\" ], \"1\": [ \"table\", \"123\" ] &#125;, \"nextNum\": 2 &#125; &#125;&#125; 根据changeset规范解析上述通信协议数据 123pack the changeset `Z:3&gt;3|1=2*0|1+1*0*1+1*0|1+1$\\n*\\n`&#123; oldLen: 3,newLen: 6,ops: '|1=2*0|1+1*0*1+1*0|1+1',charBank: '\\n*\\n' &#125; operator:12345678910&#123; opcode: '=', chars: 2, lines: 1, attribs: '' &#125;插入一个空行 \\n&#123; opcode: '+', chars: 1, lines: 1, attribs: '*0' &#125;插入一个表格 * (*代表表格，图片，嵌入的文件)(img/embed/table)&#123; opcode: '+', chars: 1, lines: 0, attribs: '*0*1' &#125;插入一个空行 \\n&#123; opcode: '+', chars: 1, lines: 1, attribs: '*0' &#125; 插入表格代码： 123456789101112131415161718var rep = ace.getRep();// don't insert tables in title linevar selStart = [rep.selStart[0], rep.selStart[1]];var selEnd = [rep.selEnd[0], rep.selEnd[1]];if (selStart[0] == 0) &#123; selStart = [1, 0]; selEnd = [1, 0]; // make sure the table is on its own line, // (and not the title line) ace.replaceRange(selStart, selStart, '\\n\\n', []);&#125; else &#123; // make sure the table is on its own line, // (and not the title line) ace.replaceRange(selStart, selEnd, '\\n\\n', []); selStart = [selStart[0] + 1, 0];&#125;ace.replaceRange(selStart, selStart, '*', [['table', '123']]);padeditor.ace.focus(); 12345678910111213141516/** * Replace a range of text with new text. * @param &#123;Array.&lt;number&gt;&#125; start The line/column of the range start. * @param &#123;Array.&lt;number&gt;&#125; end The line/column of the range end. * @param &#123;string&#125; text The new text. * @param &#123;Array&#125; attribs The new attributes for this text. * @param &#123;boolean&#125; insertsAfterSelection The new text goes after the range. */self.replaceRange = function(start, end, text, attribs, insertsAfterSelection) &#123; self.inCallStackIfNecessary('replaceRange', function() &#123; self.fastIncorp(); self.performDocumentReplaceRange(start, end, text, attribs, insertsAfterSelection); &#125;);&#125; 编辑表格数据 在表格的第一个格子坐标(0:0)位置插入一个字符b 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 67, \"changeset\": \"Z:7&gt;0|2=3*0=1$\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"0:0\", \"b\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 在表格的第一个格子坐标(0:0)位置追加一个字符c 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 68, \"changeset\": \"Z:7&gt;0|2=3*0=1$\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"0:0\", \"bc\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 在表格的第一个格子坐标(0:1)位置插入一个字符d 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 69, \"changeset\": \"Z:7&gt;0|2=3*0=1$\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"0:1\", \"d\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 在表格的第一个格子坐标(1:0)位置插入一个字符e 1234567891011121314151617&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 70, \"changeset\": \"Z:7&gt;0|2=3*0=1$\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"1:0\", \"e\" ] &#125;, \"nextNum\": 1 &#125; &#125;&#125; 综上： 插入一个表格，会直接在apool 增加一个[&#39;table&#39;, &#39;123&#39;]属性 表格有位置坐标 | (0,0) | (0,1) | | — | — | | (1,0) | (1,1) | | (2,0) | (2,1) | 替换每个坐标里的值，会在apool中新生成一个[&quot;1:0&quot;, &quot;abc&quot;] 往每个坐标里追加值，会在apool中替换已生成的坐标位置一样的新值[&quot;1:0&quot;, &quot;123&quot;] 表格里的字符是不能使用加粗，下划线，等\b附加属性的，这个功能还有待开发（\b如果基于hackpad现有的表格设计，使用apool中的属性，已经很难再设计出附加属性的添加，猜测腾讯文档应该是做了其他的优化） 上述这些\b增加，追加的方式编辑表格数据，通过对属性apool的操作，\b\b然后根据 Changeset.applyToText(cs,str)方法，从而不需要\b把表格那一个range的 text(文本数据)进行OT算法实现就可以实现文档中表格数据的协同编辑\b。 2、图片直接\b copy 图片 url123456789101112131415161718192021&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 8, \"changeset\": \"Z:s&gt;15|4=q*0*1+1*0|1+1*0+13$*\\nhttps://p.upyun.com/docs/cloud/demo.jpg\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"author\", \"p.1\" ], \"1\": [ \"img\", \"https://p.upyun.com/docs/cloud/demo.jpg\" ] &#125;, \"nextNum\": 2 &#125; &#125;&#125; 直接 copy 图片 url, 是直接在charbank:{*\\nurl}\b ,*表示图片，\\n表示换一行，url表示图片链接,和 etherpad 不同在于*表示图片。 和插入表格一样，都会在\bapool里新增属性&quot;1&quot;:[&quot;img&quot;,&quot;https://p.upyun.com/docs/cloud/demo.jpg&quot;] 上传本地图片 hackpad 图片存储使用 AWS 的 S3 存储服务 12345678910111213141516171819202122232425&#123; \"type\": \"COLLABROOM\", \"data\": &#123; \"type\": \"USER_CHANGES\", \"baseRev\": 37, \"changeset\": \"Z:f&gt;1|4=e*0*1*2+1$*\", \"apool\": &#123; \"numToAttrib\": &#123; \"0\": [ \"attachmentPlaceholder\", \"attachment-1531119782428\" ], \"1\": [ \"author\", \"p.1\" ], \"2\": [ \"img\", \"/static/img/pixel.gif\" ] &#125;, \"nextNum\": 3 &#125; &#125;&#125; 1234567891011awsUser = __aws_key_id__awsPass = __aws_secret__s3Bucket = __aws_attachments_bucket__s3Region = us-east-1相关代码:editor.performDocumentReplaceRange(start, end, '*', [ ['img', '/static/img/pixel.gif'], ['attachmentPlaceholder', attachmentId]]); 上传图片的方法： 构造FormData数据，使用ajax上传到S3\b 12345678910111213141516171819202122232425262728$.ajax(&#123; xhr: function() &#123; var xhr = new window.XMLHttpRequest(); xhr.upload.addEventListener(\"progress\", function(evt) &#123; if (evt.lengthComputable) &#123; var progress = evt.loaded / evt.total; editor.callWithAce(function (ace) &#123; setAttachmentUrlProgress(attachmentId, progress); &#125;); &#125; &#125;, false); return xhr; &#125;, url: s3host, data: form, processData: false, contentType: false, type: \"POST\", success: function() &#123; setTimeout(function() &#123; editor.callWithAce(function (ace) &#123; setAttachmentUrl(attachmentId, s3host + path, path); &#125;); observer.trigger('track', ['file-attach', null, null, &#123; success: true, padId: clientVars.padId, userId: clientVars.userId, type: file.type, path: path, size: file.size, uploadSize: shrunk.size &#125;]); &#125;, 500&#125;) 3、Ace编辑器 &amp; Changeset变更集 &amp; AttribPool属性池hackpad 的项目结构： hackpad bin 构建项目和启动项目的命令 contrib cron 包含一个清理的定时任务 glue 包含一些 python 脚本 runit 包含设置容器的一些脚本 scripts 设置数据库和服务的一些脚本 testing 测试\b目录 etherpad bin 在本地启动项目的命令 data 本地的数据，包含日志和 solr 全文搜索服务器 etc 一些\b配置文件 solr solr 全文搜索服务器 src etherpad etherpad\b 产品功能代码 locals \b语言设置 static etherpad 静态代码\b包含 ace 编辑器 easy_sync 算法等\b themes \b主题文件 .ejs 模板 appjet-eth-dev.jar 编译 infrastructure 目录下的.scala 文件生成的项目 infrastructure Scala \b目录，目前不是太懂 lib 包含一个数据库连接件 1、ace 编辑器 相对于\betherpad，ace编辑器\b功能没有太大的变化，整个ace目录结构分离，同时增加了ace_table表格，ace_media\b\b，ace_caret等抽象模块。 2、Changeset 变更集 相对于\betherpad，changeset\b功能没有变化，即便是加了table，image还是和etherpad的相同。 hackpad的changeset结构上做了分离。抽离成easysync1.js，easysync2.js。 easysync1.js包含changeset自身的一些方法，包括Changeset.decodeFromString，Changeset.numberArrayToString等。 easysync2.js包含changeset的OT功能上的一些方法，包括Changeset.follow，Changeset.compose等。 3、AttribPool 属性池 相对于\betherpad，AttribPool\b则没有改变。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"OT","slug":"Code/OT","permalink":"http://xiaoqinghua.site/categories/Code/OT/"}],"tags":[{"name":"OT","slug":"OT","permalink":"http://xiaoqinghua.site/tags/OT/"}]},{"title":"云文档的难点","slug":"云文档的难点","date":"2018-04-05T06:50:30.000Z","updated":"2018-08-05T06:57:09.278Z","comments":true,"path":"云文档的难点.html","link":"","permalink":"http://xiaoqinghua.site/云文档的难点.html","excerpt":"","text":"1. 多人协作，实时同步在云文档上同时编写的客户可能会非常多，如果一个成员更新了别的成员无法及时看到，或者几个成员无法同时更新，那就不可能实现团队协作，甚至会出现业务错误风险。在石墨文档上，用户输入的每一个文字都需要在毫秒级尺度内实时计算，并传给同一个文档的其他协作者。为此，石墨文档引用了 NATS 数据管道，对进入服务器的所有流量进行削峰填谷的处理。在数据高峰期引入服务器的数据进行延时处理，等待空闲时间再计算，从而使服务器可以平稳运行。同时基于此，还实现了根据数据流量对后端服务器自动扩容，当数据量突然增大时，自动增加服务器，提高整个系统负载能力。 2.多客户端实时同步 互联网时代，各种终端层出不穷，每个人日常中至少会使用两种设备，手机和电脑，如果一个人同时在手机和电脑上编辑同一份笔记，出现冲突时，很多笔记类应用会为每一个冲突创建独立的副本，需要用户手工合并，使得用户使用笔记便利性大大下降； 为了支持实时协作，石墨文档技术团队对算法进行了改进，这个算法可以解决一段文字，多个客户端同时修改引起的冲突合并问题。另外到目前为止，已经适配了 50 种不同的机器和浏览器。 3.离线编辑，避免冲突离线编辑，用户同步过来的数据往往是他几个小时编写的成果，此时，这个版本或已经与服务器的版本相差甚远了，按着此前方法，如何解决文档冲突是个问题。 对此，石墨文档尽可能多地记录用户编辑过程中的每一步操作，然后利用各用户端的历史操作信息挨个重放，从而还原用户编辑的本意。比如，对于“今天天气很好”，第一个人可能会删除中间的“天气”两字，变成“今天很好”；而另外一个人可能会加上一个“真”字，变成“今天天气真的很好”，按着石墨文档的基于还原用户意图的算法，最后合并的结果则是“今天真的很好”，既满足删除“天气”，又满足增加“真”的双方意图。当然，这种合并方法也并非百分百完美，但李子骅表示这是最适合目前编写体验的。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Cloud-Office","slug":"Code/Cloud-Office","permalink":"http://xiaoqinghua.site/categories/Code/Cloud-Office/"}],"tags":[{"name":"Cloud-Office","slug":"Cloud-Office","permalink":"http://xiaoqinghua.site/tags/Cloud-Office/"}]},{"title":"VIM练习手册","slug":"VIM练习手册","date":"2018-02-25T06:42:48.000Z","updated":"2018-08-24T07:45:22.116Z","comments":true,"path":"VIM练习手册.html","link":"","permalink":"http://xiaoqinghua.site/VIM练习手册.html","excerpt":"","text":"==VIM命令==1.一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 1234567Ctrl+f 向下移动一页Ctrl+b 向上移动一页0 移动到这一行的最前面的字符处$ 移动到这一行的最后面的字符处G 移动到文本的最后一行gg 移动到文本的第一行，相当于1Gn&lt;Enter&gt; n为数字。光标向下移动n行 搜索替换 12345/word 向光标之下查询“word”的字符串n 查找到“word”之后,光标定位到下一个“word”N 与n相反,定位到上一个:n1,n2s/word1/word2/g 在n1行与n2行之间查询“word1”,并替换成“word2”:n1,$s/word1/word2/gc 在n1行与文本最后一行之间查询“word1”,并替换成“word2”,并提示用户 删除、复制、粘贴 1234567891011121314x(小写) 相当于[del]键X(大写) 相当于[backspace]键dd 删除光标所在的那一行ndd 删除光标所在的行下n行yy 复制光标所在的那一行nyy 复制光标所在的行下n行p(小写) 将复制的内容粘贴在光标下一行P(大写) 将复制的内容粘贴在光标上一行J(大写) 将当前光标行与下一行，拼成一行u 恢复Crtl+r 重做. 重复上一个命令注意: dd,yy 都可以与“0”,“$”,“G”配合使用 一般模式切换到编辑模式的可用的按钮说明12345678i 在当前光标处开始输入I 在当前行的第一个非空格处开始输入a 在当前光标的下一个字符处开始输入A 在当前行的最后一个字符处开始输入o 在当前行的下一行处输入新的一行O 在当前行的上一行处输入新的一行r 取代模式，只会取代光标所在字符一次R 取代模式，会一直取代光标所在的文字，直到按下ESC键 一般模式切换到命令行模式的可用的按钮说明123:w 保存，退出:q 仅仅是退出vi编辑器，如果没有修改直接退出，如果有修改会提示，可以使用:q!不存储修改部分，强制退出:wq 存储后退出 牛逼的技巧 单词移动 1234567W w 移动到下一个单词开头E e 移动到下一个单词结尾B b 倒退到上一个单词开头- E会忽略标点符号，如：I‘m，e会当成两个单词，E则不会- 2w，表示往下移动2个单词- 一般用小写的就可以了 整行移动 12340 移动到行首$ 移动到行末+ 移动到下一行开头- 移动到上一行开头 滚屏 1234567Ctrl+f 往前滚动一整屏Ctrl+b 往后滚动一整屏Ctrl+d 往前滚动半屏Ctrl+u 往后滚动半屏Ctrl+e 往后滚动一行 Ctrl+y 往前滚动一行 用z调整光标 123z&lt;Enter&gt; 将光标所在行移动到屏幕顶端z. 将光标所在行移动到屏幕中间z- 将光标所在行移动到屏幕低端 在屏幕中移动 123456H 移动到屏幕顶端的行M 移动到屏幕中央的行L 移动到屏幕底端的行nH 移动到屏幕顶端往下的第n行nL 移动到屏幕顶端往上的第n行 单词删除 12345dw 删除到下一个单词开头de 删除到本单词末尾dE 删除到本单词末尾包括标点在内db 删除到前一个单词dB 删除到前一个单词包括标点在内 单词修改 12cw 从光标处修改到单词结尾cb 从光标处修改到单词开头 行修改 123456c$ 从光标修改到本行末尾C 功能同上c0 从光标修改到本行开头cc 删除整行从头修改S 功能同上s 删除光标所在位置的字符，然后插入 单词和字符复制 123456ynl 向右复制n个字符ynh 向左复制n个字符ynw 向前复制n个单词ynb 向后复制n个单词e！ 全文恢复dt&quot; 删除所有的内容，直到遇到双引号—— &quot; 最强光标移动 12% : 匹配括号移动，包括 (, &#123;, [. （陈皓注：你需要把光标先移到括号上）;* 和 #: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）; 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Vim","slug":"Code/Vim","permalink":"http://xiaoqinghua.site/categories/Code/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://xiaoqinghua.site/tags/Vim/"}]},{"title":"Java异常总结","slug":"Java异常总结","date":"2017-09-23T14:20:13.000Z","updated":"2018-08-24T15:17:06.291Z","comments":true,"path":"Java异常总结.html","link":"","permalink":"http://xiaoqinghua.site/Java异常总结.html","excerpt":"","text":"异常概述异常异常就是在程序的运行过程中所发生的不正常的事件，它会中断正在运行的程序 异常处理Java 编程语言使用异常处理机制为程序提供了错误处理的能力，好处就是：如果代码中存在了异常，但是进行了捕获处理，那么程序就会继续运行下去，不会因为一个异常导致程序中断运行 🌰1：如果程序可能存在异常但是没有做异常处理，那么将导致程序不能正常的运行下去 12345678910111213public class ExceptionTest &#123; public static void main(String[] args) &#123; int a = 10; int b = 0; int c = a / b; System.out.println(c); System.out.println(\"不会输出的语句，因为不会执行到这里\"); &#125;&#125;输出结果是：Exception in thread \"main\" java.lang.ArithmeticException: / by zeroat cn.caijiajia.cn.caijiajia.exception.ExceptionTest.main(ExceptionTest.java:12) 🌰2：如果程序可能存在异常并做了异常处理，那么程序就会正常的运行下去 1234567891011121314151617181920public class ExceptionTest &#123; public static void main(String[] args) &#123; try &#123; int a = 10; int b = 0; int c = a / b; System.out.println(c); System.out.println(\"异常代码下面的代码将都不会执行\"); &#125; catch (ArithmeticException e) &#123; System.out.println(\"处理异常的代码\"); &#125; System.out.println(\"异常处理代码下面的程序将会继续执行而不会程序中断\"); &#125;&#125;输出结果是：Exception in thread \"main\" java.lang.ArithmeticException: / by zeroat cn.caijiajia.cn.caijiajia.exception.ExceptionTest.main(ExceptionTest.java:12)处理异常的代码异常处理代码下面的程序将会继续执行而不会程序中断 Java 中如何处理异常异常处理的 5 个关键字12345try：执行可能产生异常的代码catch：捕获异常并对异常情况做相应处理finally：无论是否发生异常，代码总能执行。（释放资源，关闭数据库连接）throws：声明可能抛出的各种异常（受检异常较多）用于方法后throw：手动的抛出异常（手动抛出我们自定义的异常较多）用于方法体中 异常处理后程序运行情况 情况一：没产生异常 123456789101112public void method() &#123; try &#123; // 代码段① [正常业务逻辑代码，此处不会产生异常] &#125; catch (Exception e) &#123; // 代码段② [对异常处理的代码段] &#125; // 代码段③ [正常业务逻辑代码]&#125;运行结果： 代码段① 代码段③ 情况二：产生异常并捕获异常 12345678910111213141516public void method() &#123; try &#123; // 异常代码段① [正常业务逻辑代码，此处会产生异常] // 代码段② [正常业务逻辑代码] &#125; catch (Exception e) &#123; // 代码段③ [对异常处理的代码段] &#125; // 代码段④ [正常业务逻辑代码]&#125;运行结果： 代码段① 代码段③ 代码段④注意：如果想要正常的 代码段② 执行，那么可以把代码段从 try catch 里面提出来，和 代码段④ 放在一起，当异常处理完之后，就可以同时去执行 代码段② 和 代码段④ 了。 情况三：产生异常并捕获异常，但是捕获异常类型不匹配产生异常类型 1234567891011121314public void method() &#123; try &#123; // 异常代码段① [正常业务逻辑代码，此处会产生角标越界异常] // 代码段② [正常业务逻辑代码] &#125; catch (IOException e) &#123; // 代码段③ [对异常处理的代码段] &#125; // 代码段④ [正常业务逻辑代码]&#125;运行结果： 代码段① 注意：如果捕获异常类型和产生的异常类型不匹配，那么就和没有处理异常情况一样了，try catch 后面的代码段将都不会执行，发生异常就会导致程序中断运行 异常体系异常类层次图 Error 和 ExceptionError 类和 Exception 类的父类都是 Throwable 类 Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。因此我们在学习的时候主要是学会Exception。 Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 Exception 异常分类及处理Exception 异常主要分为两大类：Checked Exception，Unchecked Exception；即受检异常和非受检异常（运行时异常） Checked Exception：受检异常，即 Java 程序必须显式处理的异常，如果程序没有处理 Checked 异常，该程序在编译时就会发生错误无法编译。例如图中所示的 IOException 处理受检异常通过有如下两种方式： 方式一：通过 trycatch 显式处理异常，否则编译不通过 12345678910public class ExceptionTest &#123; public static void main(String[] args) &#123; try &#123; // 通过 try catch 显示处理异常 FileInputStream fis = new FileInputStream(new File(\"\")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 方式二：通过 throws 抛出异常，让上层来处理异常，否则编译不通过 12345public class ExceptionTest &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream(new File(\"\")); &#125;&#125; Unchecked Exception：非受检异常，即 RuntimeException 运行时异常。这些异常程序可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。比如常见的 NullPointerException、IndexOutOfBoundsException 就是运行时异常。不过按照经验来说，这类异常要么尽量避免，要么出现了就要做异常处理，从而保证程序的健壮性。 处理运行时异常通过有如下两种方式： 方式一：常见的空指针处理 123456// 通过写伪代码来演示其处理流程if (对象 == null) &#123; // 处理对象为 null 的逻辑&#125; else &#123; // 处理对象不为 null 的逻辑&#125; 方式二：跟业务相关异常，抛出自定义异常 1234567// 通过手机号注册业务逻辑User user = dao.getByPhone(phone);if (user != null) &#123; // 说明此手机号码已经被注册，那么就抛出业务异常（即自定义异常） throw new MyRuntimeException(\"该用户已注册\");&#125;// 如果没有注册，继续走注册流程代码 总结： 受检异常（Checked Exception）处理起来很简单，因为程序如果不做显式处理，那么就会编译不通过，强制要求处理 运行时异常（Unchecked exception）则是看心情处理的，但是如果想要公司代码更加健壮，更少的出现问题，最好要做一下异常处理。但是如果做这个处理呢？对于这种运行时异常，大部分都是和业务相关的，比如手机号注册例子；这种情况下在 Java 的异常体系中并没有相关异常类做处理，因为 Java 不管再智能，也不可能知道我们的业务情况，当然就不会针对业务提供一些异常类供我们使用，因此为了解决这个问题，自定义异常就出现了，它对于我们处理业务中产生的运行时异常非常`非常重要，接下来就来看看自定义异常`。 自定义异常产生原因Java 现有的异常类不能满足更多的业务异常处理，因此我们要自定义合适的异常类来处理业务异常 如何自定义异常类第一步：声明一个类继承 Exception 或其子类 那么我们声明的这个类到底继承谁呢？Exception？RuntimeException？ 答案是：RuntimeException 原因是：看了上面的异常类层次图，应该也能发现，Exception 下面有两大类子类，受检异常和运行时异常，如果我们自定义的类继承了 Exception，则就会因为受检异常的存在而变成了受检异常类，这个时候我们自定义的异常类，如果在程序中使用，那么就必须显式处理异常，要么 try catch，要么抛出给上层；这样一来，使得我们的程序很混乱，而且并没有达到我们预期的结果。然后当我们自定义的类继承了 RuntimeException 之后，当我们程序中想要使用的时候，直接 new 一个即可，而不再需要显式去再多做处理了。 第二步：自定义异常类应至少包含四个构造方法 123456789101112131415public class MyException extends RuntimeException &#123; public MyException() &#123;&#125; public MyException(String msg) &#123; super(msg); &#125; public MyException(Throwable throwable) &#123; super(throwable); &#125; public MyException(String msg, Throwable throwable) &#123; super(msg, throwable); &#125;&#125; catch住了异常一定要记住处理： 12345678910111213public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; throw new Myexception(\"我是一个异常\"); &#125; catch (Exception e) &#123; e.printStackTrace(); return; &#125; &#125; &#125;此时 `retrun` 就是处理，退出循环如果不处理，循环一直进行 第三步：在程序中使用我们的自定义异常 12345678910public void testException() &#123; User user = dao.getByPhone(phone); if (user != null) &#123; // 因为 MyException 是继承 RuntimeException，所以这里直接抛出异常而不用做其它处理 throw new MyException(\"该手机号已被注册\"); &#125; // ...&#125; 注：没错，这里又使用了这个手机号注册的例子，因为这个就是实实在在的在业务中的异常处理。业务是千变万化，但是它们可能产生的异常处理方式是不会变化的，按照这个思路去做异常处理即可。 tips： 如上自定义的异常类中的构造方法是最基本的几个。每家公司的自定义异常可能都会有区别; 比如定义一个 SuperException 类实现了 RuntimeException，然后在自定义 ClientException，ServerException 再去继承 SuperException；那么这就是一套自定义体系了，分为客户端异常和服务端异常，在需要做异常处理的地方使用对应的异常类并抛出异常错误信息即可了。 比如可能有的公司会在自定义异常类中在定义一些字段，errorCode，errorMessage 等，来代表某些业务错误码和·对应的错误信息·等。不管怎么样，我们只要了解自定义异常的原理后，面对哪个公司的自定义异常体系我们都能够轻松应对。 总结 一个是异常体系，要分清受检异常和运行时异常； 一个就是自定义异常，知道如何自定义异常和如何使用自定义异常。 参考资料Java 入门之异常处理Java 异常的面试问题及答案 -Part 1Java 异常的面试问题及答案 -Part 2Java 异常的面试问题及答案 -Part 3","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java反射","slug":"Java反射","date":"2017-09-10T09:06:08.000Z","updated":"2018-08-24T09:11:38.628Z","comments":true,"path":"Java反射.html","link":"","permalink":"http://xiaoqinghua.site/Java反射.html","excerpt":"","text":"反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 创建新的对象。 Advantages of Using Reflection: Extensibility Features :An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.Class Browsers and Visual Development Environments : A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.Debuggers and Test Tools : Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite. Drawbacks of Reflection:Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection. Performance Overhead : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications. Security Restrictions : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet. Exposure of Internals :Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform. Trail: The Reflection API Java 反射使用总结","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Object类总结","slug":"Object总结","date":"2017-09-03T09:06:13.000Z","updated":"2018-08-24T07:42:55.771Z","comments":true,"path":"Object总结.html","link":"","permalink":"http://xiaoqinghua.site/Object总结.html","excerpt":"","text":"Object 上帝类Object类是Java中其他所有类的祖先，没有Object类Java面向对象无从谈起。作为其他所有类的基类，Object具有哪些属性和行为，是Java语言设计背后的思维体现。 Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入。Object类没有定义属性，一共有13个方法： 123456789101112131415161718192021222324252627282930313233// 隐式构造方法public Object();// 调用本地C/C++实现的方法private static native void registerNatives();// 初始化调用static &#123; registerNatives();&#125;protected native Object clone() throws CloneNotSupportedExceptionpublic final native Class&lt;?&gt; getClass()public boolean equals(Object obj)public native int hashCode()public String toString()public final void wait() throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionprotected void finalize() throws Throwable &#123;&#125; 1、类构造器public Object();大部分情况下，Java中通过形如 new A(args..)形式创建一个属于该类型的对象。其中 A 即是类名，A(args..)即此类定义中相对应的构造函数。通过此种形式创建的对象都是通过类中的构造函数完成。为体现此特性，Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数。作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。 当然，并不是所有的类都是通过此种方式去构建，也自然的，并不是所有的类构造函数都是public。 2、private static native void registerNatives();registerNatives函数前面有native关键字修饰，Java中，用native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。方法的具体实现体在dll文件中，对于不同平台，其具体实现应该有所不同。用native修饰，即表示操作系统，需要提供此方法，Java本身需要使用。具体到registerNatives()方法本身，其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。 既然如此，可能有人会问，registerNatives()修饰符为private，且并没有执行，作用何以达到？其实，在Java源码中，此方法的声明后有紧接着一段静态代码块： 12341 private static native void registerNatives();2 static &#123;3 registerNatives();4 &#125; 3、protected native Object clone() throws CloneNotSupportedException;clone()方法又是一个被声明为native的方法，因此，我们知道了clone()方法并不是Java的原生方法，具体的实现是有C/C++完成的。clone英文翻译为&quot;克隆&quot;，其目的是创建并返回此对象的一个副本。形象点理解，这有一辆科鲁兹，你看着不错，想要个一模一样的。你调用此方法即可像变魔术一样变出一辆一模一样的科鲁兹出来。配置一样，长相一样。但从此刻起，原来的那辆科鲁兹如果进行了新的装饰，与你克隆出来的这辆科鲁兹没有任何关系了。你克隆出来的对象变不变完全在于你对克隆出来的科鲁兹有没有进行过什么操作了。Java术语表述为：clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。 明白了clone的含义后，接下来看看如果调用clone()函数对象进行此克隆操作。 首先看一下下面的这个例子： 123456789public class ObjectTest &#123; public static void main(String[] args) &#123; Object o1 = new Object(); // The method clone() from the type Object is not visible Object clone = o1.clone(); &#125;&#125; 例子很简单，在main()方法中，new一个Object对象后，想直接调用此对象的clone方法克隆一个对象，但是出现错误提示：&quot;The method clone() from the type Object is not visible&quot; why? 根据提示，第一反应是ObjectTest类中定义的Object对象无法访问其clone()方法。回到Object类中clone()方法的定义，可以看到其被声明为protected，估计问题就在这上面了，protected修饰的属性或方法表示：在同一个包内或者不同包的子类可以访问。显然，Object类与ObjectTest类在不同的包中，但是ObjectTest继承自Object，是Object类的子类，于是，现在却出现子类中通过Object引用不能访问protected方法，原因在于对&quot;不同包中的子类可以访问&quot;没有正确理解。 &quot;不同包中的子类可以访问&quot;，是指当两个类不在同一个包中的时候，继承自父类的子类内部且主调（调用者）为子类的引用时才能访问父类用protected修饰的成员（属性/方法）。 在子类内部，主调为父类的引用时并不能访问此protected修饰的成员。！（super关键字除外） 于是，上例改成如下形式，可以正常编译： 12345678910111213public class ObjectTest &#123; public static void main(String[] args) &#123; ObjectTest ot1 = new ObjectTest(); try &#123; ObjectTest ot2 = (ObjectTest) ot1.clone(); &#125; catch (CloneNotSupportedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 是的，因为此时的主调已经是子类的引用了。 上述代码在运行过程中会抛出&quot;java.lang.CloneNotSupportedException&quot;,表明clone()方法并未正确执行完毕，问题的原因在与Java中的语法规定： clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。 Cloneable接口仅是一个表示接口，接口本身不包含任何方法，用来指示Object.clone()可以合法的被子类引用所调用。 于是，上述代码改成如下形式，即可正确指定clone()方法以实现克隆。 12345678910111213141516 3 public class ObjectTest implements Cloneable &#123; 4 5 public static void main(String[] args) &#123; 6 7 ObjectTest ot1 = new ObjectTest(); 8 9 try &#123;10 ObjectTest ot2 = (ObjectTest) ot1.clone();11 System.out.println(\"ot2:\" + ot2);12 &#125; catch (CloneNotSupportedException e) &#123;13 // TODO Auto-generated catch block14 e.printStackTrace();15 &#125;16 &#125;17 18 &#125; 4、public final native Class&lt;?&gt; getClass();getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。 首先解释下&quot;类对象&quot;的概念：在Java中，类是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为&quot;类对象&quot;。 5、public boolean equals(Object obj);==与equals在 Java 中经常被使用，大家也都知道==与equals的区别： ==表示的是变量值完成相同（对于基础类型，地址中存储的是值，引用类型则存储指向实际对象的地址） equals表示的是对象的内容完全相同，此处的内容多指对象的特征/属性。 实际上，上面说法是不严谨的，更多的只是常见于String类中。首先看一下Object类中关于equals()方法的定义： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 由此可见，Object原生的equals()方法内部调用的正是==，与==具有相同的含义。既然如此，为什么还要定义此equals()方法？ equlas()方法的正确理解应该是：判断两个对象是否相等。那么判断对象相等的标尺又是什么？ 如上，在Object类中，此标尺即为==。当然，这个标尺不是固定的，其他类中可以按照实际的需要对此标尺含义进行重定义。如String类中则是依据字符串内容是否相等来重定义了此标尺含义。如此可以增加类的功能型和实际编码的灵活性。当然了，如果自定义的类没有重写equals()方法来重新定义此标尺，那么默认的将是其父类的equals()，直到Object基类。 String 类的 equals(): 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 如下场景的实际业务需求，对于User bean，由实际的业务需求可知当属性uid相同时，表示的是同一个User，即两个User对象相等。则可以重写equals以重定义User对象相等的标尺。 1234567891011121314151617181920212223242526272829303132333435363738394041public class User &#123; private int uid; private String name; private int age; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; protected String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object obj) &#123; if (obj == null || !(obj instanceof User)) &#123; return false; &#125; if (((User) obj).getUid() == this.getUid()) &#123; return true; &#125; return false; &#125;&#125; 123456789101112131415public class ObjectTest implements Cloneable &#123; public static void main(String[] args) &#123; User u1 = new User(); u1.setUid(111); u1.setName(\"张三\"); User u2 = new User(); u2.setUid(111); u2.setName(\"张三丰\"); System.out.println(u1.equals(u2)); //返回true &#125;&#125; ObjectTest中打印出true，因为User类定义中重写了equals()方法，这很好理解，很可能张三是一个人小名，张三丰才是其大名，判断这两个人是不是同一个人，这时只用判断uid是否相同即可。 如上重写equals方法表面上看上去是可以了，实则不然。因为它破坏了Java中的约定：重写equals()方法必须重写hasCode()方法 补充 等价关系 自反性 1x.equals(x); // true 对称性 1x.equals(y) == y.equals(x); // true 传递性 12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; 一致性 12多次调用 equals() 方法结果不变x.equals(y) == x.equals(y); // true 与 null 的比较 12对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 falsex.equals(null); // false; equals() 与 == 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 6、public native int hashCode();hashCode()方法返回一个整形数值，表示该对象的哈希码值。 hashCode()具有如下约定： 在Java应用程序程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致； 如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等； 反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。 1234567EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。 一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。 12345678@Overridepublic int hashCode() &#123; int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result;&#125; 7、public String toString();toString()方法返回该对象的字符串表示。先看一下Object中的具体方法体： 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode());&#125; toString()方法相信大家都经常用到，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。 getClass()返回对象的类对象，getClassName()以String形式返回类对象的名称（含包名）。Integer.toHexString(hashCode())则是以对象的哈希码为实参，以16进制无符号整数形式返回此哈希码的字符串表示形式。 因此：toString()是由对象的类型和其哈希码唯一确定，同一类型但不相等的两个对象分别调用toString()方法返回的结果可能相同。 8~12、wait(…) / notify() / notifyAll()一说到wait(...) / notify() | notifyAll()几个方法，首先想到的是线程。确实，这几个方法主要用于java多线程之间的协作。先具体看下这几个方法的主要含义： wait()：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法。 wait(long timeout)/wait(long timeout, int nanos)：调用此方法所在的当前线程等待，直到在其他线程上调用此方法的主调（某一对象）的notify()/notifyAll()方法，或超过指定的超时时间量。 notify()/notifyAll()：唤醒在此对象监视器上等待的单个线程/所有线程。 wait(...) / notify() | notifyAll()一般情况下都是配套使用。下面来看一个简单的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ThreadTest &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub MyRunnable r = new MyRunnable(); Thread t = new Thread(r); t.start(); synchronized (r) &#123; try &#123; System.out.println(\"main thread 等待t线程执行完\"); r.wait(); System.out.println(\"被notity唤醒，得以继续执行\"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"main thread 本想等待，但被意外打断了\"); &#125; System.out.println(\"线程t执行相加结果\" + r.getTotal()); &#125; &#125;&#125;class MyRunnable implements Runnable &#123; private int total; @Override public void run() &#123; // TODO Auto-generated method stub synchronized (this) &#123; System.out.println(\"Thread name is:\" + Thread.currentThread().getName()); for (int i = 0; i &lt; 10; i++) &#123; total += i; &#125; notify(); System.out.println(\"执行notif后同步代码块中依然可以继续执行直至完毕\"); &#125; System.out.println(\"执行notif后且同步代码块外的代码执行时机取决于线程调度\"); &#125; public int getTotal() &#123; return total; &#125;&#125; 运行结果： 123456main thread 等待t线程执行完Thread name is:Thread-0执行notif后同步代码块中依然可以继续执行直至完毕执行notif后且同步代码块外的代码执行时机取决于线程调度 //此行输出位置有具体的JVM线程调度决定，有可能最后执行被notity唤醒，得以继续执行线程t执行相加结果45 既然是作用于多线程中，为什么却是Object这个基类所具有的方法？原因在于理论上任何对象都可以视为线程同步中的监听器，且wait(...)/notify()|notifyAll()方法只能在同步代码块中才能使用。 从上述例子的输出结果中可以得出如下结论： wait(...)方法调用后当前线程将立即阻塞，且释放其所持有的同步代码块中的锁，直到被唤醒或超时或打断后且重新获取到锁后才能继续执行； notify()/notifyAll()方法调用后，其所在线程不会立即释放所持有的锁，直到其所在同步代码块中的代码执行完毕，此时释放锁，因此，如果其同步代码块后还有代码，其执行则依赖于JVM的线程调度。 在Java源码中，可以看到wait()具体定义如下： 123public final void wait() throws InterruptedException &#123; wait(0);&#125; 且wait(long timeout, int nanos)方法定义内部实质上也是通过调用wait(long timeout)完成。而wait(long timeout)是一个native方法。因此，wait(...)方法本质上都是native方式实现。 notify()/notifyAll()方法也都是native方法。 13、protected void finalize();finalize方法主要与Java垃圾回收机制有关。首先我们看一下finalized方法在Object中的具体定义： 1protected void finalize() throws Throwable &#123; &#125; 我们发现Object类中finalize方法被定义成一个空方法，为什么要如此定义呢？finalize方法的调用时机是怎么样的呢？ 首先，Object中定义finalize方法表明Java中每一个对象都将具有finalize这种行为，其具体调用时机在：JVM准备对此对对象所占用的内存空间进行垃圾回收前，将被调用。由此可以看出，此方法并不是由我们主动去调用的（虽然可以主动去调用，此时与其他自定义方法无异）。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java关键字final和static","slug":"Java关键字final和static","date":"2017-09-02T07:31:51.000Z","updated":"2018-08-24T07:42:38.998Z","comments":true,"path":"Java关键字final和static.html","link":"","permalink":"http://xiaoqinghua.site/Java关键字final和static.html","excerpt":"","text":"关键字final1、数据： 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int x = 1;// x = 2; // cannot assign value to final variable 'x'final A y = new A();y.a = 1; 2、方法： 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3、类： 声明类不允许被继承。 static1、静态变量： 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 1234567891011public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2、静态方法： 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 12345678910public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3、静态语句块： 静态语句块在类初始化时运行一次。 1234567891011public class A &#123; static &#123; System.out.println(\"123\"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125;123 4、静态内部类： 非静态内部类依赖于外部类的实例，而静态内部类不需要。 1234567891011121314public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5、静态导包： 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 6、初始化顺序： 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = \"静态变量\";static &#123; System.out.println(\"静态语句块\");&#125;public String field = \"实例变量\";&#123; System.out.println(\"普通语句块\");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println(\"构造函数\");&#125; 存在继承的情况下，初始化顺序为： 1234561 父类（静态变量、静态语句块）2 子类（静态变量、静态语句块）3 父类（实例变量、普通语句块）4 父类（构造函数）5 子类（实例变量、普通语句块）6 子类（构造函数）","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 抽象类和接口","slug":"Java抽象类接口","date":"2017-08-27T11:56:48.000Z","updated":"2018-08-24T14:20:25.347Z","comments":true,"path":"Java抽象类接口.html","link":"","permalink":"http://xiaoqinghua.site/Java抽象类接口.html","excerpt":"","text":"抽象类 当编写一个类时，常常会为该类定义一些方法，这些方法用以描述该类的行为方式，那么这些方法都有具体的方法体。但在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确地知道这些子类如何实现这些方法。使用抽象方法即可满足该要求：抽象方法是只有方法签名（方法名+形参列表），没有方法实现的方法 抽象方法和抽象类抽象方法和抽象类必须使用abstract修饰符来定义，有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法 抽象方法和抽象类的规则如下： 抽象类必须使用abstract修饰符来修饰，抽象方法也必须使用abstract修饰符来修饰，抽象方法不能有方法体 抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例 抽象类可以包含成员变量、方法（普通方法和抽象方法）、构造器、初始化块、内部类（接口、枚举）5种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用 含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含的抽象方法三种情况）只能被定义成抽象类 抽象类与空方法体的方法：public abstract void test(); public void test(){}; 抽象类不能用于创建实例，只能当作父类被其他子类继承 当使用abstract修饰类时，表明这个类只能被继承；当使用abstract修饰方法时，表明这个方法必须由子类提供实现（即重写）。而final修饰的类不能被继承，final修饰的方法不能被重写。因此final和abstract永远不能同时使用 abstract不能用于修饰成员变量，不能用于修饰局部变量，即没有抽象变量、没有抽象成员变量等说法；abstract也不能用于修饰构造器，没有抽象构造器，抽象类里定义的构造器只能是普通构造器 当使用static修饰一个方法时，表明这个方法属于该类本身，即通过类就可调用该方法，但如果该方法被定义成抽象方法，则将导致通过该类来调用该方法时出现错误（调用了一个没有方法体的方法肯定会引起错误）。因此static和abstract不能同时修饰某个方法，即没有所谓的类抽象方法。但static和abstract可以同时修饰内部类 abstract关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此abstract方法不能定义为private访问权限，即private和abstract不能同时修饰方法 抽象类的方法抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会大致保留抽象类的行为方式。 模板模式在面向对象的软件中很常用，其原理简单，实现也很简单。下面是使用模板模式的一些简单规则： 抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给其子类去实现 父类中可能包含需要调用其他系列方法的方法，这些被调用方法既可以由父类实现，也可以由其子类实现。父类里提供的方法只是定义了一个通用算法，其实现也许并不完全由自身实现，而必须依赖于其子类的辅助 Java8改进的接口抽象类是从多个类中抽象出来的模板，如果将这种抽象进行得更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（interface），接口里不能包含普通方法，接口里的所有方法都是抽象方法。Java8对接口进行了改进，允许在接口中定义默认方法，默认方法可以提供方法实现 接口的概念接口定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，这意味着接口里通常是定义一组公用方法。 Java8中接口的定义123456[修饰符] interface 接口名 extends 父接口1,父接口2...&#123; 零个到多个常量定义... 零个到多个抽象方法定义... 零个到多个内部类、接口、枚举定义... 零个到多个默认方法或类方法定义...&#125; 修饰符可以是public或者省略，如果省略了public访问控制符，则默认采用包权限访问控制符，即只有在相同包结构下才可以访问该接口 接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可；如果要遵守Java可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无须任何分隔符。接口名通常能够使用形容词。 一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。 由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法或默认方法）、内部类（包括内部接口、枚举）定义 接口里定义的是多个类共同的公共行为规范，因此接口里的所有成员，包括常量、方法、内部类和内部枚举都是public访问权限。定义接口成员时，可以省略访问控制修饰符，如果指定访问控制修饰符，则只能使用public访问控制修饰符。 对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加static和final两个修饰符。也就是说，在接口中定义成员变量时，不管是否使用public static final修饰符，接口里的成员变量总是使用这三个修饰符来修饰。而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值 接口里定义的内部类、内部接口、内部枚举默认都采用public static两个修饰符，不管定义时是否指定这两个修饰符，系统都会自动使用public static对它们进行修饰 接口里定义的方法只能是抽象方法、类方法或默认方法，因此如果不是定义默认方法，系统将自动为普通方法增加abstract修饰符；定义接口里的普通方法时不管是否使用public abstract修饰符，接口里的普通方法总是public abstract来修饰。接口里的普通方法不能有方法实现（方法体）；但类方法、默认（default）方法都必须有方法实现（方法体 Java8允许在接口中定义类方法，类方法必须使用static修饰，该方法不能使用default修饰，无论程序是否指定，类方法总是使用public修饰——如果开发者没有指定public，系统会自动为类方法添加public修饰符。类方法可以直接使用接口来调用。 接口的继承接口的继承和类继承不一样，接口完全支持多继承，即一个接口可以有多个直接父接口。和类继承相似，子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。一个接口继承多个父接口时，多个父接口排在extends关键字之后，多个父接口之间以英文逗号（,）隔开。 使用接口接口不能用于创建实例，但接口可以用于声明引用类型变量。当使用接口来声明引用类型变量时，这个引用类型变量必须引用到其实现类的对象。除此之外，接口的主要用途就是被实现类实现。 定义变量，也可用于进行强制类型转换 调用接口中定义的常量 被其他类实现一个类可以实现一个或多个接口，继承使用extends关键字，实现则使用implements关键字 123[修饰符] class 类名 extends 父类 implements 接口1，接口2&#123; 类体部分&#125; 一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。 一个类实现某个接口时，该类将会获得接口中定义的常量（成员变量）、方法等，因此可以把实现接口理解为一种特殊的继承，相当于实现类继承了一个彻底抽象的类（相当于除了默认方法外，所有方法都是抽象方法的类）。 实现接口方法时，必须使用public访问控制修饰符，因为接口里的方法都是public的，而子类（相当于实现类）重写父类方法时访问权限只能更大或者相等，所以实现类实现接口里的方法时只能使用public访问权限 接口和抽象类接口和抽象类很像，它们都具有如下特征: 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。 接口作为系统与外界交互的窗口，接口体现的是一种规范抽象类作为系统中多个子类的共同父类，它所体现的是一种模板式设计 接口和抽象类在用法上的差别： 接口里只能包含抽象方法和默认方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法 接口里不能定义静态方法；抽象类里可以定义静态方法 接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量 接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作 接口里不能包含初始化块，但抽象类则完全包含初始化块 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 参数传递","slug":"Java参数传递","date":"2017-08-27T10:48:08.000Z","updated":"2018-08-24T07:42:27.841Z","comments":true,"path":"Java参数传递.html","link":"","permalink":"http://xiaoqinghua.site/Java参数传递.html","excerpt":"","text":"概述1.什么是参数传递？ 123调用方法时向形参传递数据的过程叫做参数传递。在编程语言中有两种传递方式：值传递与引用传递。必须强调的是，这里提到的两种传递方式不是仅限于Java使用到的传递方式，而是出现在包括Java在内的多种编程语言中的传递方式。 2.变量类型 1在Java中，我们将指向基本类型数据的变量称为原始变量，将指向对象的变量称为引用变量。 值传递1.什么是值传递？ 1将变量的副本传入方法，方法内外操作隔离，在方法内对变量的操作不会反映到方法外的变量中。 2.原始变量 12345678910public void change(int b) &#123; b = 7;&#125;@Testpublic void testBasic() &#123; int a = 9; change(a); System.out.println(a);&#125; 实际输出：9 在参数传递时，按照值传递的规则，变量b接收一个a的副本，同样指向字面值“9”： 接下来，在方法内部，为b赋值7，这样b指向7，由于a与b是两个相互独立的变量，两者之间没有引用与被引用的关系，a依然指向9： 3.String 12345678910public void change(String str01) &#123; str01 = \"baidu\";&#125;@Testpublic void testString() &#123; String str = new String(\"www.baidu.com\"); change(str); System.out.println(str);&#125; 实际输出：www.baidu.com 在参数传递时，str将自身的一个副本传递给str01，这样str01也指向堆中存放“www.baidu.com”的对象： 在方法内部为str01赋值，这样str01就指向方法区字符串常量池中的”baidu”，str依然指向堆中的“www.baidu.com”，str与str01指向不同的对象，相互之间不影响： 这里需要注意一点：java将String设计成不可改变的对象，即一旦String对象包含的字面值发生改变，java就会新建一个对象，并将变量指向新的对象。 4.StringBuilder 12345678910public void change(StringBuilder builder01) &#123; builder01.append(\" World!\");&#125;@Testpublic void testStringBuilder() &#123; StringBuilder builder = new StringBuilder(\"Hello\"); change(builder); System.out.println(builder);&#125; 实际输出：Hello World! 在参数传递完成以后，builder01变量获得builder变量的一个副本，副本与原始变量指向堆中同一个对象： 在方法内部，变量builder没有指向新的对象，依然与builder指向同一对象，所以当builder访问堆中同一对象时，数据发生改变： 5.自定义类型 123456789101112131415161718public class MyInner &#123; public int a;&#125;public class Test&#123; public void change(MyInner in01) &#123; in01.a = 1; &#125; @Test public void testDemain() &#123; MyInner in = new MyInner(); in.a = 9; change(in); System.out.println(in.a); &#125;&#125; 实际输出：1 执行过程同StringBuilder执行过程相同，这里不再赘述。下面对上面的代码做一点改动，如下： 12345678910111213141516171819public class MyInner &#123; public int a;&#125;public class Test&#123; public void change(MyInner in01) &#123; in01=new MyInner();//使in01指向一个新的对象 in01.a = 1; &#125; @Test public void testDemain() &#123; MyInner in = new MyInner(); in.a = 9; change(in); System.out.println(in.a); &#125;&#125; 实际输出：9 参数传递完成时，in01与in指向同一个对象，in01对对象的操作等同于in对对象的操作，接着在方法内部执行”in01=new MyInner();”，这样in01 就指向了一个新的对象，in01所有的操作都与in无关了： 综合以上的运行结果与分析，可知java参数传递方式符合值传递。 引用传递什么是引用传递？ 12345将变量自身的内存地址传入方法中，方法中的变量指向方法外的变量，在方法中对变量的操作就是对方法外变量的操作 。不再一一分析其他变量类型，分析后可以发现，java在传递参数时采用的 不是引用传递，而是值传递。简单讲，值传递时方法内外是两个拥有同一指向的变量，引用传递时方法内外是同一个变量。 本文转自:http://www.tuicool.com/articles/niUfuqN","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java数据类型缓存池","slug":"数据类型缓存池","date":"2017-08-27T02:28:23.000Z","updated":"2018-08-24T07:45:53.514Z","comments":true,"path":"数据类型缓存池.html","link":"","permalink":"http://xiaoqinghua.site/数据类型缓存池.html","excerpt":"","text":"new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; 编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓存池如下： 12345boolean values true and falseall byte valuesshort values between -128 and 127int values between -128 and 127char in the range \\u0000 to \\u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓存池中的对象。 StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 内部类","slug":"Java内部类","date":"2017-08-26T07:01:58.000Z","updated":"2018-08-24T07:42:24.335Z","comments":true,"path":"Java内部类.html","link":"","permalink":"http://xiaoqinghua.site/Java内部类.html","excerpt":"","text":"少啰嗦，先上代码123456789101112131415161718192021222324252627public class OuterClass &#123; private String name ; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; class InnerClass&#123; public InnerClass()&#123; name = \"chenssy\"; age = 23; &#125; &#125;&#125; 在这里InnerClass就是内部类，虽然没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。 为什么要使用内部类 为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承(二义性)的解决方案变得更加完整。 其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）： 1234567891、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。3、创建内部类对象的时刻并不依赖于外围类对象的创建。4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。 内部类基础 在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。 1234567891011121314151617181920212223242526public class OuterClass &#123; private String name ; private int age; /**省略getter和setter方法**/ public class InnerClass&#123; public InnerClass()&#123; name = \"xiaoqinghua\"; age = 25; &#125; public void display()&#123; System.out.println(\"name：\" + getName() +\" ;age：\" + getAge()); &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.display(); &#125;&#125;--------------Output：name：xiaoqinghua ;age：25 在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。 其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类： OuterClass.InnerClass innerClass = outerClass.new InnerClass();。 同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。 1234567891011121314151617181920public class OuterClass &#123; public void display()&#123; System.out.println(\"OuterClass...\"); &#125; public class InnerClass&#123; public OuterClass getOuterClass()&#123; return OuterClass.this; &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.getOuterClass().display(); &#125;&#125;-------------Output:OuterClass... 到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。 在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。 成员内部类成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。 在成员内部类中要注意两点: 成员内部类中不能存在任何static的变量和方法 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类 12345678910111213141516171819202122232425262728293031public class OuterClass &#123; private String str; public void outerDisplay()&#123; System.out.println(\"outerClass...\"); &#125; public class InnerClass&#123; public void innerDisplay()&#123; //使用外围内的属性 str = \"xiaoqinghua...\"; System.out.println(str); //使用外围内的方法 outerDisplay(); &#125; &#125; /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */ public InnerClass getInnerClass()&#123; return new InnerClass(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.getInnerClass(); inner.innerDisplay(); &#125;&#125;--------------------xiaoqinghua...outerClass... 局部内部类有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。 定义在方法里： 12345678910111213141516171819public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation(\"xiaoqinghua\"); &#125;&#125; 定义在作用域内: 1234567891011121314151617181920212223242526public class Parcel6 &#123; private void internalTracking(boolean b)&#123; if(b)&#123; class TrackingSlip&#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip()&#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip(\"xiaoqinghua\"); String string = ts.getSlip(); &#125; &#125; public void track()&#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel6 parcel6 = new Parcel6(); parcel6.track(); &#125;&#125; 匿名内部类在做Swing编程中，我们经常使用这种方式来绑定事件 123456button2.addActionListener( new ActionListener()&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"点击了按钮\"); &#125; &#125;); 我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子： 123456789101112131415161718192021222324public class OuterClass &#123; public InnerClass getInnerClass(final int num,String str2)&#123; return new InnerClass()&#123; int number = num + 3; public int getNumber()&#123; return number; &#125; &#125;; /* 注意：分号不能省 */ &#125; public static void main(String[] args) &#123; OuterClass out = new OuterClass(); InnerClass inner = out.getInnerClass(2, \"xiaoqinghua\"); System.out.println(inner.getNumber()); &#125;&#125;interface InnerClass &#123; int getNumber();&#125;----------------Output:5 这里我们就需要看清几个地方 123456781、 匿名内部类是没有访问修饰符的。2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。 静态内部类static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖于外围类的。 它不能使用任何外围类的非static成员变量和方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class OuterClass &#123; private String sex; public static String name = \"chenssy\"; /** *静态内部类 */ static class InnerClass1&#123; /* 在静态内部类中可以存在静态成员 */ public static String _name1 = \"chenssy_static\"; public void display()&#123; /* * 静态内部类只能访问外围类的静态成员变量和方法 * 不能访问外围类的非静态成员变量和方法 */ System.out.println(\"OutClass name :\" + name); &#125; &#125; /** * 非静态内部类 */ class InnerClass2&#123; /* 非静态内部类中不能存在静态成员 */ public String _name2 = \"chenssy_inner\"; /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */ public void display()&#123; System.out.println(\"OuterClass name：\" + name); &#125; &#125; /** * @desc 外围类方法 * @author chenssy * @data 2013-10-25 * @return void */ public void display()&#123; /* 外围类访问静态内部类：内部类. */ System.out.println(InnerClass1._name1); /* 静态内部类 可以直接创建实例不需要依赖于外围类 */ new InnerClass1().display(); /* 非静态内部的创建需要依赖于外围类 */ OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2(); /* 方位非静态内部类的成员需要使用非静态内部类的实例 */ System.out.println(inner2._name2); inner2.display(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); outer.display(); &#125;&#125;----------------Output:chenssy_staticOutClass name :chenssychenssy_innerOuterClass name：chenssy 以上内容转载至：http://www.cnblogs.com/chenssy/ chenssy 大佬的博客 加一下料：重写和重载 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"String的那些事","slug":"再记String","date":"2017-08-25T02:28:23.000Z","updated":"2018-08-22T08:57:11.354Z","comments":true,"path":"再记String.html","link":"","permalink":"http://xiaoqinghua.site/再记String.html","excerpt":"","text":"String 的用法String类在 java.lang 包中，java 使用String类创建一个字符串变量，字符串变量属于对象。java 把String类声明的final类，不能有子类。String类对象创建后不能修改，由 0 或多个字符组成，包含在一对双引号之间，下面简单的熟悉一下其常用的 API： 1234567891011121314151617char charAt (int index) 返回index所指定的字符 String concat(String str) 将两字符串连接 boolean endsWith(String str) 测试字符串是否以str结尾 boolean equals(Object obj) 比较两对象 char[] getBytes 将字符串转换成字符数组返回 char[] getBytes(String str) 将指定的字符串转成制服数组返回 boolean startsWith(String str) 测试字符串是否以str开始 int length() 返回字符串的长度 String replace(char old ,char new) 将old用new替代 char[] toCharArray 将字符串转换成字符数组 String toLowerCase() 将字符串内的字符改写成小写 String toUpperCase() 将字符串内的字符改写成大写 String valueOf(Boolean b) 将布尔方法b的内容用字符串表示 String valueOf(char ch) 将字符ch的内容用字符串表示 String valueOf(int index) 将数字index的内容用字符串表示 String valueOf(long l) 将长整数字l的内容用字符串表示 String substring(int1,int2) 取出字符串内第int1位置到int2的字符串 1.构造方法 123456//直接初始化String str = \"abc\";//使用带参构造方法初始化char[] char = &#123;'a','b','c'&#125;;String str1 = new String(\"abc\");String str2 = new String(str);String str3 = new String(char); 2.求字符串长度和某一位置字符 123String str = new String(\"abcdef\");int strlength = str.length();//strlength = 7char ch = str.charAt(4);//ch = e 3.提取子串 用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数:1)public String substring(int beginIndex)//该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。 2)public String substring(int beginIndex, int endIndex)//该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回。 123String str1 = new String(\"abcdef\");String str2 = str1.substring(2);//str2 = \"cdef\"String str3 = str1.substring(2,5);//str3 = \"cde\" 4.字符串比较 1)public int compareTo(String anotherString)//该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。 2)public int compareToIgnoreCase(String anotherString)//与compareTo方法相似，但忽略大小写。 3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。 4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似，但忽略大小写。 123456String str1 = new String(\"abc\");String str2 = new String(\"ABC\");int a = str1.compareTo(str2);//a&gt;0int b = str1.compareToIgnoreCase(str2);//b=0boolean c = str1.equals(str2);//c=falseboolean d = str1.equalsIgnoreCase(str2);//d=true 5.字符串链接 public String concat(String str)//将参数中的字符串str连接到当前字符串的后面，效果等价于”+” 12String str = \"aa\".concat(\"bb\").concat(\"cc\");//相当于String str = \"aa\"+\"bb\"+\"cc\"; 6.字符串中单个字符查找 1)public int indexOf(int ch/String str)//用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。 2)public int indexOf(int ch/String str, int fromIndex)//改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。 3)public int lastIndexOf(int ch/String str)//该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。 4)public int lastIndexOf(int ch/String str, int fromIndex)//该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。 123456String str = \"I really miss you !\";int a = str.indexOf('a');//a = 4int b = str.indexOf(\"really\");//b = 2int c = str.indexOf(\"gg\",2);//c = -1int d = str.lastIndexOf('s');//d = 6int e = str.lastIndexOf('s',7);//e = 7 7.大小写转换 1)public String toLowerCase()//返回将当前字符串中所有字符转换成小写后的新串 2)public String toUpperCase()//返回将当前字符串中所有字符转换成大写后的新串 123String str = new String(\"abCD\");String str1 = str.toLowerCase();//str1 = \"abcd\"String str2 = str.toUpperCase();//str2 = \"ABCD\" 8.字符串中字符的替换 1)public String replace(char oldChar, char newChar)//用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。 2)public String replaceFirst(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。 3)public String replaceAll(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。 12345String str = \"asdzxcasd\";String str1 = str.replace('a','g');//str1 = \"gsdzxcgsd\"String str2 = str.replace(\"asd\",\"fgh\");//str2 = \"fghzxcfgh\"String str3 = str.replaceFirst(\"asd\",\"fgh\");//str3 = \"fghzxcasd\"String str4 = str.replaceAll(\"asd\",\"fgh\");//str4 = \"fghzxcfgh\" 9.其他方法 1)String trim()//截去字符串两端的空格，但对于中间的空格不处理。 1234String str = \" a bc \";String str1 = str.trim();int a = str.length();//a = 6int b = str1.length();//b = 4 2)boolean statWith(String prefix)或boolean endWith(String suffix)//用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。 123String str = \"abcdef\";boolean a = str.statWith(\"ab\");//a = trueboolean b = str.endWith(\"ef\");//b = true 3)contains(String str)//判断参数s是否被包含在字符串中，并返回一个布尔类型的值。 123String str = \"abcdef\";str.contains(\"ab\");//truestr.contains(\"gh\");//false 4)String[] split(String str)//将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。 12String str = \"abc def ghi\";String[] str1 = str.split(\" \");//str1[0] = \"abc\";str1[1] = \"def\";str1[2] = \"ghi\"; 10.类型转换 字符串转基本类型:java.lang包中有Byte、Short、Integer、Float、Double类的调用方法： 123456789public static byte parseByte(String s)public static short parseShort(String s)public static short parseInt(String s)public static long parseLong(String s)public static float parseFloat(String s)public static double parseDouble(String s)int n = Integer.parseInt(\"12\");float f = Float.parseFloat(\"12.34\");double d = Double.parseDouble(\"1.124\"); 基本类型转字符串:String类中提供了String valueOf()放法，用作基本类型转换为字符串类型 1234567891011static String valueOf(char data[])static String valueOf(char data[], int offset, int count)static String valueOf(boolean b)static String valueOf(char c)static String valueOf(int i)static String valueOf(long l)static String valueOf(float f)static String valueOf(double d)//将char '8' 转换为int 8String str = String.valueOf('8');int num = Integer.parseInt(str); 进制转换:使用Long类中的方法得到整数之间的各种进制转换的方法： 1234Long.toBinaryString(long l)//二进制Long.toOctalString(long l)//八进制Long.toHexString(long l)//十六进制Long.toString(long l, int p)//p作为任意进制 String 的特性1、String是不可变类 这句话其实大家都很熟悉了，那么具体什么是不可变类呢？一般认为：当对象一旦创建完成后，在正常情况下，对象的状态不会因外界的改变而改变（对象的状态是指对象的属性，包括属性的类型及属性值） 首先看一个基本的例子： 12341 String s = \"abc\";2 System.out.println(\"s:\" + s); // 输出s:abc3 s = \"def\";4 System.out.println(\"s:\" + s); // 输出s:def 此时，初看上去，输出的结果变了，发现s的值发生了变化，那么这与上面的说法——String类是不可变类是否矛盾呢？答案是否定的，因为s只是指向堆内存中的引用，存储的是对象在堆中的地址，而非对象本身，s本身存储在栈内存中。 实际上，此时堆内存中依然存在着&quot;abc&quot;和&quot;def&quot;对象。对于&quot;abc&quot;对象本身而言，对象的状态是没有发生任何变化的。 那么为什么String类具有不可变性呢，显然，既然不可变说明String类中肯定没有提供对外可setters方法。接下来来具体看一下String类的定义。 下面是String类中主要属性的定义（Java 1.7源码）： 1234567891 public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123;2 3 /** The value is used for character storage. */4 private final char value[];5 6 /** Cache the hash code for the string */7 private int hash; // Default to 08 9 &#125; 不可变的好处： 123456789101112131415161. 可以缓存 hash 值因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算2. String Pool 的需要如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool3. 安全性String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是4. 线程安全String 不可变性天生具备线程安全，可以在多个线程中安全地使用 Program Creek : Why String is immutable in Java? 2、String, StringBuffer and StringBuilder 12345678910可变性String 不可变StringBuffer 和 StringBuilder 可变线程安全String 不可变，因此是线程安全的StringBuilder 不是线程安全的StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StackOverflow : String, StringBuffer, and StringBuilder \b举几个🌰🌰1: 1234567String a = \"Hello World!\"; String b = \"Hello World!\"; String c = new String(\"Hello World!\"); String d = \"Hello\"+\" \"+\"World!\";System.out.println(a == b);//trueSystem.out.println(a == c);//falseSystem.out.println(a == d);//true 我们应该明白： 首先String不属于8种基本数据类型，String是一个对象。 因为对象的默认值是null，所以 String 的默认值也是null；但它又是一种特殊的对象，有其它对象没有的一些特性。 在这里，我们先不谈堆，也不谈栈，只先简单引入常量池这个简单的概念。 常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。 Java会确保一个字符串常量只有一个拷贝。 因为例子中的a和b都是字符串常量，它们在编译期就被确定了，所以a==b为true；而&quot;Hello&quot;和&quot; &quot;以及&quot;World!&quot;也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以d也同样在编译期就被解析为一个字符串常量，所以d也是常量池中&quot;Hello World!&quot;的一个引用。所以我们得出a==b==d 用new String()创建的字符串不是常量,不能在编译期就确定，所以new String()创建的字符串不放入常量池中，它们有自己的地址空间 🌰2: 123456String a = \"HelloWorld\"; String b = new String(\"HelloWorld\"); String c = \"Hello\"+ new String(\"World\"); System.out.println( a == b );//falseSystem.out.println( a == c );//falseSystem.out.println( b == c );//false a还是常量池中”HelloWorld”的引用，b因为无法在编译期确定，所以是运行时创建的新对象”HelloWorld”的引用，c因为有后半部分new String(“World”)所以也无法在编译期确定，所以也是一个新创建对象”HelloWorld”的引用，明白了这些也就知道为何得出此结果了。 12String.intern()：再补充介绍一点：存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用，看例3就清楚了。 🌰3: 12345678910String a = \"Hello\"; String b = new String(\"Hello\"); String c = new String(\"Hello\"); System.out.println( a == b );//falseSystem.out.println( “**********” ); b.intern(); c = c.intern(); //把常量池中\"Hello\"的引用赋给c System.out.println( a == b);//false虽然执行了b.intern()但没有赋值给bSystem.out.println( a == b.intern() );//true System.out.println( a == c ); //true 🌰4: 关于equals()和==:equals() 是比较两个对象的值是否相等，这个对于 String 简单来说就是比较两字符串的 Unicode 序列是否相当，如果相等返回 true;而 == 是比较两字符串的地址是否相同，也就是是否是同一个字符串的引用。 🌰5: String是不可变的:这一说又要说很多，大家只要知道String的实例一旦生成就不会再改变了，比如说： 1String str = ”aa”+”bb”+” “+”cc”; 就是有4个字符串常量，首先”aa”和”bb”生成了”aabb”存在内存中，后”aabb”又和” “ 生成 ”aabb “存在内存中，最后又和生成了”aabb cc”，并把这个字符串的地址赋给了str,就是因为String的“不可变”产生了很多临时变量，这也就是为什么建议用StringBuffer的原因了。 来一个反射改变String的🌰12345678910111213141516171819 1 public static void stringReflection() throws Exception &#123; 2 3 String s = \"Hello World\"; 4 5 System.out.println(\"s = \" + s); //Hello World 6 7 //获取String类中的value字段 8 Field valueField = String.class.getDeclaredField(\"value\"); 9 10 //改变value属性的访问权限11 valueField.setAccessible(true);12 13 char[] value = (char[]) valueField.get(s);14 15 //改变value所引用的数组中的第5个字符16 value[5] = '_';17 18 System.out.println(\"s = \" + s); //Hello_World19 &#125;","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 类型转换","slug":"Java类型转换","date":"2017-08-20T12:28:23.000Z","updated":"2018-08-24T07:42:07.654Z","comments":true,"path":"Java类型转换.html","link":"","permalink":"http://xiaoqinghua.site/Java类型转换.html","excerpt":"","text":"类型转换Java 语言是一种强类型的语言。强类型的语言有以下几个要求： 变量或常量必须有类型:要求声明变量或常量时必须声明类型，而且只能在声明以后才能使用。 赋值时类型必须一致:值的类型必须和变量或常量的类型完全一致。 运算时类型必须一致:参与运算的数据类型必须一致才能运算。 但是在实际的使用中，经常需要在不同类型的值之间进行操作，这就需要一种新的语法来适应这种需要，这个语法就是数据类型转换。 在数值处理这部分，计算机和现实的逻辑不太一样，对于现实来说，1和 1.0 没有什么区别，但是对于计算机来说，1 是整数类型，而 1.0 是小数类型，其在内存中的存储方式以及占用的空间都不一样，所以类型转换在计算机内部是必须的。 Java 语言中的数据类型转换有两种： 自动类型转换:编译器自动完成类型转换，不需要在程序中编写代码。 强制类型转换:强制编译器进行类型转换，必须在程序中编写代码。 由于基本数据类型中 boolean 类型不是数字型，所以基本数据类型的转换是出了 boolean 类型以外的其它 7 种类型之间的转换。下面来具体介绍两种类型转换的规则、适用场合以及使用时需要注意的问题。 自动类型转换自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。由于实际开发中这样的类型转换很多，所以 Java 语言在设计时，没有为该操作设计语法，而是由 JVM 自动完成。 转换规则：从存储范围小的类型到存储范围大的类型。具体规则为：byte→short(char)→int→long→float→double 也就是说 byte 类型的变量可以自动转换为 short 类型，示例代码： 12byte b = 10;short sh = b;这里在赋值时，JVM 首先将 b 的值转换为 short 类型，然后再赋值给 sh。 在类型转换时可以跳跃。示例代码： 12byte b1 = 100;int n = b1; 注意问题:在整数之间进行类型转换时，数值不发生改变，而将整数类型，特别是比较大的整数类型转换成小数类型时，由于存储方式不同，有可能存在数据精度的损失。 强制类型转换强制类型转换，也称显式类型转换，是指必须书写代码才能完成的类型转换。该类类型转换很可能存在精度的损失，所以必须书写相应的代码，并且能够忍受该种损失时才进行该类型的转换。 转换规则:从存储范围大的类型到存储范围小的类型。 具体规则为：double→float→long→int→short(char)→byte 语法格式为：(转换到的类型)需要转换的值 示例代码： 12double d = 3.10;int n = (int)d; 这里将 double 类型的变量 d 强制转换成 int 类型，然后赋值给变量 n。需要说明的是小数强制转换为整数，采用的是去 1 法，也就是无条件的舍弃小数点的所有数字，则以上转换出的结果是 3。整数强制转换为整数时取数字的低位，例如 int 类型的变量转换为 byte 类型时，则只去 int 类型的低 8 位(也就是最后一个字节)的值。示例代码： 1234int n = 123;byte b = (byte)n;int m = 1234;byte b1 = (byte)m; 则 b 的值还是 123，而 b1 的值为-46。b1 的计算方法如下：m 的值转换为二进制是10011010010，取该数字低8位的值作为b1的值，则b1的二进制值是11010010，按照机器数的规定，最高位是符号位，1代表负数，在计算机中负数存储的是补码，则该负数的原码是 10101110，该值就是十进制的-46。注意问题:强制类型转换通常都会存储精度的损失，所以使用时需要谨慎。","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Java 数据类型","slug":"Java基本数据类型","date":"2017-08-19T03:58:52.000Z","updated":"2018-08-24T07:40:53.494Z","comments":true,"path":"Java基本数据类型.html","link":"","permalink":"http://xiaoqinghua.site/Java基本数据类型.html","excerpt":"","text":"基本类型，或者叫做内置类型，是JAVA中不同于类的特殊类型。它们是我们编程中使用最频繁的类型。java是一种强类型语言，第一次申明变量必须说明数据类型（Java 9 之后的 var类型推断，了解一下），第一次变量赋值称为变量的初始化。 1. Java的简单类型及其封装器类Java基本类型共有八种，基本类型可以分为三类，字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。JAVA中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。8 中类型表示范围如下： 123456789101112131415byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。char：16位，存储Unicode码，用单引号赋值。short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。boolean：只有true和false两个取值。 对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。如： 12345678910111213141516171819基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE 注意：float、double 两种类型的最小值与 Float.MIN_VALUE、 Double.MIN_VALUE 的值并不相同，实际上 Float.MIN_VALUE 和 Double.MIN_VALUE 分别指的是 float 和 double 类型所能表示的最小正数。也就是说存在这样一种情况，0 到 ±Float.MIN_VALUE 之间的值 float 类型无法表示，0 到 ±Double.MIN_VALUE 之间的值 double 类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。 Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314。 Java基本类型存储在栈中，因此它们的存取速度要快于存储在堆中的对应包装类的实例对象。从Java5.0（1.5）开始，JAVA虚拟机（Java Virtual Machine）可以完成基本类型和它们对应包装类之间的自动转换。因此我们在赋值、参数传递以及数学运算的时候像使用基本类型一样使用它们的包装类，但这并不意味着你可以通过基本类型调用它们的包装类才具有的方法。另外，所有基本类型（包括void）的包装类都使用了final修饰，因此我们无法继承它们扩展新的类，也无法重写它们的任何方法。 基本类型的优势：数据存储相对简单，运算效率比较高包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想 2.Java中的常量十六进制整型常量：以十六进制表示时，需以0x或0X开头，如0xff,0X9A。 八进制整型常量：八进制必须以0开头，如0123，034。 长整型：长整型必须以L作结尾，如9L,342L。 浮点数常量：由于小数常量的默认类型是double型，所以float类型的后面一定要加f(F)。同样带小数的变量默认为double类型。 如：float f; 12//必须声明ff = 1.3f; 字符常量：字符型常量需用两个单引号括起来（注意字符串常量是用两个双引号括起来）。Java中的字符占两个字节(因为字符是char，一个\b char 占两个字节，16位)。一些常用的转义字符： 12345678910111213\\r表示接受键盘输入，相当于按下了回车键；\\n表示换行；\\t表示制表符，相当于Table键；\\b表示退格键，相当于Back Space键；\\&apos;表示单引号；\\&apos;&apos;表示双引号；\\\\表示一个斜杠\\。 3. 数据类型之间的转换1、简单类型数据间的转换,有两种方式:自动转换和强制转换,通常发生在表达式中或方法的参数传递时。 自动转换: 具体地讲,当一个较”小”数据与一个较”大”的数据一起运算时,系统将自动将”小”数据转换成”大”数据,再进行运算。而在方法调用时,实际参数较”小”,而被调用的方法的形式参数数据又较”大”时(若有匹配的,当然会直接调用匹配的方法),系统也将自动将”小”数据转换成”大”数据,再进行方法的调用,自然,对于多个同名的重载方法,会转换成最”接近”的”大”数据并进行调用。这些类型由”小”到”大”分别为 (byte，short，char)--int--long--float—double。这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小。 12345678910111213①下面的语句可以在Java中直接通过：byte b;int i=b; long l=b; float f=b; double d=b;②如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值，例如char c=&apos;c&apos;; int i=c;System.out.println(&quot;output:&quot;+i);输出：output:99;③对于byte,short,char三种类型而言，他们是平级的，因此不能相互自动转换，可以使用下述的强制类型转换。short i=99 ; char c=(char)i; System.out.println(&quot;output:&quot;+c);输出：output:c; 强制转换: 将”大”数据转换为”小”数据时，你可以使用强制类型转换。即你必须采用下面这种语句格式： int n=(int)3.14159/2;可以想象，这种转换肯定可能会导致溢出或精度的下降。 2、表达式的数据类型自动提升, 关于类型的自动提升，注意下面的规则。 1234567①所有的byte,short,char型的值将被提升为int型；②如果有一个操作数是long型，计算结果是long型；③如果有一个操作数是float型，计算结果是float型；④如果有一个操作数是double型，计算结果是double型； 例， byte b; b=3; b=(byte)(b*3);//必须声明byte。ps: 运算才会提升类型，b=3不会把 byte b 变成 int b,而b=b*3会提升； 3、包装类过渡类型转换 一般情况下，我们首先声明一个变量，然后生成一个对应的包装类，就可以利用包装类的各种方法进行类型转换了。例如： 123456789101112131415①当希望把float型转换为double型时：float f1 = 100.00f;Float F1 = new Float(f1);double d1 = F1.doubleValue(); //F1.doubleValue()为Float类的返回double值型的方法②当希望把double型转换为int型时：double d1 = 100.00;Double D1 = new Double(d1);int i1 = D1.intValue(); 简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。即：Boolean(boolean value)、Character(char value)、Integer(int value)、Long(long value)、Float(float value)、Double(double value) 而在各个包装类中，总有形为××Value()的方法，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。 4、字符串与其它类型间的转换 其它类型向字符串的转换 12345①调用类的串转换方法: X.toString();②自动转换: X + &quot;&quot;;③使用 String 的方法: String.volueOf(X); 字符串作为值,向其它类型的转换 123456789101112131415161718192021①先转换成相应的封装器实例,再调用对应的方法转换成其它类型例如，字符中&quot;32.1&quot;转换`double`型的值的格式为:`new Float(&quot;32.1&quot;).doubleValue()`。也可以用:`Double.valueOf(&quot;32.1&quot;).doubleValue()`②静态 parseXXX 方法String s = &quot;1&quot;;byte b = Byte.parseByte( s );short t = Short.parseShort( s );int i = Integer.parseInt( s );long l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s );③Character 的 getNumericValue(char ch)方法 5、Date类与其它数据类型的相互转换 整型和Date类之间并不存在直接的对应关系，只是你可以使用int型为分别表示年、月、日、时、分、秒，这样就在两者之间建立了一个对应关系，在作这种转换时，你可以使用Date类构造函数的三种形式： 12345①Date(int year, int month, int date)：以int型表示年、月、日②Date(int year, int month, int date, int hrs, int min)：以int型表示年、月、日、时、分③Date(int year, int month, int date, int hrs, int min, int sec)：以int型表示年、月、日、时、分、秒 在长整型和Date类之间有一个很有趣的对应关系，就是将一个时间表示为距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。对于这种对应关系，Date类也有其相应的构造函数：Date(long date)。 获取Date类中的年、月、日、时、分、秒以及星期你可以使用Date类的getYear()、getMonth()、getDate()、getHours()、getMinutes()、getSeconds()、getDay()方法，你也可以将其理解为将Date类转换成int。 而Date类的getTime()方法可以得到我们前面所说的一个时间对应的长整型数，与包装类一样，Date类也有一个toString()方法可以将其转换为String类。 有时我们希望得到Date的特定格式，例如20020324，我们可以使用以下方法: 1234567891011121314151617181920212223242526272829import java.text.SimpleDateFormat;import java.util.*;java.util.Date date = new java.util.Date(); //如果希望得到YYYYMMDD的格式SimpleDateFormat sy1 = new SimpleDateFormat(&quot;yyyyMMDD&quot;);String dateFormat = sy1.format(date);//如果希望分开得到年，月，日SimpleDateFormat sy = new SimpleDateFormat(&quot;yyyy&quot;);SimpleDateFormat sm = new SimpleDateFormat(&quot;MM&quot;);SimpleDateFormat sd = new SimpleDateFormat(&quot;dd&quot;);String syear = sy.format(date);String smon = sm.format(date);String sday = sd.format(date); 总结：只有boolean不参与数据类型的转换 123456789101112131.自动类型的转换：a.常数在表数范围内是能够自动类型转换的b.数据范围小的能够自动向数据类型大的转换（注意特例）int 到 float，long 到 float，long 到 double 同样可以自动转换的，只不过会丢失精度，因为存储结构不同c.引用类型能够自动转换为父类d.基本类型和它们包装类型是能够互相转换的2.强制类型转换：用圆括号括起来目标类型，置于变量前 4.Java引用类型Java有 5 种引用类型（对象类型）：类 接口 数组 枚举 标注 引用类型：底层结构和基本类型差别较大 JVM的内存空间： 1234567891011121314151617（1）Heap 堆空间：分配对象 `new Student（）`（2）Stack 栈空间：临时变量 `Student stu`（3）Code 代码区 ：类的定义，静态资源 `Student.class`eg：Student stu = new Student（）； //new 在内存的堆空间创建对象stu.study(); //把对象的地址赋给stu引用变量上例实现步骤：a.JVM 加载 `Student.class` 到Code区b.`new Student()`在堆空间分配空间并创建一个Student实例c.将此实例的地址赋值给引用`stu`栈空间","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Java-Fundamental","slug":"Code/Java-Fundamental","permalink":"http://xiaoqinghua.site/categories/Code/Java-Fundamental/"}],"tags":[{"name":"Java-Fundamental","slug":"Java-Fundamental","permalink":"http://xiaoqinghua.site/tags/Java-Fundamental/"}]},{"title":"Redis基础及高级特性与性能调优","slug":"Redis基础及高级特性与性能调优","date":"2017-07-23T14:35:52.000Z","updated":"2018-08-24T07:45:04.148Z","comments":true,"path":"Redis基础及高级特性与性能调优.html","link":"","permalink":"http://xiaoqinghua.site/Redis基础及高级特性与性能调优.html","excerpt":"","text":"本文将从 Redis 的基本特性入手，通过讲述 Redis 的数据结构和主要命令对 Redis 的基本性能进行直观的介绍。之后概览 Redis 提供的高级能力，并在部署、维护、性能调优等多个方面进行更深入的介绍和指导。 本文适合使用 Redis 的普通开发人员，以及对 Redis 进行选型、架构设计和性能调优的架构设计人员。 目录 概述 Redis 的数据结构和相关常用命令 数据持久化 内存管理和数据淘汰机制 Pipelining 事务与 Scripting Redis 性能调优 主从复制与集群分片 Redis Java 客户端的选择 概述Redis 是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。Redis 支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图(Bitmap)、HyperLogLogs等。Redis 具备 LRU(Least Recently Use)淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过 Redis Sentinel 实现的高可用方案，同时还支持通过 Redis Cluster 实现的数据自动分片能力。 Redis 的主要功能都是基于\b单线程模型\b实现，也就是说 Redis 使用一个线程来服务所有的客户端请求，同时 Redis 采用了\b非阻塞式IO，并精细地优化各种命令\b的算法时间复杂度，这些信息意味着： Redis 是线程安全的 (因为只有一个线程)，其所有的操作都是原子的，不会因为\b并发产生数据异常 Redis 的速度非常快（因为使用的是非阻塞式IO，且大部分命令的算法时间复杂度都是O(1)） 使用高\b耗时的 \bRedis 命令是很危险的，会占用唯一的线程的大量处理时间，导致所有请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用） Redis 的数据结构和相关常用命令KeyRedis 采用Key-Value型的基本数据结构，任何二进制序列都可以作为 Redis 的 Key 使用（例如普通的字符串或一张\b JPEG 图片）关于 Key 的一些注意事项\b: 不要使用过长的 Key。\b例如使用一个1024字节的 key \b就不是一个好主意，不仅会消耗更多的内存，还会导致查询的效率降低 Key 短到缺失了可读性也是不好的，例如&quot;u1000flw&quot;比起&quot;user:1000:followers&quot;来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦 最好使用统一规范来设计 Key ，比如&quot;object-type:id:attr&quot;，以\b这一规范设计出的 Key 可能是&quot;user:1000&quot;或者&quot;comment:1234:reply-to&quot; Redis 允许的最大 Key 长度是 512MB (对 Value 的长度限制也是 512MB) StringString 是 Redis 的基础数据类型，Redis 没有 Int、Float、Boolean等数据类型的概念，所有的基本类型在 Redis 中都以 \bString 体现 与\b String 相关的常用命令： \bSET： 为一个 key 设置 \bvalue，可以配合EX/PX参数指定 key 的有效期，\b通过NX/XX参数针对 key 是否存在的情况进行分区操作，时间复杂度O(1) GET： 获取某个 key 对用的 value，时间复杂度为O(1) GETSET： 为一个 key 设置 value，并返回该 key 的原 value，时间复杂度O(1) MSET： 为多个 key 设置 value，时间复杂度为O(N) MSETNX： 同 MSET，\b\b如果指定的 key 中有任意一个已存在，则不进行任何操作，时间复杂度O(N) MGET： 获取\b\b\b多个 key 对应的 value ，时间复杂度O(N) 上文提到过，Redis 的基本数据类型只有 String，但 Redis可以把 String 作为整形或者浮点型数字来使用，主要体现在INCR、DECR类的命令上： INCR：将 key 对应的 value 值自增1，并返回自增后的值。只对可以转换为整形的 String 数据起作用。时间复杂度O(1) INCRBY： \b将 key 对应的 value 值自增指定的整形数值，并返回自增之后的值。只对可以转换为整形的 String 数据起作用。时间复杂度为O(1) DECR/DECRBY：同INCR/INCRBY，自增改为自减 INCR/DECR系列命令要求操作的 value 类型为 String，并可以转换为64位带符号的整形数字，否则会返回错误。也就是说，进行INCR/DECR系列命令的 value，\b必须在[-2^63~2^63-1]范围内 前文提到过，Redis 采用单线程模型，天然是线程安全的，这使得INCR/DECR命令可以非常便利的实现高并发场景\b下的精确控制。 例1：库存控制在高并发场景下实现\b库存余量的精准校验，确保不出现超卖的情况\b设置库存总量： 1SET inv:remain &quot;100&quot; 库存扣减 + 余量校验 1DECR inv:remain 当DECR\b命令返回值大于等于0时，说明库存余量通过校验，如果返回小于0的值，则说明库存已经耗尽。 假设同时有300个并发请求进行库存扣减，Redis 能够确保这300个请求分别得到99 ~ -200的返回值，每个请求得到的返回值都是唯一的，绝对不会出现两个请求得到一样的返回的情况。 例2：自增序列生成实现类似于RDBMS的Sequence功能，生成一系列唯一序列号 设置序列起始值： 1SET sequence &quot;10000&quot; 获取一个序列值： 1INCR sequence 直接将返回值作为序列使用即可。 获取一批（如100个）序列值： 1INCRBY sequence 100 假设返回值为N，那么[N - 99 ~ N]的数值都是可以用的序列值。 当多个客户端同时向 Redis 申请自增序列时，Redis 能够确保每个客户端得到的序列值或序列范围都是全局唯一的。绝对不会出现不同客户端得到了重复的序列值的情况。 ListRedis 的 list 是链表的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在 List 的连段执行插入元素和弹出元素的操作。虽然 List 也支持在特定index上插入和读取元素的功能，但其时间复杂度较高(O(N))，应小心使用。 与 List 相关的常用命令： LPUSH： 向指定的 List 的左侧（即头部）插入1个或多个元素，返回插入后的 List 长度。时间复杂度O(N), N 为插入元素的数量 RPUSH：同 LPUSH，向 List 的右侧（即尾部）插入一个或多个元素 LPOP：从指定的 List 的左侧（即头部）移除一个元素并返回，时间复杂度O(1) RPOP：同 LPOP ，从指定的 List 的右侧（即尾部）移除一个元素并返回 LPUSHX/RPUSHX：与 LPUSH/RPUSH 类似，区别在于，LPUSHX/RPUSHX 操作的 key 如果不存在，则不会进行任何操作 LLEN：返回指定的 List 长度，时间复杂度O(1) LRANGE：返回指定 List 中指定范围的元素 （双端包含，即 LRANGE key 0 10 会返回10个元素），时间复杂度O(N)。应尽可能控制以此获取的元素数量，一次获取过大范围的 List 元素会导致延迟，同时对长度不可预知的 List ，避免使用 LRANGE key 0 -1这样的完整便利操作 应谨慎使用的 List 相关命令： LINDEX：返回指定 List 指定 index 上的元素，如果 index 越界，返回 nil。index 数值是回环的，即 -1 代表 List 最后一个位置，-2 代表 List 倒数第二个位置。时间复杂度O(N) LSET：将指定 List 指定 index 上的元素设置为 value，如果 index 越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1) LINSERT：向指定 List 中指定元素之前/之后插入一个新元素，并返回操作后的 List 长度。如果指定的元素不存在，返回 -1。如果指定 key 不存在，不会进行任何操作，时间复杂度O(N) 由于 Redis 的 List 是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。 换句话说，Redis 的 List 实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用 Redis 的 List 数据结构。 为了更好支持队列的特性，Redis 还提供了一系列阻塞式的操作命令，如BLPOP/BRPOP等，能够实现类似于BlockingQueue的能力，即在 List 为空时，阻塞该连接，直到 List 中有对象可以出队时再返回。 HashHash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。Hash的优点包括： 可以实现二元查找，如”查找ID为1000的用户的年龄” 比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗 当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令 与Hash相关的常用命令： HSET：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1) HGET：返回指定Hash中field字段的值，时间复杂度O(1) HMSET/HMGET：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量 HSETNX：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1) HEXISTS：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1) HDEL：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量 HINCRBY：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1) 应谨慎使用的Hash相关命令： HGETALL：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N) HKEYS/HVALS：返回指定Hash中所有的field/value，时间复杂度O(N) 上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关，对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历； SetRedis Set是无序的，不可重复的String集合。 与Set相关的常用命令： SADD：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数 SREM：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数 SRANDMEMBER：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数 SPOP：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数 SCARD：返回指定Set中的member个数，时间复杂度O(1) SISMEMBER：判断指定的value是否存在于指定Set中，时间复杂度O(1) SMOVE：将指定member从一个Set移至另一个Set 慎用的Set相关命令： SMEMBERS：返回指定Hash中所有的member，时间复杂度O(N) SUNION/SUNIONSTORE：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 SINTER/SINTERSTORE：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 SDIFF/SDIFFSTORE：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。可以考虑通过SSCAN命令遍历获取相关Set的全部member，如果需要做并集/交集/差集计算，可以在客户端进行，或在不服务实时查询请求的Slave上进行。 Sorted SetRedis Sorted Set是有序的、不可重复的String集合。Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。如果多个member拥有相同的score，则以字典序进行升序排序。 Sorted Set非常适合用于实现排名。 Sorted Set的主要命令： ZADD：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量 ZREM：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量 ZCOUNT：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N)) ZCARD：返回指定Sorted Set中的member数量，时间复杂度O(1) ZSCORE：返回指定Sorted Set中指定member的score，时间复杂度O(1) ZRANK/ZREVRANK：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N)) ZINCRBY：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N)) 慎用的Sorted Set相关命令： ZRANGE/ZREVRANGE：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数 ZRANGEBYSCORE/ZREVRANGEBYSCORE：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M) ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M) 上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。可以通过ZSCAN命令来进行游标式的遍历，或通过LIMIT参数来限制返回member的数量（适用于ZRANGEBYSCORE和ZREVRANGEBYSCORE命令），以实现游标式的遍历。 Bitmap和HyperLogLogRedis的这两种数据结构相较之前的并不常用，在本文中只做简要介绍，如想要详细了解这两种数据结构与其相关的命令； Bitmap在Redis中不是一种实际的数据类型，而是一种将String作为Bitmap使用的方法。可以理解为将String转换为bit数组。使用Bitmap来存储true/false类型的简单数据极为节省空间。 HyperLogLogs是一种主要用于数量统计的数据结构，它和Set类似，维护一个不可重复的String集合，但是HyperLogLogs并不维护具体的member内容，只维护member的个数。也就是说，HyperLogLogs只能用于计算一个集合中不重复的元素数量，所以它比Set要节省很多内存空间。 其他常用命令 EXISTS：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1) DEL：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量 EXPIRE/PEXPIRE：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1) TTL/PTTL：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1) RENAME/RENAMENX：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1) TYPE：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1) CONFIG GET：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1) CONFIG SET：为Redis某个配置项设置新值，时间复杂度O(1) CONFIG REWRITE：让Redis重新加载redis.conf中的配置 数据持久化Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。 必须使用数据持久化吗？Redis的数据持久化机制是可以关闭的。如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。但通常来说，仍然建议至少开启RDB方式的数据持久化，因为： RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成 Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快 现在硬盘那么大，真的不缺那一点地方 RDB采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。可以在配置文件中配置Redis进行快照保存的时机： 1save [secends] [changes] 意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如： 1save 60 100 会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。可以配置多条save指令，让Redis执行多级的快照保存策略。Redis默认开启RDB快照，默认的RDB策略如下： 123save 900 1save 300 10save 60 10000 也可以通过BGSAVE命令手工触发RDB快照保存。 RDB的优点： 对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。 每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。 使用RDB文件进行数据恢复比使用AOF要快很多。 RDB的缺点： 快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。 如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。 AOF采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。 AOF默认是关闭的，如要开启，进行如下配置： 1appendonly yes AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定： appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快 appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢 appendfsync everysec：折中的做法，交由后台线程每秒fsync一次 随着AOF不断地记录写操作日志，必定会出现一些无用的日志，例如某个时间点执行了命令SET key1 “abc”，在之后某个时间点又执行了SET key1 “bcd”，那么第一条命令很显然是没有用的。大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。AOF rewrite可以通过BGREWRITEAOF命令触发，也可以配置Redis定期自动进行： 12auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。 AOF的优点： 最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。 AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。 AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。 AOF的缺点： AOF文件通常比RDB文件更大 性能消耗比RDB高 数据恢复速度比RDB慢 内存管理与数据淘汰机制最大内存设置默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。 在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。 通过如下配置控制Redis使用的最大内存： 1maxmemory 100mb 在内存占用达到maxmemory后，再向Redis写入数据时，Redis会： 根据配置的数据淘汰策略尝试淘汰数据，释放空间 如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行 在为Redis设置maxmemory时，需要注意： 如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间，如果maxmemory过于接近主机的可用内存，导致数据同步时内存不足。所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。 数据淘汰机制Redis提供了5种数据淘汰策略： volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰 volatile-random：随机淘汰数据，只淘汰设定了有效期的key allkeys-random：随机淘汰数据，所有的key都可以被淘汰 volatile-ttl：淘汰剩余有效期最短的key 最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。 一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。 配置方法： 1maxmemory-policy volatile-lru #默认是noeviction，即不进行数据淘汰 PipelinlingPipelinlingRedis提供许多批量操作的命令，如MSET/MGET/HMSET/HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的，但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。 然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如： 123SET a &quot;abc&quot;INCR bHSET c name &quot;hi&quot; 此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。使用pipelining时，只需要从客户端一次向Redis发送多条命令（以\\r\\n）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如： 1234$ (printf &quot;PING\\r\\nPING\\r\\nPING\\r\\n&quot;; sleep 1) | nc localhost 6379+PONG+PONG+PONG 大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。 Pipelining的局限性Pipelining只能用于执行连续且无相关性的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。 通过Scripting功能，可以规避这一局限性 事务与ScriptingPipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。 比如获取当前累计的PV数并将其清0 1234&gt; GET vCount12384&gt; SET vCount 0OK 如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。 Redis的事务可以确保复数命令执行时的原子性。也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。 通过MULTI和EXEC命令来把这两个命令加入一个事务中： 123456789&gt; MULTIOK&gt; GET vCountQUEUED&gt; SET vCount 0QUEUED&gt; EXEC1) 123842) OK Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。 可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。 需要注意的是，Redis事务不支持回滚：如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误，2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。 通过事务实现CASRedis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。 假设要实现将某个商品的状态改为已售： 12if(exec(HGET stock:1001 state) == &quot;in stock&quot;) exec(HSET stock:1001 state &quot;sold&quot;); 这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。 使用WATCH命令和事务可以解决这一问题： 123456exec(WATCH stock:1001);if(exec(HGET stock:1001 state) == &quot;in stock&quot;) &#123; exec(MULTI); exec(HSET stock:1001 state &quot;sold&quot;); exec(EXEC);&#125; WATCH的机制是：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。 Scripting通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读/写交互放在服务端进行，避免过多的数据交互，提升性能。 Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。 Redis性能调优尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。 针对Redis的性能优化，主要从下面几个层面入手： 最初的也是最重要的，确保没有让Redis执行耗时长的命令 使用pipelining将连续执行的命令组合执行 操作系统的Transparent huge pages功能必须关闭： 1echo never &gt; /sys/kernel/mm/transparent_hugepage/enable 如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。 检查数据持久化策略 考虑引入读写分离机制 长耗时命令Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在文本和官方文档中均对每个命令的时间复杂度有说明。 通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。 避免在使用这些O(N)命令时发生问题主要有几个办法： 不要把List当做列表使用，仅当做队列来使用 通过机制严格控制Hash、Set、Sorted Set的大小 可能的话，将排序、并集、交集等操作放在客户端执行 绝对禁止使用KEYS命令 避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历 Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。 Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个： 12slowlog-log-slower-than xxxms #执行时间慢于xxx毫秒的命令计入Slow Logslowlog-max-len xxx #Slow Log的长度，即最大纪录多少条Slow Log 使用SLOWLOG GET [number]命令，可以输出最近进入Slow Log的number条命令。使用SLOWLOG RESET命令，可以重置Slow Log 网络引发的延迟 尽可能使用长连接或连接池，避免频繁创建销毁连接 客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节 数据持久化引发的延迟Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略： AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响 AOF + fsync every second是比较好的折中方案，每秒fsync一次 AOF + fsync never会提供AOF持久化方案下的最优性能 使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置 每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟 1Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。 1可以通过INFO命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒） Swap引发的延迟当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。 /proc//smaps文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。 数据淘汰引发的延迟当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。 引入读写分离机制Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。 主从复制与集群分片主从复制Redis支持一主多从的主从复制架构。一个Master实例负责处理所有的写请求，Master将写操作同步至所有Slave。借助Redis的主从复制，可以实现读写分离和高可用： 实时性要求不是特别高的读请求，可以在Slave上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的Redis命令，可以专门规划出1个或几个Slave用于服务这些统计任务 借助Redis Sentinel可以实现高可用，当Master crash后，Redis Sentinel能够自动将一个Slave晋升为Master，继续提供服务 启用主从复制非常简单，只需要配置多个Redis实例，在作为Slave的Redis实例中配置： 1slaveof 192.168.1.1 6379 #指定Master的IP和端口 当Slave启动后，会从Master进行一次冷启动数据同步，由Master触发BGSAVE生成RDB文件推送给Slave进行导入，导入完成后Master再将增量数据通过Redis Protocol同步给Slave。之后主从之间的数据便一直以Redis Protocol进行同步 使用Sentinel做自动failoverRedis的主从复制功能本身只是做数据同步，并不提供监控和自动failover能力，要通过主从复制功能来实现Redis的高可用，还需要引入一个组件：Redis Sentinel Redis Sentinel是Redis官方开发的监控组件，可以监控Redis实例的状态，通过Master节点自动发现Slave节点，并在监测到Master节点失效时选举出一个新的Master，并向所有Redis实例推送新的主从配置。 Redis Sentinel需要至少部署3个实例才能形成选举关系。 关键配置： 1234sentinel monitor mymaster 127.0.0.1 6379 2 #Master实例的IP、端口，以及选举需要的赞成票数sentinel down-after-milliseconds mymaster 60000 #多长时间没有响应视为Master失效sentinel failover-timeout mymaster 180000 #两次failover尝试间的间隔时长sentinel parallel-syncs mymaster 1 #如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用 另外需要注意的是，Redis Sentinel实现的自动failover不是在同一个IP和端口上完成的，也就是说自动failover产生的新Master提供服务的IP和端口与之前的Master是不一样的，所以要实现HA，还要求客户端必须支持Sentinel，能够与Sentinel交互获得新Master的信息才行。 集群分片为何要做集群分片： Redis中存储的数据量大，一台主机的物理内存已经无法容纳 Redis的写请求并发量大，一个Redis实例以无法承载 当上述两个问题出现时，就必须要对Redis进行分片了。Redis的分片方案有很多种，例如很多Redis的客户端都自行实现了分片功能，也有向Twemproxy这样的以代理方式实现的Redis分片方案。然而首选的方案还应该是Redis官方在3.0版本中推出的Redis Cluster分片方案。 本文不会对Redis Cluster的具体安装和部署细节进行介绍，重点介绍Redis Cluster带来的好处与弊端。 Redis Cluster的能力 能够自动将数据分散在多个节点上 当访问的key不在当前分片上时，能够自动将请求转发至正确的分片 当集群中部分节点失效时仍能提供服务 其中第三点是基于主从复制来实现的，Redis Cluster的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致，唯一的区别是省去了Redis Sentinel这一额外的组件，由Redis Cluster负责进行一个分片内部的节点监控和自动failover。 Redis Cluster分片原理Redis Cluster中共有16384个hash slot，Redis会计算每个key的CRC16，将结果与16384取模，来决定该key存储在哪一个hash slot中，同时需要指定Redis Cluster中每个数据分片负责的Slot数。Slot的分配在任何时间点都可以进行重新分配。 客户端在对key进行读写操作时，可以连接Cluster中的任意一个分片，如果操作的key不在此分片负责的Slot范围内，Redis Cluster会自动将请求重定向到正确的分片上。 hash tags在基础的分片原则上，Redis还支持hash tags功能，以hash tags要求的格式明明的key，将会确保进入同一个Slot中。例如：{uiv}user:1000和{uiv}user:1001拥有同样的hash tag {uiv}，会保存在同一个Slot中。 使用Redis Cluster时，pipelining、事务和LUA Script功能涉及的key必须在同一个数据分片上，否则将会返回错误。如要在Redis Cluster中使用上述功能，就必须通过hash tags来确保一个pipeline或一个事务中操作的所有key都位于同一个Slot中。 1有一些客户端（如Redisson）实现了集群化的pipelining操作，可以自动将一个pipeline里的命令按key所在的分片进行分组，分别发到不同的分片上执行。但是Redis不支持跨分片的事务，事务和LUA Script还是必须遵循所有key在一个分片上的规则要求。 主从复制 vs 集群分片在设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？ 从各个方面看，Redis Cluster都是优于主从复制的方案 Redis Cluster能够解决单节点上数据量过大的问题 Redis Cluster能够解决单节点访问压力过大的问题 Redis Cluster包含了主从复制的能力 那是不是代表Redis Cluster永远是优于主从复制的选择呢？ 并不是。 软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用Redis Cluster的弊端包括： 维护难度增加。在使用Redis Cluster时，需要维护的Redis实例数倍增，需要监控的主机数量也相应增加，数据备份/持久化的复杂度也会增加。同时在进行分片的增减操作时，还需要进行reshard操作，远比主从模式下增加一个Slave的复杂度要高。 客户端资源消耗增加。当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。 性能优化难度增加。你可能需要在多个分片上查看Slow Log和Swap日志才能定位性能问题。 事务和LUA Script的使用成本增加。在Redis Cluster中使用事务和LUA Script特性有严格的限制条件，事务和Script中操作的key必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的key进行额外的规划和规范要求。如果应用的场景中大量涉及事务和Script的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。 所以说，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在确实有必要引入数据分片时再使用Redis Cluster。下面是一些建议： 需要在Redis中存储的数据有多大？未来2年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用LRU算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出Redis需要使用的物理内存。 用于部署Redis的主机物理内存有多大？有多少可以分配给Redis使用？对比(1)中的内存需求评估，是否足够用？ Redis面临的并发写压力会有多大？在不使用pipelining时，Redis的写性能可以超过10万次/秒在使用Redis时，是否会使用到pipelining和事务功能？使用的场景多不多？ 综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对Redis的容量需求，且Redis面临的并发写压力距离Benchmark值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。同时，如果应用中大量使用pipelining和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。 Redis Java客户端的选择Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson和lettuce。 在这里对Jedis和Redisson进行对比介绍 Jedis： 轻量，简洁，便于集成和改造 支持连接池 支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster 不支持读写分离，需要自己实现 文档差（真的很差，几乎没有……） Redisson： 基于Netty实现，采用非阻塞IO，性能高 支持异步请求 支持连接池 支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster 不支持事务，官方建议以LUA Scripting代替事务 支持在Redis Cluster架构下使用pipelining 支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用 内建Tomcat Session Manager，为Tomcat 6/7/8提供了会话共享功能 可以与Spring Session集成，实现基于Redis的会话共享 文档较丰富，有中文文档 对于Jedis和Redisson的选择，同样应遵循前述的原理，尽管Jedis比起Redisson有各种各样的不足，但也应该在需要使用Redisson的高级特性时再选用Redisson，避免造成不必要的程序复杂度提升。 Jedis：github：https://github.com/xetorthio/jedis文档：https://github.com/xetorthio/jedis/wiki Redisson：github：https://github.com/redisson/redisson文档：https://github.com/redisson/redisson/wiki","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Redis","slug":"Code/Redis","permalink":"http://xiaoqinghua.site/categories/Code/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://xiaoqinghua.site/tags/Redis/"}]},{"title":"Redis笔记","slug":"Redis笔记","date":"2017-07-01T15:04:49.000Z","updated":"2018-08-24T07:45:12.677Z","comments":true,"path":"Redis笔记.html","link":"","permalink":"http://xiaoqinghua.site/Redis笔记.html","excerpt":"","text":"Redis 重点笔记1、为什么使用 redis2、使用 redis 容易造成什么问题3、单线程的 redis 为什么这么快4、redis 的数据类型，以及每种数据类型的使用场景5、redis 的过期策略以及内存淘汰机制6、redis 和数据库双写一致性问题7、如何应对缓存穿透和缓存雪崩问题8、如何解决 redis 的并发竞争问题 笔记解析1、为什么使用 redis分析：在项目中使用 redis 主要考虑两点性能和并发。除此之外，redis 还具备做分布式锁等其他功能（// TODO 什么其他功能），但是如果只是为了分布式锁这些其他功能，完全还有其他中间件（如 zookeeper 等）代替，并不是非要用 redis。 性能 和 并发 性能： \b如下图所示，我们在碰到需要执行耗时特别久，且执行结果不频繁变动的 SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应，因此提高了性能。 并发： 如下图所示，在高并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 redis 做一个缓冲操作，让请求先访问到 redis，而不是直接访问数据库。 2、使用 redis 容易造成什么问题分析：诚然 redis 解决了很多问题，提高了系统性能，优化了系统处理并发的能力，但是使用 redis 也会遇到解决上述问题进而所产生的衍生问题。 主要是四个问题 缓存和数据库双写一致性问题 缓存雪崩（大面积的数据崩溃） 缓存击穿 缓存并发竞争问题 下文中给出解决方案。 3、单线程的 redis 为什么这么快分析：这个问题其实是对 redis 内部机制的一个考察。redis 是单线程的！！！！ 为什么快，主要是以下三点 纯内存操作 单线程操作，避免频繁切换上下文 采用非阻塞 I/O 多路复用机制（想到了 netty ） I/O 多路复用：单个线程，通过跟踪每个I/O流的状态，来管理多个I/O流。下图是类比到真实的 redis 线程模型：我们使用redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/O 多路复用的程序，将其置入队列之中（//TODO 可理解为一个线程模型，单线程处理），然后发送到文件事件分派器，依次去队列中取，转发到不同的事件处理器中。redis的这个I/O 多路复用机制，还体现在redis提供了select，epoll，evport，kqueue`等多路复用函数库。 4、redis的数据类型，以及每种数据类型的使用场景分析：这是一个基础问题，配合熟记食用更佳。 有五种数据类型 String 常规set/get操作，value可以是String也可以是数字。一般做一些复杂计算功能的缓存。 hash hash数据类型的value存放的是结构化的对象，比较方便的就是操作其中的某个字段。在做单点登录的时候，就可以用这种结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 list list数据结构，可以做简单的消息队列的功能。另外一个是，可以利用lrange命令，做基于redis的分页功能（lrange mylist 0 10），性能极佳，用户体验很好。 set set数据结构存放的是一堆不重复的集合。所以可以做全局去重的功能。可以使用交集、并集、差集等操作，可以计算共同喜好，全部喜好，自己独有喜好等功能。 sorted set sorted set多了一个权重参数score，集合中的元素能够按照score进行排列。可以做排行榜应用，取TOP N操作，延时任务，范围查找。 5、 redis的过期策略以及内存淘汰机制分析：假如redis只能存 5G 数据量，写入了 10G 的数据，就会删除 5G 数据，怎么删除，按照什么策略删除。 redis 采用 定期删除+惰性删除策略 为什么不用定时删除策略 定时删除，用一个定时器来负责监视 key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在高并发场景下，CPU 应该将时间应用在处理请求上，而不是删除 key，因此不采用这一种策略。 定期删除+惰性删除是如何工作的？ 定期删除，redis 默认每隔100ms检查是否有过期的key，有过期的key直接删除。需要说明的是，redis不是每隔100ms将所有的key检查一次，而是随机抽取进行检查（如果每隔100ms将所有的key检查一次，redis应该已经爆炸💥了），因此如果只采取定期删除策略，会导致很多过期的key没有被删除。于是，惰性删除派上用场了。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间，那么是否过期了？如果过期此时就会被删除。（感觉就是一波亡羊补牢的操作，不过能这样还是挺 NB 的） 采用定期删除+惰性删除就没其他问题了？？？ 不是的！，如果定期删除没有删除key。然后你也没有去get这个key，也就是说惰性删除没有生效。这样，redis的内存占用会越来越大。此时就应该采用内存淘汰机制。 在reids.conf中有一行配置： 1# maxmemory-policy volatile-lru 这个配置就是内存淘汰策略，一下是几种淘汰策略，解析一下： noeviction：当内存不足以容纳新写入的数据时，新写入操作会报错。这个应该没人用吧😂 allkeys-lru：当内存不足以容纳新写入的数据时，在键空间中，移除最近最少使用的key（least recently used）。推荐使用这一种策略。 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候采用。不推荐 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐 //TODO why volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐。 如果没有设置expire的key，不满足先决条件prerequisites；那么volatile-lru，volatile-random和volatile-ttl策略的行为和noeviction（不删除）基本一致。 6、redis 和数据库双写一致性问题分析：一致性问题是分布式常见的问题，还可以分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致问题。注意：有一个前提，如果对数据有强一致性要求，数据就不能存放在缓存。我们所做的一切只能保证最终一致性。另外，我们所做的方案从根本上来说，只能降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。 1首先，采取正确的更新策略，先更新数据库，再删除缓存。其次，因为可能存在缓存删除失败的问题，提供一个补偿措施即可，例如利用消息队列。 7、如何应对缓存穿透和缓存雪崩问题分析：这个问题，一版高并发的项目可能会遇到，流量几百万左右。 缓存穿透 有人故意去请求缓存中不存在的数据，导致所有的请求怼到数据库上，从而数据库连接异常。 解决方案： 1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁之后，再去请求数据库。没得到锁，则休眠一端时间重试。 2、采用异步更新策略，无论是key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，就异步起一个线程去读数据库，更新缓存。这个方案，需要做缓存预热（羡慕启动前，先预加载缓存）操作。 3、提供一个能迅速判断请求是否有效的拦截机制。比如，利用布隆过滤器（bloom filter），内部维护一系列合法有效的key。迅速判断出，请求所携带的key是否合法有效。如果不合法，则直接返回。 缓存雪崩 缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都到了数据库上，从而导致数据库连接异常。 解决方案： 1、给缓存的失效时间，加上一个随机值，避免集体失效。 2、使用互斥锁，但是吞吐量明显下降了。 3、使用双缓存，两个缓存，A，B。缓存 A 的失效时间是20分钟，缓存 B 不设失效时间。自己做缓存预热操作。然后细分一下几个小点： 从缓存 A 读数据库，有则直接返回。 A 没有读到数据，直接从 B 读数据，有则直接返回，并异步启动一个更新线程。 更新线程同时更新缓存 A 和缓存 B。 8、如何解决 Redis 的并发竞争问题分析：这个问题大致就是，同时又多个子系统去set一个key。一般很多回答是使用redis的事务机制。但是因为我们的生产环境，一般都是redis集群环境，做了数据分片操作。你一个事务中所有涉及到多个key操作的时候，这个key不一定都存储在同一个redis-server上。因此，redis 的事务机制，有点鸡肋。（// TODO） 如下所示： 1、如果这个key操作，不要求顺序，可以准备一个分布式锁，大家去抢锁，抢到了锁就做set操作即可。 2、如果这个key操作，要求顺序，假设有一个key1，系统 A 需要将key1设置为valueA，系统 B 需要将 key1设置为valueB，系统 C 需要将key1设置为valueC。 我们期望按照key1的value值按照valueA–&gt;valueB–&gt;valueC的顺序变化。这时候我们在写入数据库的时候，就需要保存一个时间戳。假设时间戳如下： 123系统A key1 &#123;valueA 3:00&#125;系统B key1 &#123;valueB 3:05&#125;系统C key1 &#123;valueC 3:10&#125; 那么根据上述，假设是系统 B 先抢到锁，将key1设置为{valueB 3:05}。那么接下来，如果 A 抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那么久不做set操作了。 其他方法，如利用队列，将set方法变成串行访问也可以。 本文出处孤独烟，个人只是一字一字的解读，理解前辈总结的经验。我认为只是大致浏览一篇博文，看一篇公众号整理的干货文章，是没有用的，还是要多理解，多实践，加深记忆，才能深刻，涓涓细流，沁人心脾，强劲壮骨。这种方式只是我个人的学习方式，可能比较笨重，比较慢，但好记性不如烂笔头。这也是为什么写博客的原因。有幸","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Redis","slug":"Code/Redis","permalink":"http://xiaoqinghua.site/categories/Code/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://xiaoqinghua.site/tags/Redis/"}]},{"title":"iterm2 小技巧","slug":"iterm2小技巧","date":"2017-03-12T06:47:35.000Z","updated":"2018-08-24T07:44:19.096Z","comments":true,"path":"iterm2小技巧.html","link":"","permalink":"http://xiaoqinghua.site/iterm2小技巧.html","excerpt":"","text":"iterm2 小技巧标签1234- 新建标签：command + t- 关闭标签：command + w- 切换标签：command + 数字 或者command + 方向键- 切换全屏：command + enter 分屏1234- 垂直分屏 command + d- 水平分屏 command + shift + d- 查看历史命令 command + ;- 查看剪粘板历史 command + shift + h 其他1234567891011- 清除当前行 ctrl + u- 到行首 ctrl + a- 到行尾 ctrl + e- 搜索历史命令 ctrl + r- 删除当前光标的字符 ctrl + d- 删除光标之前的字符 ctrl + h- 删除光标之前的单词 ctrl + w- 删除到文本末尾 ctrl + k- 交换光标处字符 ctrl + t- 清屏 command + r- command + f 所选中的内容会被自动复制 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"Iterm2","slug":"Code/Iterm2","permalink":"http://xiaoqinghua.site/categories/Code/Iterm2/"}],"tags":[{"name":"Iterm2","slug":"Iterm2","permalink":"http://xiaoqinghua.site/tags/Iterm2/"}]},{"title":"白夜行","slug":"白夜行","date":"2016-11-14T12:06:59.000Z","updated":"2018-08-18T04:52:34.510Z","comments":true,"path":"白夜行.html","link":"","permalink":"http://xiaoqinghua.site/白夜行.html","excerpt":"","text":"白夜行世界上有两样东西不能直视，一是太阳，二是人心。 我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。 曾经拥有的东西被夺走，并不代表就会回到原来没有那种东西的时候。 一天中，太阳会升起，同时还会落下。人生也一样，有白天和黑夜，只是不会像太阳那样，有定时的日出和日落。有些人一辈子都活在太阳的照耀下，有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在自己身上的光芒消失。 一个把平等置于自由智商的社会两者都得不到。一个把自由置于平等之上的社会，很大程度上可以两者兼得。 只有在一个方面，联邦储备体系始终如一。这边是，他把所有问题都归咎于超出自己控制能力的外部影响，而把所有合意的结果都归功于自己。由此他继续维持着那个谬传，说私人经济是不稳定的；而他的所作所为却不断证明了这一事实即政府才是导致今天经济不稳定的主要根源。 公众和经济学家观念的改变，均源自对实际情况的误解。当时只有少数人知道，而我们现在都知道，大萧条并非是私有制企业失败所导致而是因为政府并未成功履行它被赋予的责任。这些责任用《合众国宪法》第一天第八款的话来说，便是“铸造货币，调节其价值，并厘定外币价值”。不幸的是，在第九章我们将看到，政府在管理货币方面的失败不仅是历史上的一桩怪事，而且任是今日之事实。 没有什么比时间更有说服力了，因为时间无需通知我们就可以改变一切。 最初我们来到这个世界上是因为不得不来的。最终我们离开这个世界，是因为我们不得不走。 以笑的方式哭，在死亡的伴随下活着。 作为一个词语，“活着”在我们中国的语言里充满了力量，它的力量不是来自于喊叫，也不是来自于进攻，而是忍受，去忍受生命赋予我们的责任，去忍受现实给我们的幸福和苦难，无聊和平庸。 做人不能忘记四条，话不要说错，床不要睡错，门槛不要踏错，口袋不要摸错。 人是为活着本身而活着，不是为了活着之外的任何事物所活着。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"影响力","slug":"影响力","date":"2016-10-27T13:35:02.000Z","updated":"2018-08-18T04:52:26.982Z","comments":true,"path":"影响力.html","link":"","permalink":"http://xiaoqinghua.site/影响力.html","excerpt":"","text":"影响力越喜欢一个人，受这个人的影响越大。 一样原本没有什么吸引力的东西，突然间变得很有诱惑力，就因为很快你就得不到它了。 在接受了别人的好处之后，人们很亲依就会答应一个在没有负债心里时一定会拒绝的请求。即便是一个不请自来的好处，一旦被接收，也会制造出一种负债感。 当我们对自己缺乏信心时，当形式变得不很明朗时，当不确定占了上风时，我们最有可能以别人的行为作为自己行动的参照。与我们类似的人的行为对我们最有影响力。 一旦我们做了一个决定，或选择了一种立场，就会有发自内心以及来自外部的压力来迫使我们与此保持一致。在这种压力下，我们总是希望以实际行动来证明我们以前的决定是正确的。 cazhulafu brother上帝与魔鬼在那里搏斗，战斗便在人们心中。 在现实主义者身上，并不是奇迹产生信仰，而是信仰产生奇迹。 在大多数情况下，人们，甚至恶人，要比我们想象中的他们幼稚的多，天真的多。其实我们也一样。 对自己说谎和听自己说谎的人会落到这样的地步：无论在自己身上还是周围，即使有真理，他也无法辨别，结果将是既不自重，也不尊重别人。一个人如果对谁都不尊重，也就没有了爱；在没有爱的情况下想要消遣取乐，无非放纵情欲，耽于原始的感官享受，在罪恶的泥潭中完全堕落成畜类，而一切都始于不断的对人和对己说谎。对自己说谎的人最容易怄气。 电子游戏让人上瘾的全部原因只有一个。创造一个属于我们自己的世界。我想不出有什么东西比做一个神更能让人上瘾的了。 人们都说没有什么能逃脱冷库的热力学第二定律，宇宙的最后归宿是一片热死寂。但这不是故事的全部，宇宙在沉寂的同事，也在热闹起来，从旧物中带来新生、增加复杂性的新层次。宇宙充满了无尽的创造力。熵和进化，两者就像两支时间之矢，一头拖着我们退入无穷的黑暗，一头在拉扯我们走向永恒的光明。 网络把隐私从道德领域转移到了市场领域——隐私成了一种商品。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"少有人走的路","slug":"少有人走的路","date":"2016-09-27T13:39:24.000Z","updated":"2018-08-18T04:52:23.081Z","comments":true,"path":"少有人走的路.html","link":"","permalink":"http://xiaoqinghua.site/少有人走的路.html","excerpt":"","text":"少有人走的路一辈子真的很短，远没有我们想象的那么长，永远真的没有多远，所有不妨对爱你的好一点，也对自己好一点，今天是你的枕畔人，明天就可能是你的陌生人，如果这一辈子来不及好好爱，就更不要指望下辈子还能遇见。 想让别人真正爱你，只有让自己成为值得爱的人。 承受痛苦是走向成熟的必经之路，任何人都不能回避。 大部分的恐惧与懒惰有关，这句话我深以为然。我么常常会害怕改变，其实都是因为自己太懒了，懒得去适应新环境，懒得去学习新知识，涉足新的领域，但如果总是这样的话，如何能让自己成熟起来呢？ 多数人认为勇气就是不害怕。现在让我来告诉你，不害怕不是勇气，它只是脑损伤。勇气是尽管你感觉害怕，但仍能迎难而上；尽管你感觉痛苦，但仍能直接面对。 所谓自律，是以积极而主动地态度，去解决人生痛苦的重要原则，主要包括四个方面：推迟满足感、承担责任、尊重事实、保持平衡。 未来简史更重要的\b，当以大数据、人工智能为代表的科学技术发展的日益成熟，人类将面临着从进化到智人以来最大的一次改变，绝大部分人将沦为“无价值的群体”，只有少部分人能进化成特质发生改变的”神人”。 未来，人类将面临\b着三大问题：生物本身就是算法，生命是不断处理数据的过程；意识与智能的分离；拥有大数据积累的外部环境将比我们自己更了解自己。如何看待这三大问题，以及如何采取应对措施，将直接影响着人类未来的发展。 天才在左，疯子在右时间是不流逝的，流逝的是我们。 哲学家与疯子的区别，一个知识在想，另一个真的去做了。 孤独感时常体现在一种矛盾上，就是你经常处于一种挣扎状态：既希望别人关心、管住自己，又不知道该怎么去接触和回应别人。于是干脆直接抗拒，科室骨子里又是那么的渴望被了解和关注，而且矛盾到嘴里说出来的和心里想的完全相反。 只有当你认真的去做一件事情的时候，才会发现自己的灵魂和灵魂深处。 如果有一天你看到我疯了，其实是你疯了。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"Mysql存储IP地址细节","slug":"Mysql存储IP地址细节","date":"2016-08-20T03:58:41.000Z","updated":"2018-08-24T07:42:51.279Z","comments":true,"path":"Mysql存储IP地址细节.html","link":"","permalink":"http://xiaoqinghua.site/Mysql存储IP地址细节.html","excerpt":"","text":"Mysql存储IP地址细节ipv4:数据库可以设计成: 1`ipv4` INT UNSIGNED; 插入 ipv4 地址1INSERT INTO `table` (`ipv4`) VALUES (INET_ATON(&quot;127.0.0.1&quot;)); 查询 ipv41SELECT INET_NTOA(`ipv4`) FROM `table`; 注意实测一定要设计成 UNSIGNED ，MySQL 的 INT 存储范围是 -2147493648到2147493647(SIGNED) ，0到4294967295(UNSIGNED)”而 ipv4 中 255.255.255.255被INET_ATON 成 int 之后是 4294967295 刚好是最大值。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Code","slug":"Code","permalink":"http://xiaoqinghua.site/categories/Code/"},{"name":"MySql","slug":"Code/MySql","permalink":"http://xiaoqinghua.site/categories/Code/MySql/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"http://xiaoqinghua.site/tags/MySql/"}]},{"title":"乌合之众","slug":"乌合之众","date":"2016-08-08T12:23:54.000Z","updated":"2018-08-18T04:52:12.967Z","comments":true,"path":"乌合之众.html","link":"","permalink":"http://xiaoqinghua.site/乌合之众.html","excerpt":"","text":"乌合之众人一到群体中，智商就严重降低，为了获得认同感，个体原意抛弃是非，用智商去换取那份让人倍感安全的归属感。 群体不善推理，却又急于行动。 我们始终有一种错觉，以为我们的感情源自我们的内心。 我们以为自己是理性的我们以为自己的一举一动都是有其道理的。但事实上，我们绝大多数的日常行为，都是一些我们自己根本无法了解的隐蔽动机结果。 个人一旦成为群体中的一员，他所作所为就不会再承担责任，这是每个人都会暴露出自己不受约束的一面。群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。 所谓信仰，它让一个人变得完全受自己的梦想奴役。 月亮与六便士上帝的磨盘转的很慢，却磨得很细。 在爱情的事上，如果你考虑起自尊心来，那只能有一个原因：实际上你还是最爱你自己。 我们每个人生在世界上都是孤独的。每个人都困在一座铁塔里，只能靠一些符号同别人传达自己的思想。而这些符号并没有共同的价值，因此他们的意义是模糊的、不确定的。我嗯非常可怜地想把自己心中的财富传送给别人，但他们却没有接受这财富的能力。因此我们只能孤独地行走，尽管身体相互依傍却并不在一起，既不了解别人也不能被别人所了解。 海伯利安看了这本书，你就不会再看《三体》了。 我去旅行是因为我决定要去，并不是因为风景。 趁年轻，好好利用这个机会，尽力去尝遍所有的痛苦，这种事可不是一辈子什么时候都可以遇到的。 人不是从娘胎里出来就一成不变的，相反，生活会逼他一次又一次的脱胎换骨。 真正的爱情需要什么？需要两个人在一起是轻松快乐的，没有压力的。 诚实的生活方式其实是按照自己身体的意愿行事，饿的时候吃饭，爱的时候不必撒谎。 苏菲的世界生命本来就是悲伤而严肃的。我们来到这个美丽的世界里，彼此相逢，彼此问候，并结伴同游一段短暂的时间。然后我们就是去了对方，然后就莫名其妙的消失了，就像我们莫名其妙地来到世界一般。 你太习惯这个世界了，所以你对任何事情都不感到惊奇。 真正的知识来自内心，而不是得自别人的传授。同时唯有出自内心的知识，才能使人拥有真正的智慧。 理智和经验都缺失时，就会出现一个真空，这个真空可以有信仰填补。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"娱乐至死","slug":"娱乐至死","date":"2016-07-03T05:26:41.000Z","updated":"2018-08-18T04:52:19.219Z","comments":true,"path":"娱乐至死.html","link":"","permalink":"http://xiaoqinghua.site/娱乐至死.html","excerpt":"","text":"娱乐至死有两种方法可以让文化精神枯萎，一种是奥威尔式——文化成为一种监狱，另一种是赫胥黎式——文化成为一场滑稽戏。 我们将死于我们所热爱的东西。 \b真理不能，也从来没有，毫无修饰地存在。它必须穿着\b某种合适的外衣出现，否则就可能得不到承认，这也正说明了“真理”是一种文化偏见。 过去，人们为了解决生活中的问题儿搜索信息，现在是为了让无用的\b信息派上用场而制造问题。 一个人学到的\b最重要的东西是学习的方法。 1984他们不到觉悟的时候，就不会造反。他们不造反，就不会有觉悟。 如果你感到保持人性是值得的，即使这不能有任何结果，你也已经打败了他们。 上等人的目标是保持他们的地位。中等人的目标是要通上等人交换地位。下等人的特点始终是，他们劳苦之余无暇旁顾，偶尔才顾到日常生活以外的事，因此如果他们有目标的话，无非就是取消一切差别，建立一个人人平等的社会。 我们很明白没有人会为了废除权利而夺取权利。权力不是手段，权力是目的。建立专政不是为了保卫革命，反过来进行革命是为了建立专政。 zoo越喜欢上什么，一旦突然失去它，我的心就越为悲泣。这样反反复复地，我还任要忍耐这种苦楚不得不继续度过剩余的生命。这是多么残酷的事情啊。与其如此，不如干脆把我当做什么都不爱，没有人心徒有人形的样子。 爱的越深刻，死的意义就越沉重，失落感也会越深刻。 我脸上越是挤出明亮的笑容，我的内心就越是变的荒芜。 我对别人的存在感到恐惧，我觉得自己对别人谄媚的行径也会因为这个。被别人讨厌，被别人看不起，被别人嘲笑，对我来说都是难以忍受的痛苦，于是为了逃避这些行为，我再自己的内心养了那样一只丑陋的动物。如果没有别人在这个世界上，只有我自己一个人，那将是多么轻松啊。 ps:这本书太沉重了吧😨，配个阳光明媚的 landspace 吧。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]},{"title":"百年孤独","slug":"百年孤独","date":"2016-06-27T09:26:41.000Z","updated":"2018-08-18T04:52:38.820Z","comments":true,"path":"百年孤独.html","link":"","permalink":"http://xiaoqinghua.site/百年孤独.html","excerpt":"","text":"百年孤独无论走到哪里，都应该记住，过往的一切都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧\b而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实，唯有孤独永恒。 生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。 我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折中涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。 买下一张永久车票，登上一辆永无终点的列车。 所有人都显得很激进，用自己的方式想尽办法派遣寂寞，事实上仍是延续自己的孤独。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。 作者：xiaoqinghua 有幸联系地址：https://github.com/smartzer版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://xiaoqinghua.site/tags/Life/"}]}]}